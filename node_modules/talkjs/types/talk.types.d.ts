
/**
 * App metadata, such as global custom fields for the entire app.
 *
 * @public
 */
declare interface AppMetadata {
    readonly id: string;
    readonly custom: CustomData;
}

/**
 * @public
 * @hidden due to being empty
 */
export declare interface BlurEvent {
}

/**
 * A messaging UI for just a single conversation
 *
 * There is no way for the user to switch between conversations
 * (but you can change the active conversation through {@link Chatbox.select}).
 * Create a Chatbox through {@link Session.createChatbox} and then call
 * {@link Chatbox.mount} to show it.
 * @public
 */
export declare interface Chatbox extends UIBox {
    /**
     * Renders the UI inside a DOM element specified by `container`.
     *
     * @remarks
     * `container` must either be a DOM Element (as returned by e.g. `document.getElementById`) or
     * a JQuery object with a single element.
     */
    mount(container: HTMLElement | JQuery | null): Promise<void>;
    /**
     * Destroys the chatbox.
     *
     * @remarks
     * Call this before removing the chatbox container from the DOM.
     */
    destroy(): void;
}

/**
 * @alias UIBox Chatbox
 * @public
 */
export declare interface ChatboxOptions {
    /**
     * Controls the text direction (for supporting right-to-left languages such as Arabic and Hebrew). TalkJS tries
     * to determine the appropriate text direction from the parent page, but if that does not work or you want to
     * explicitly control it, you can override it here. Defaults to "rtl".
     */
    dir?: "rtl" | "ltr";
    /**
     * Sets the message input box to the given text.
     * You can use this to suggest a certain initial message to be sent. The user can still edit it before hitting "send".
     *
     * @deprecated We recommend using {@link MessageField.setText} before mounting the chatbox to precisely control when message suggestions are shown.
     */
    messageSuggestion?: string;
    /**
     * Used to control if the Chat Header is displayed in the UI. Defaults to true.
     */
    showChatHeader?: boolean;
    /**
     * Controls what text appears in the chat title, in the header above the messages.
     * Defaults to `"participants"`.
     *
     * (also see {@link this.chatSubtitleMode} and {@link InboxOptions.feedConversationTitleMode})
     */
    chatTitleMode?: "subject" | "participants";
    /**
     * Controls what text appears in the chat subtitle, right below the chat title.
     * No subtitle is displayed when the conversation has no subject set or when set to `null`.
     * Defaults to `"subject"`.
     *
     * (also see {@link this.chatTitleMode} and {@link InboxOptions.feedConversationTitleMode})
     */
    chatSubtitleMode?: "subject" | "participants" | null;
    /**
     * TalkJS leverages `iframe`s behind the scenes and therefore not all services that you use in your app will work out of the box.
     * This option adds support for a number of services to help you use them. Let us know if you're missing any.
     */
    thirdparties?: ThirdPartyOptions;
    /**
     * Used to control which messages are shown in the message list, depending on a type, origin
     * or custom message attributes.
     *
     * See {@link MessagePredicate} for all available options.
     *
     * You can also modify the filter on the fly using {@link UIBox.setMessageFilter}.
     */
    messageFilter?: MessagePredicate;
    /**
     * TalkJS can translate conversations to the current user's locale using Google Translate.
     * This option specifies which conversations should be translated in this UI. You can pass a boolean to enable/disable
     * translation for all conversations, "auto" to enable translation on conversations where users have different locales,
     * or you can pass an array of {@link ConversationBuilder}s or conversation Ids to be translated.
     * This feature is only available on the Premium plan and above. Make sure you add your Google Translate API key in the dashboard.
     */
    translateConversations?: boolean | "auto" | string[] | ConversationBuilder[];
    /**
     * Set this to `true` to show a translation toggle in all conversations.
     * Set this to `"auto"` to show a translation toggle in conversations where there are participants with different locales.
     * This setting defaults to `false`, meaning that no toggles will be shown.
     * In order to use this, you must be on the Premium plan, and set a Google Translate API key in the dashboard.
     */
    showTranslationToggle?: boolean | "auto";
    /**
     * Setting this to `true` disp
     */
    /**
     * Settings that affect the behavior of the message field
     */
    messageField?: MessageFieldOptions;
}

/** @public
* @hidden due to being empty
*/
export declare interface CloseEvent {
}

/**
 * Encapsulates an active conversation between two parties.
 *
 * @remarks
 * Use this object to send system messages to the conversation or to programmatically select a
 * conversation by passing it to {@link Inbox.select}.
 *
 * Conversation objects are created with the deprecated {@link Session.getOrStartConversation}
 * method.
 *
 *
 * @public
 * @deprecated
 */
export declare interface Conversation {
    /**
     * The ID of the conversation
     */
    readonly id: string;
    /**
     * @hidden
     * An array of {@link Participant | Participants} in the conversation.
     */
    participants: Array<Participant>;
    /**
     * Legacy - please use {@link Conversation.subject} instead.
     */
    readonly topicId?: string;
    /**
     * An optional conversation subject which is displayed in the chat header
     */
    subject?: string | null;
    /**
     * Optional custom conversation meta data
     */
    custom?: {
        [name: string]: string | null;
    } | null;
    welcomeMessages?: Array<string> | null;
    /**
     * An optional URL to a photo which will be shown as the photo for the conversation.
     */
    photoUrl?: string | null;
}

/** @public */
export declare type ConversationAccessLevel = "ReadWrite" | "Read" | "None";

/**
 * Conversation attributes that can be set using {@link ConversationBuilder.setAttributes}
 * @public
 */
export declare interface ConversationAttributes {
    /**
     * A human-readable subject of the conversation. Supports formatted links in a Markdown-style syntax, e.g.
     * `Beautiful <https://example.com/booking/18644|home by the sea>!`.
     *  URLs and email addresses are made clickable, and emojis made to work cross-platform.
     */
    subject?: string | null;
    /**
     * The URL of a photo to be used for this conversation in the TalkJS UI in case there are more than 2 participants
     * (TalkJS shows the photo of the other participant in a 1-on-1 conversation)
     */
    photoUrl?: string | null;
    /**
     * Custom metadata that is stored with the conversation
     */
    custom?: {
        [key: string]: string | null;
    } | null;
    /**
     * Messages which are sent at the beginning of a chat.
     * In this case the messages will appear as system messages.
     */
    welcomeMessages?: Array<string> | null;
}

/**
 * A Conversation Builder represents a conversation that is about to be created, fetched, or updated.
 * You can use this object to set up or modify a conversation before showing it.
 *
 * Note: any changes you make here will not be sent to TalkJS immediately.
 * Instead, instantiate a TalkJS UI using methods such as {@link Session.createInbox}.
 *
 * @public
 */
export declare interface ConversationBuilder {
    /**
     * An optional conversation subject which will be displayed in the chat header.
     */
    subject?: string | null;
    /**
     * Allows custom conversation metadata to be stored in the form `{ [name: string]: string }`
     */
    custom?: {
        [name: string]: string | null;
    } | null;
    /**
     * An optional URL to a photo which will be shown as the photo for the conversation.
     */
    photoUrl?: string | null;
    /**
     * Messages which are sent at the beginning of a chat.
     * In this case the messages will appear as system messages.
     */
    welcomeMessages?: Array<string> | null;
    /**
     * Sets a participant of the conversation.
     *
     * @remarks
     * This method is idempotent and can be called multiple times.
     *
     * @param user - A `User` object that identifies the person who is a participant of the
     * conversation. The user is uniquely identified by their id; all other fields (name, photo etc)
     * are overwritten in the TalkJS database each  time they change.
     * @param settings - An optional setting of participation, can be an initial `access` right or
     * if user should be notified.
     */
    setParticipant(user: User, settings?: Partial<ParticipationSettings>): void;
    /**
     * Used to set certain attributes for a specific conversation
     *
     * @remarks
     * For example:
     *
     * ```
     * conversation.setAttributes({subject: "Booking question"});
     * conversation.setAttributes({custom:
     *   {
     *     sold: "true",
     *     itemId: "720"
     *   }
     * });
     *
     * ```
     *
     */
    setAttributes(attributes: ConversationAttributes): void;
    /**
     * Sends a text message in a given conversation.
     * @param text - The message body that is to be sent.
     */
    sendMessage(text: string, options: SendMessageOptions): Promise<void>;
}

/** @public */
export declare interface ConversationData {
    /**
     * The ID of the conversation
     */
    id: string;
    /**
     * Contains custom metadata for the conversation if it was set using {@link ConversationBuilder.custom}.
     */
    custom: CustomData;
    /**
     * Contains the conversation subject if it was set using {@link ConversationBuilder.subject}.
     */
    subject: string | null;
    /**
     * @deprecated
     * Please use {@link ConversationBuilder.subject} instead.
     */
    topicId: string | null;
    /**
     * Contains the URL of a photo was set using {@link ConversationBuilder.subject}.
     */
    photoUrl: string | null;
    /**
     * One or more welcome messages that will display to the user as a SystemMessage
     */
    welcomeMessages: Array<string> | null;
}

/**
 * Allows you to filter conversations down to a specific subset.
 *
 * Use with {@link Inbox.setFeedFilter} or pass {@link InboxOptions.feedFilter} to {@link Session.createInbox}.
 */
/** @public */
export declare interface ConversationPredicate {
    /**
     * Only select conversations that the current user as specific access to.
     *
     * Must be an 2-element array of `[operator, operand]` structure. Valid operators are:
     * `"=="`, `"!="`, `"oneOf"`, and `"!oneOf"`.
     *
     * The operand must be either a string (one of `"ReadWrite"`, `"Read"` or `"None"`) or an array of strings (for the `oneOf` operators).
     *
     * Example:
     * ```js
     * // to remove conversations that the user has no access to anymore, do:
     * { access: ["!=", "None"] }
     * ```
     */
    access?: FieldPredicate<ConversationAccessLevel>;
    /**
     * Only select conversations that have particular custom fields set to particular values.
     *
     * @remarks
     * Every key must correspond to a key in the custom conversation data that you set (by passing
     * `custom` to {@link ConversationBuilder.setAttributes}). It is not necessary for all
     * conversations to have these keys.
     *
     * Each value must be one of the following:
     *
     * A string, equal to `"exists"` or `"!exists"`
     *
     * A 2-element array of `[operator, operand]` structure.  The operand must be either a
     * string or an array of strings (for the `oneOf` operators). Valid operators are:
     * `"=="`, `"!="`, `"oneOf"`, and `"!oneOf"`.
     *
     * Examples, assuming you have set a `category` custom field on your conversations:
     *
     * ```js
     * // only show conversations that have no category set:
     * { custom: { category: "!exists" } }
     *
     * // only show conversations of category "shoes"
     * { custom: { category: ["==", "shoes"] } }
     *
     * // only show conversations either category "shoes" or "sandals"
     * { custom: { category: ["oneOf", ["shoes", "sandals"] ] } }
     *
     * // only show conversations about shoes that are marked visible.
     * // this assumes you also have a custom field called `visibility`
     * { custom: { category: ["==", "shoes"], visibility: ["==", "visible" ] } }
     * ```
     */
    custom?: {
        [key: string]: CustomFieldPredicate;
    };
    /**
     * Set this field to only select conversations that have, or don't have any, unread messages.
     */
    hasUnreadMessages?: boolean;
}

/** @public
 *
 * This represents the interface of the event triggered from {@link Inbox.on | Inbox.on("conversationSelected")}.
 */
export declare interface ConversationSelectedEvent {
    /**
     * The current TalkJS {@link User}
     */
    me: UserData;
    /**
     * The other participants in the conversation that are not the current user
     */
    others?: Array<UserData>;
    /**
    * The current conversation object
    */
    conversation: ConversationData | null;
}

/**
 * @public
 * Used to store additional metadata on users, conversations and messages
 */
export declare interface CustomData {
    /**
     * Any number of key/value pairs of your choosing to be stored along with the associated resource.
     * You can use custom data for all kinds of purposes, such as customizing a user's email notification text, transmitting contextual user data, or making email login tokens.
     *
     * Both the key and the value must be strings; arbitrarily deeply nested JSON is not supported. Example:
     *
     * ```
     * {"country":"nl", "itemId": "720"}
     * ```
     */
    [key: string]: string;
}

/** @public */
export declare type CustomFieldPredicate = FieldPredicate<string> | "exists" | "!exists";

/**
 * @public
 * This event is triggered when {@link https://talkjs.com/docs/Features/Notifications/Browser_Notifications.htm | desktop notifications} are toggled.
*/
export declare interface DesktopNotificationToggledEvent {
    /**
     * Boolean indicating if desktop Notifications are enabled or not
     */
    isEnabled: boolean;
}

/**
 * @public
 */
declare enum ErrorCode {
    NOTIFICATIONS_PERMISSION_DENIED = 0,
    NOTIFICATIONS_NOT_SUPPORTED = 1
}

/** @public */
export declare type FieldPredicate<T> = ["==" | "!=", T] | ["oneOf" | "!oneOf", T[]];

/**
 * @public
 * @hidden due to being empty
 */
export declare interface FocusEvent {
}

/**
 *  @public
 *  @hidden
*/
export declare interface FullStoryOptions {
    /**
     * Fullstory hostname
     */
    host?: string;
    /**
     * Fullstory organization ID
     */
    org: string;
}

/**
 * Retrieves global App metadata.
 *
 * @remarks This function may be called before instantiating a Talk.Session, and
 * is not authenticated. Please consider all app metadata (eg global custom
 * fields) to be public data, and ensure that you do not store any sensitive
 * data in app custom fields.
 *
 * You can change App metadata using the TalkJS REST API.
 *
 * Note that this function cannot be used to verify whether an app ID exists; it
 * always returns valid data, even for nonexistent app IDs.
 */
export declare function getAppMetadata(appId: string): Promise<AppMetadata>;

/**
 * @public
 */
declare interface GetOrStartOptionsA {
    topicId?: string;
    /** Only used if `topicId` is given: a human-readable subject
    * of the conversation. Supports formatted links in a Markdown-style syntax, e.g.
    * `Beautiful <https://yoursite.com/booking/18644|home by the sea>!`.
    * URLs and email addresses are made clickable, and emojis made to work
    * cross-platform.
    */
    subject?: string;
    /** Additional parameter to store the custom fields, that you
    * want to use in the email template. E.g. `custom.specialToken`
    */
    custom?: {
        [name: string]: string;
    };
    /** Photo to be used for this conversation in the TalkJS UI. */
    photoUrl?: string;
    welcomeMessages?: string[];
}

declare interface GetOrStartOptionsB {
    participants: Array<User>;
    /** Only used if `topicId` is given: a human-readable subject
    * of the conversation. Supports formatted links in a Markdown-style syntax, e.g.
    * `Beautiful <https://yoursite.com/booking/18644|home by the sea>!`.
    * URLs and email addresses are made clickable, and emojis made to work
    * cross-platform.
    */
    subject?: string;
    /** Additional parameter to store the custom fields, that you
    * want to use in the email template. E.g. `custom.specialToken`
    */
    custom?: {
        [name: string]: string;
    };
    /** Photo to be used for this conversation in the TalkJS UI. */
    photoUrl?: string;
}

/**
 * HTML Panel
 * HTML panels should only be created through {@link Inbox.createHtmlPanel}, {@link Chatbox.createHtmlPanel} or {@link Popup.createHtmlPanel}.
 * @public
 */
export declare interface HtmlPanel {
    /**
     * Shows the panel if it's hidden.
     */
    show(): void;
    /**
     * Hides the panel if it's visible.
     */
    hide(): void;
    /**
     * Changes the panel height.
     *
     * @remarks
     * If you don't need to change the height after the panel is created, you can pass it as an option to the `createHtmlPanel`.
     */
    setHeight(height: number): void;
    /**
     * Returns `true` if the panel is visible, `false` if it's hidden or destroyed
     */
    isVisible(): boolean;
    /**
     * Destroys the HTML panel
     */
    destroy(): Promise<void>;
}

/** @public */
export declare interface HtmlPanelOptions {
    /**
     * Required. URL you want to load inside the HTML panel.
     * Url can be absolute ("https://www.example.com/register-form.html") or relative ("register-form.html").
     * We recommend using same origin pages to have better control of the page.
     * Learn more about HTML Panels and same origin pages {@link https://talkjs.com/docs/Customizations/HTML_Panels.html | here}.
     */
    url: string;
    /**
     * Optional, defaults to 300 (px).
     */
    height?: number;
    /**
     * Optional, defaults to true. Set false if you don't want the HTML panel to be shown after
     * `createHtmlPanel` is called. You can change the visibility of the HTML panels by
     * calling `.hide()` or `.show()` on the `HtmlPanel` instance returned by `createHtmlPanel`'s promise.
     */
    show?: boolean;
    /**
     * Either a `Conversation` object
     * (as returned from `getOrCreateConversation`) or the `id` field of
     * a conversation (which you may have stored in your database).
     * If given the HTML panel called will only show up for that conversation.
     */
    conversation?: Conversation | ConversationBuilder | string;
}

/**
 * The main messaging UI. Chats on the left, messages on the right.
 * Create an Inbox through {@link Session.createInbox} and then call {@link Inbox.mount} to show it.
 * @public
 */
export declare interface Inbox extends UIBox {
    /**
     * Used to control which conversations are shown in the conversation feed, depending on access
     * level, custom conversation attributes or message read status.
     *
     * See {@link ConversationPredicate} for all available options.
     *
     * You can also set the filter in {@link Session.createInbox} using {@link InboxOptions.feedFilter}.
     */
    setFeedFilter(filter: ConversationPredicate): void;
    /**
     * Renders the UI inside a DOM element specified by `container`. `container`
     * must either be a DOM Element (as returned by e.g. `document.getElementById`) or
     * a JQuery object with a single element.
     */
    mount(container: HTMLElement | JQuery | null): Promise<void>;
    /**
     * Triggers when a user clicks a conversation in the feed. It's triggered *before* a conversation is selected.
     * You can prevent the conversation from being actually selected by calling `event.preventDefault()`.
     *
     * @namedoverload on("selectConversation")
     */
    on(eventType: "selectConversation", handler: (event: SelectConversationEvent) => void): void;
    /**
     * Triggers when a conversation is selected.
     *
     * @remarks
     * This event is emitted in 4 situations:
     *
     * 1. When the Inbox loads;
     *
     * 2. When the user clicks on a conversation in the feed;
     *
     * 3. When something in your code calls {@link Inbox.select}
     *
     * 4. When the Inbox is shown in mobile view, and the user clicks the `< Inbox` button.
     *
     * Note that the event's `conversation` field will be `null` when the inbox loads (and the user
     * has no conversations), when calling {@link Inbox.select} with `null` to deselect any
     * conversation, and in case 4 above.
     *
     * @namedoverload on("conversationSelected")
     */
    on(eventType: "conversationSelected", handler: (event: ConversationSelectedEvent) => void): void;
    /**
     * Triggers when the user toggles the "Desktop Notifications" toggle in the inbox feed header.
     * @namedoverload on("desktopNotificationToggled")
     */
    on(eventType: "desktopNotificationToggled", handler: (event: DesktopNotificationToggledEvent) => void): void;
    /**
     *
     * Triggers when the user sends a message using the TalkJS UI
     * @namedoverload on("sendMessage")
     */
    on(eventType: "sendMessage", handler: (event: SendMessageEvent) => void): void;
    /**
     * Triggers when the chat UI gets focused (i.e. the user clicks/taps anywhere inside it).
     * @namedoverload on("focus")
     */
    on(eventType: "focus", handler: (event: FocusEvent) => void): void;
    /**
     * Triggers when the chat UI gets unfocused (i.e. the user clicks/taps anywhere outside it).
     * @namedoverload on("blur")
     */
    on(eventType: "blur", handler: (event: BlurEvent) => void): void;
    /**
     * Triggers when the user toggles translation in a conversation
     * @namedoverload on("translationTriggered")
     */
    on(eventType: "translationToggled", handler: (event: TranslationToggledEvent) => void): void;
    /**
     * Used to stop listening to TalkJS events.
     *
     * @remarks
     * Stops listening for the _selectConversation_ event
     * @param handler - The handler function must be the same handler function that was passed to `on("selectConversation")`
     */
    off(eventType: "selectConversation", handler: (event: SelectConversationEvent) => void): void;
    /**
     * Used to stop listening to TalkJS events.
     *
     * @remarks
     * Stops listening for the _conversationSelected_ event
     * @param handler - The handler function must be the same handler function that was passed to `on("conversationSelected")`
     */
    off(eventType: "conversationSelected", handler: (event: ConversationSelectedEvent) => void): void;
    /**
     * Used to stop listening to TalkJS events.
     *
     * @remarks
     * Stops listening for the _desktopNotificationToggled_ event
     * @param handler - The handler function must be the same handler function that was passed to `on("desktopNotificationToggled")`
     */
    off(eventType: "desktopNotificationToggled", handler: (event: DesktopNotificationToggledEvent) => void): void;
    /**
     * Used to stop listening to TalkJS events.
     *
     * @remarks
     * Stops listening for the _focus_ event
     * @param eventType
     * @param handler - The handler function must be the same handler function that was passed to `on("focus")`
     */
    off(eventType: "focus", handler: () => void): void;
    /**
     * Used to stop listening to TalkJS events.
     *
     * @remarks
     * Stops listening for the _blur_ event
     * @param eventType
     * @param handler - The handler function must be the same handler function that was passed to `on("blur")`
     */
    off(eventType: "blur", handler: () => void): void;
    /**
     * Used to stop listening to TalkJS events.
     *
     * @remarks
     * Stops listening for the _sendMessage_ event
     * @param eventType
     * @param handler - The handler function must be the same handler function that was passed to `on("sendMessage")`
     */
    off(eventType: "sendMessage", handler: (event: SendMessageEvent) => void): void;
    /**
     * Used to stop listening to TalkJS events.
     *
     * @remarks
     * Stops listening for the _translationToggled_ event
     * @param eventType
     * @param handler - The handler function must be the same handler function that was passed to `on("translationToggled")`
     */
    off(eventType: "translationToggled", handler: () => void): void;
    /**
     * Destroys an inbox and removes all event listeners it has running. Call this before removing the inbox
     * container from the DOM.
     */
    destroy(): void;
}

/**
 * @alias UIBox Inbox
 * @public
 */
export declare interface InboxOptions extends ChatboxOptions {
    /**
     *  Makes the inbox start up with the given Conversation. Can be passed a value of the type ConversationBuilder (returned by getOrCreateConversation) or the string value of the conversation id. Conversation can be deselected on startup by passing a null value. Passing undefined means that the last conversation (or "no chats yet page") will be displayed.
     */
    selected?: Conversation | ConversationBuilder | string | null;
    /**
     * Controls if the feed header containing the toggle to enable desktop notifications is shown.
     * Defaults to true.
     */
    showFeedHeader?: boolean;
    /**
     * Controls how a chat is displayed in the feed of chats.
     *
     * Note: when set to `"subject"` but a conversation has no subject set, then
     * TalkJS falls back to `"participants"`.
     *
     * When not set, defaults to `"auto"`, which means that in group conversations
     * that have a subject set, the subject is displayed and otherwise the participants.
     *
     * (also see {@link this.chatSubtitleMode} and {@link this.chatTitleMode})
     */
    feedConversationTitleMode?: "participants" | "subject" | "auto";
    /**
     * Controls whether the user navigating between conversation should count
     * as steps in the browser history. Defaults to true, which means that if the user
     * clicks the browser's back button, they go back to the previous conversation
     * (if any).
     */
    useBrowserHistory?: boolean;
    /**
     * Used to control which conversations are shown in the conversation feed, depending on access
     * level, custom conversation attributes or message read status.
     *
     * See {@link ConversationPredicate} for all available options.
     *
     * You can also modify the filter on the fly using {@link Inbox.setFeedFilter}.
     */
    feedFilter?: ConversationPredicate;
    /**
     * Whether to show a "Back" button at the top of the chat screen on mobile devices.
     */
    showMobileBackButton?: boolean;
}

/**
 * @public
 * @hidden due to being empty
 */
export declare interface JQuery {
    [index: number]: HTMLElement;
    length: number;
    jquery: string;
}

/**
 * @public
 * A TalkJS message, used as part of {@link Session.on}
*/
export declare interface Message {
    /**
     * Contains the {@link ConversationData} that the message belongs to.
     */
    conversation: ConversationData;
    /**
     * 'true' if the message was sent by the current user.
     */
    isByMe: boolean;
    /**
     * The senderID (userID) for the person that sent the message
     */
    senderId: string | null;
    /**
     * The {@link User} that sent the message
     */
    sender: UserData | null;
    /**
     * Contains the message's content
     */
    body: string;
    /**
     * Specifies if if the message is media (file), text or a shared location
     */
    type: "media" | "text" | "location";
    /**
     * UNIX timestamp specifying when the message was sent (UTC, in milliseconds)
     */
    timestamp: number;
    /**
     * 'true' if the message has been read, 'false' has not been seen yet
     */
    read: boolean;
    /**
     * Determines how this message was sent: respectively, Via a web browser (or mobile Webview), via the REST API, via reply-to-email, or using the import API.
     */
    origin: string;
    /**
     * Custom metadata that is stored with the conversation
     */
    custom: CustomData;
    /**
     * Only given if the message's `type` equals `"media"`. An object with the URL and filesize (in bytes) of the given file.
     */
    attachment: {
        url: string;
        size: number;
    } | null;
    /**
     * Only given if the message's `type` equals `"location"`. An array of two numbers which represent the longitude and latitude of this location, respectively. Only given if this message is a shared location.
     *
     * Example:
     *
     * ```js
     * [51.481083, -3.178306]
     * ```
     */
    location: [number, number] | null;
}

/**
 * Encapsulates the message entry field tied to the currently selected conversation.
 * @public
 */
export declare interface MessageField {
    /**
     * Focuses the message entry field. Note that on mobile devices, this will cause the on-screen
     * keyboard to pop up, obscuring part of the screen.
     */
    focus(): void;
    /**
     * Sets the message entry field to `text`.
     *
     * Useful if you want to guide your user with message suggestions. If you want to start a UI
     * with a given text showing immediately, call this method before calling {@link Inbox.mount}
     *
     * @param text - The text to be displayed in the message entry field
     */
    setText(text: string): void;
    /**
     * Sets the visibility of the Message Field to a given value or to a certain predicate.
     *
     * See {@link MessageFieldOptions.visible} for examples.
     *
     * @param visible - boolean or a more advanced predicate.
     */
    setVisible(visible: boolean | ConversationPredicate): void;
}

/**
 * @public
 */
export declare interface MessageFieldOptions {
    /**
     * If set to `true`, pressing the enter key sends the message (if there is text in the message
     * field). When set to `false`, the only way to send a message is by clicking or touching the
     * "Send" button. Defaults to `true`.
     */
    enterSendsMessage?: boolean;
    /**
     * Specifies whether the
     * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea#attr-spellcheck | spellcheck}
     * attribute is set on the message field. Note that setting this to `true` may also enable
     * autocorrect on some mobile devices. Defaults to `false`.
     */
    spellcheck?: boolean;
    /**
     * Overrides the "placeholder" in the message field, which displays a dimmed text when no text has yet been entered.
     *
     * Defaults to "Say something..." (or a {@link https://talkjs.com/docs/Features/Multiple_Languages.html | translation thereof}).
     */
    placeholder?: string;
    /**
     * Determines whether the message field is visible. Pass either a boolean (`false` to hide it),
     * or a {@link ConversationPredicate}. The latter approach lets you show/hide the message field
     * based on properties of the current conversation.
     *
     * For example, to hide the message field when the current user has no write access to the
     * current conversation, do the following:
     *
     * ```js
     * // this predicate holds iff the current user's `access` to the current conversation is
     * // set to "ReadWrite"`:
     * const showMessageField = { access: ["==", "ReadWrite"] };
     * session.createInbox(conversation, { messageField: { visible: showMessageField } });
     * ```
     *
     * Defaults to `true`.
     */
    visible?: boolean | ConversationPredicate;
}

/**
 * Lets you show only specific messages in the chat panel of a Chatbox, Inbox or Popup.
 *
 * @public
 */
export declare interface MessagePredicate {
    /**
     * Only show messages that are sent by a sender that has all of the given properties
     *
     * For example:
     *
     * ```js
     * // Only show messages sent by users with the role of 'admin' and if the user ID is 1.
     * {sender: {role: ["==", "admin"], id: ["==", "1"]}}
     * ```
     */
    sender?: {
        id?: FieldPredicate<string>;
        custom?: {
            [key: string]: CustomFieldPredicate;
        };
        locale?: FieldPredicate<string>;
        role?: FieldPredicate<string>;
    };
    /**
     * Only show messages of a given type, for example:
     *
     * ```js
     * {type: ["==", "SystemMessage"]}
     * ```
     *
     */
    type?: FieldPredicate<"UserMessage" | "SystemMessage">;
    /**
     * Only show messages that were sent by users (web), through the REST API (rest), via
     * reply-to-email (email) or via the import REST API (import).
     *
     * For example:
     *
     * ```js
     * // Don't show messages that were sent via the REST API
     * { origin: ["!=", "rest"] }
     * ```
     *
     */
    origin?: FieldPredicate<"web" | "rest" | "email" | "import">;
    /**
     * Only select messages that have particular custom fields set to particular values.
     *
     * @remarks
     * Every key must correspond to a key in the custom message data that you have set. It is not necessary for all
     * messages to have these keys.
     *
     * Each value must be one of the following:
     *
     * A string, equal to `"exists"` or `"!exists"`
     *
     * A 2-element array of `[operator, operand]` structure.  The operand must be either a
     * string or an array of strings (for the `oneOf` operators). Valid operators are:
     * `"=="`, `"!="`, `"oneOf"`, and `"!oneOf"`.
     *
     * Examples, assuming you have set a `category` custom field on your messages:
     *
     * ```js
     * // Only show messages that have no category set:
     * { custom: { category: "!exists" } }
     *
     * // Only show messages of that have the category "shoes"
     * { custom: { category: ["==", "shoes"] } }
     *
     * // Only show messages that have the 'topic' either "inquiry" or "reservation"
     * { custom: { topic: ["oneOf", ["inquiry", "reservation"] ] } }
     *
     * // Only show messages about shoes that are marked visible.
     * // this assumes you also have a custom field called `visibility`
     * { custom: { category: ["==", "shoes"], visibility: ["==", "visible" ] } }
     * ```
     */
    custom?: {
        [key: string]: CustomFieldPredicate;
    };
}

/**
 *
 * NOTE: If this function changes make sure to update the documentation in `The_Talk_Object.md`
 *
 * A helper method to predictably compute a Conversation ID based on participants' ids in the given conversation.
 * Use this method if you want to simply create a conversation between two users,
 * not related to a particular product, order or transaction.
 *
 * The order of the parameters does not matter.
 * For example, `Talk.oneOnOneId("a", "b")` yields the same result as `Talk.oneOnOneId("b", "a")`.
 *
 * This method takes the following steps:
 * 1. Take two ids of users and put them in an array
 * 2. Sort them lexicographically
 * 3. JSON encode them
 * 4. hash the result using SHA1, return the first 20 characters
 *
 * In pseudocode, this is what this function does:
 *
 *     var sorted = [me.id, other.id].sort()
 *     var encoded = JSON.encode(sorted)
 *     var hash = sha1(encoded)
 *     return truncate(hash, 20)
 *
 * For a PHP implementation, see https://gist.github.com/eteeselink/4dc3ad32cc478986ff2b5b6361a1825f.
 * {@link https://talkjs.com/?chat | Get in touch} if you need our help implementing this in your backend language.
 * @public
 */
export declare function oneOnOneId(me: User | string, other: User | string): string;

/**
 * @public
 * @hidden due to being empty
 */
export declare interface OpenEvent {
}

/**
 * @public
 * @hidden
 * Contains information about an individual participant
*/
export declare interface Participant {
    /**
     * A Talk JS {@link User}
     */
    readonly user: User;
    /**
     * Contains access and notification settings for a given user's participation to a given conversation. Used in ConversationBuilder.setParticipant.
     */
    readonly participationSettings: Partial<ParticipationSettings>;
}

/**
 * Specifies access and notification settings for a given user's participation
 * to a given conversation. Used in {@link ConversationBuilder.setParticipant}.
 * @public
 */
export declare interface ParticipationSettings {
    /**
     * Specifies the participant's access permission for a conversation. See {@link ConversationBuilder.setParticipant}
     */
    access?: "Read" | "ReadWrite";
    /**
     * Specifies the participants's notification settings. See {@link ConversationBuilder.setParticipant}
     */
    notify?: boolean;
}

/**
 * A messaging UI for just a single conversation.
 *
 * There is no way for the user to switch between conversations
 * (but you can change the active conversation through {@link Popup.select}).
 * Create a Popup through {@link Session.createPopup} and then call
 * {@link Popup.mount} to show it.
 * @public
 */
export declare interface Popup extends UIBox {
    /**
     * Mounts the Popup to the parent container
     *
     */
    mount(options?: {
        show?: boolean;
    }): Promise<void>;
    /**
     * Destroys the Popup
     *
     * @remarks
     * Call this before removing the Popup container from the DOM.
     */
    destroy(): void;
    /**
     * Shows the Popup, previously hidden or mounted with a parameter `show: false`
     */
    show(): void;
    /**
     * Closes the Popup, but doesn't remove it from the DOM
     */
    hide(): void;
    /**
     * Triggers when the popup is opened by the user.
     *
     * @remarks
     * Only gets triggered when the user performs an action to open the popup.
     * This event is not triggered when you call {@link Popup.show} or when you
     * {@link Popup.mount} it with the `{show: true}` option.
     *
     * @namedoverload on("open")
     */
    on(eventType: "open", handler: (event: OpenEvent) => void): void;
    /**
     * Triggers when the popup is closed by the user.
     *
     * @remarks
     * Only gets triggered when the user performs an action to close the popup,
     * eg when they click the "X" on the launcher or,
     * {@link PopupOptions.showCloseInHeader | if enabled}, in the popup header.
     * This event is not triggered when you call {@link Popup.hide} or
     * {@link Popup.destroy}.
     *
     * @namedoverload on("close")
     */
    on(eventType: "close", handler: (event: CloseEvent) => void): void;
    /**
     * Triggers when the user sends a message using the TalkJS UI
     * @namedoverload on("sendMessage")
     */
    on(eventType: "sendMessage", handler: (event: SendMessageEvent) => void): void;
    /**
     * Triggers when the chat UI gets focused (i.e. the user clicks/taps anywhere inside it)
     * @namedoverload on("focus")
     */
    on(eventType: "focus", handler: (event: FocusEvent) => void): void;
    /**
     * Triggers when the chat UI gets unfocused (i.e. the user clicks/taps anywhere outside it)
     * @namedoverload on("blur")
     */
    on(eventType: "blur", handler: (event: BlurEvent) => void): void;
    /**
     * Triggers when the user toggles translation in a conversation
     * @namedoverload on("translationTriggered")
     */
    on(eventType: "translationToggled", handler: (event: TranslationToggledEvent) => void): void;
    /**
     * Used to stop listening to TalkJS events.
     *
     * @remarks
     * Stops listening for the _open_ event
     * @param eventType
     * @param handler - The handler function must be the same handler function that was passed to `on("open")`
     */
    off(eventType: "open", handler: (event: OpenEvent) => void): void;
    /**
     * Used to stop listening to TalkJS events.
     *
     * @remarks
     * Stops listening for the _close_ event
     * @param eventType
     * @param handler - The handler function must be the same handler function that was passed to `on("close")`
     */
    off(eventType: "close", handler: (event: CloseEvent) => void): void;
    /**
     * Used to stop listening to TalkJS events.
     *
     * @remarks
     * Stops listening for the _sendMessage_ event
     * @param eventType
     * @param handler - The handler function must be the same handler function that was passed to `on("sendMessage")`
     */
    off(eventType: "sendMessage", handler: (event: SendMessageEvent) => void): void;
    /**
     * Used to stop listening to TalkJS events.
     *
     * @remarks
     * Stops listening for the _focus_ event
     * @param eventType
     * @param handler - The handler function must be the same handler function that was passed to `on("focus")`
     */
    off(eventType: "focus", handler: () => void): void;
    /**
     * Used to stop listening to TalkJS events.
     *
     * @remarks
     * Stops listening for the _blur_ event
     * @param eventType
     * @param handler - The handler function must be the same handler function that was passed to `on("blur")`
     */
    off(eventType: "blur", handler: () => void): void;
    /**
     * Used to stop listening to TalkJS events.
     *
     * @remarks
     * Stops listening for the _translationToggled_ event
     * @param eventType
     * @param handler - The handler function must be the same handler function that was passed to `on("translationToggled")`
     */
    off(eventType: "translationToggled", handler: () => void): void;
}

/**
 * @alias UIBox Popup
 * @public
 */
export declare interface PopupOptions extends ChatboxOptions {
    /**
     * If enabled, the Popup will reopen every time
     * the user navigates to another page. This way, a conversation can continue
     * while the user browses around. Set to `false` to disable this behavior.
     *
     * Defaults to false.
     */
    keepOpen?: boolean;
    /**
     * Specifies whether to show a round
     * launcher and/or close button beneath the popup in the right bottom corner
     * of the page.
     *
     * @remarks
     * `"close-only"`: show a close button beneath the popup, but don't show a launch button
     *
     * `"always"`: show a launch button when the popup is closed, show a close button when it is visible
     *
     * `"never"`: never show a launcher
     *
     * Note: if you choose `"never"` you may want to override the positioning of the popup as well.
     * Just tune the `__talkjs_popup` class in your CSS.
     *
     * Ignored on mobile, where the popup fills the entire screen so the value is effectively `"never"`.
     *
     * Defaults to `"always"`.
     *
     */
    launcher?: "close-only" | "always" | "never";
    /**
     * Whether to show the "x" icon in the popup header to close the popup.
     * "auto", which is the default value means `true` on mobile and to `false` on desktop.
     */
    showCloseInHeader?: boolean | "auto";
}

/** @public */
export declare const ready: Promise<void>;

/**
 * @public
 * Event data triggered from {@link Inbox.on | Inbox.on("selectConversation")}.
 */
export declare interface SelectConversationEvent {
    /**
         * The current TalkJS {@link User}
         */
    me: UserData;
    /**
     * The other participants in the conversation that are not the current user
     */
    others: Array<UserData>;
    /**
    * The current conversation object
    */
    conversation: ConversationData;
    /**
     * Prevents the clicked conversation from being selected.
     */
    preventDefault(): void;
}

/**
 * @public
 * The event triggered when listening for the sendMessage event on the {@link Inbox}, {@link Chatbox} and {@link Popup}.
 * This event is triggered before the message is sent to TalkJS, allowing you to modify the contents of the message or its metadata by
 * using `override()`.
*/
export declare interface SendMessageEvent {
    /**
     * The message that was sent
     */
    message: SentMessage;
    /**
     * The current TalkJS user
     */
    me: UserData;
    /**
     * The current conversation object
     */
    conversation: ConversationData;
    /**
     * This function allows you to modify the contents of the message or its metadata before the message is sent
     */
    override: ({ text, custom }: {
        text?: string;
        custom?: CustomData;
    }) => void;
}

/**
 * @public
 */
export declare interface SendMessageOptions {
    /**
     * An object with any custom data that you may wish to associate with this message. The custom data is sent back to you via webhooks and the REST API.
     */
    custom?: CustomData;
}

/**
 * @public
 * A message that was sent to TalkJS
*/
export declare interface SentMessage {
    /**
     * The message ID of the message that was sent
     */
    id: string | undefined;
    /**
     * The ID of the conversation that the message belongs to
     */
    conversationId: string;
    /**
     * Identifies the message as either a {@link https://talkjs.com/docs/Reference/Concepts/Messages.html | User message} or
     * {@link https://talkjs.com/docs/Reference/Concepts/System_Messages.html | System message}
     */
    type: "UserMessage" | "SystemMessage";
    /**
     * Contains an Array of {@link User.id}'s that have read the message
     */
    readBy: string[];
    /**
     * Contains the user ID for the person that sent the message
    */
    senderId: string;
    /**
     * Contains the message's text
     */
    text?: string;
    /**
     * Only given if the message contains a file. An object with the URL and filesize (in bytes) of the given file.
     */
    attachment?: {
        url: string;
        size: number;
    };
    /**
     * Only given if the message contains a location. An array of two numbers which represent the longitude and latitude of this location, respectively. Only given if this message is a shared location.
     *
     * Example:
     *
     * ```js
     * [51.481083, -3.178306]
     * ```
     */
    location?: [number, number];
}

/**
 * A session represents a user's active browser tab. It also authenticates your app
 * with TalkJS.
 *
 * @public
 */
export declare class Session {
    private readonly _eventEmitter;
    private _uiBoxes;
    private _alive;
    /**
     * Holds information about unread conversations. Lets your app be notified
     * when the active user receives a new message.
     */
    readonly unreads: Unreads;
    /** The TalkJS {@link User} associated with the current user in your application. */
    readonly me: User;
    /** Your TalkJS `AppId` that can be found your TalkJS {@link https://talkjs.com/dashboard | dashboard}. */
    readonly appId: string;
    private readonly _sessionId;
    /**
     * Creates a TalkJS Session.
     * @public
     */
    constructor(options: SessionOptions);
    /**
     * Verifies whether the `appId` is valid.
     *
     * @remarks
     * Returns a Promise of a boolean, never rejects.
     */
    hasValidCredentials(): Promise<boolean>;
    private _maybeRestorePopup;
    private _trackWindowFocus;
    /**
     * @deprecated This method will keep being supported, but for new projects,
     * we recommend that you use {@link Session.getOrCreateConversation}.
     *
     * Returns a `Conversation` object that encapsulates a conversation
     * between `me` (given in the constructor) and `other`.
     *
     * @param other - A `User` object that identifies the person to converse with.
     * The user is uniquely identified by their id; all other fields (name, photo
     * etc) are overwritten in the TalkJS database each  time they change.
     * @param options - Options used for getOrStartConversation
     */
    getOrStartConversation(other: User, options?: GetOrStartOptionsA): Conversation;
    /**
     * @deprecated This method will keep being supported, but for new projects,
     * we recommend that you use {@link Session.getOrCreateConversation}.
     *
     * Returns a `Conversation` object that encapsulates a conversation between `me` (given in the
     * constructor) and zero or more other `participants`.
     *
     * @param conversationId - A unique identifier for this conversation. Any user with access to
     *                         this ID can join this conversation.
     *
     * @param options - Options used for getOrStartConversation
     *
     */
    getOrStartConversation(conversationId: string, options?: GetOrStartOptionsB): Conversation;
    private _maybeAddMyParticipant;
    /**
     * A method used to either fetch or create a conversation.
     *
     * @remarks
     * Returns a `ConversationBuilder` object that encapsulates a conversation
     * between `me` (given in the constructor) and zero or more other `participants`.
     * Use {@link ConversationBuilder.setParticipant} and {@link ConversationBuilder.setAttributes}
     * on the returned object to further set up your conversation.
     *
     * @param conversationId - A unique identifier for this conversation, such as a channel name or topic ID.
     * Any user with access to this ID can join this conversation. {@link https://talkjs.com/docs/Reference/Concepts/Conversations.html | Read about how to choose a good conversation ID for your use case}.
     * If you want to make a simple one-on-one conversation, consider using {@link oneOnOneId} to generate one.
     */
    getOrCreateConversation(conversationId: string): ConversationBuilder;
    /**
     * Creates an Inbox UI
     *
     * @remarks
     * The Inbox is the main UI component of TalkJS. It shows a user's conversation
     * history and it allows them to write messages. You typically want to call the
     * `mount` method after creating the Inbox to make it visible on your app.
     *
     * Call `createInbox` on the messaging page of your app.
     *
     * @param options - Optional. Use these to finetune the behavior of the Inbox.
     */
    createInbox(options?: InboxOptions): Inbox;
    /**
     * Creates a Chatbox UI
     *
     * @remarks
     * The Chatbox is a slimmer version of the Inbox. It shows a single conversation,
     * without means to switch between conversations. You typically want to call the
     * `mount` method after creating the Chabox to make it visible on your app.
     *
     * Call `createChatbox` on any page you want to show a chatbox of a single conversation.
     *
     * Passing `null` for `selectedConversation` parameter will initialize TalkJS upon
     * mounting, but will *not* display a UI yet. You need to call `chatbox.select(conversation)`
     * in order to render the UI with a conversation. This is useful for preloading the
     * chatbox in some situations.
     *
     * When you call `createChatbox()` with `undefined` or without a parameter, it is going to render the user's latest active conversation in the UI upon mounting.
     *
     * @param selectedConversation - Select the conversation to show in the UI.
     * @param options - Optional. Use these to finetune the behavior of the Chatbox.
     */
    createChatbox(selectedConversation: Conversation | ConversationBuilder | null | undefined, options?: ChatboxOptions): Chatbox;
    /**
     * Creates a Popup UI
     *
     * @remarks
     * The Popup is a beautiful, well positioned box containing a conversation. It shows a single conversation,
     * without means to switch between conversations. In order to have a popup on each site you need to call
     * `createPopup` on any page you want to show a popup with the conversation.
     *
     * Passing `null` for `selectedConversation` parameter will initialize TalkJS upon
     * mounting, but will *not* display a UI yet. You need to call `Popup.select(conversation)`
     * in order to render the UI with a conversation. This is useful for preloading the
     * Popup in some situations.
     *
     * If you call `createPopup()` without a parameter, or when passing undefined, it is going to render the latest conversation in the UI upon mounting.
     * @param conversation - The conversation to show on the UI.
     */
    createPopup(conversation: Conversation | ConversationBuilder | null | undefined, options?: PopupOptions): Popup;
    /**
     * Used to configure TalkJS to use a theme hosted on the same location as your application for development.
     *
     * @remarks
     * Tells TalkJS to use a theme hosted on the same location as your application (e.g. localhost:8000/).
     * e.g. Call `talkSession.syncThemeForLocalDev("/assets/css/talkjs-theme.css")`
     * just before you call `createInbox` or `createChatbox`. TalkJS will then use the specified file instead of using a theme created in the dashboard.
     *
     * @param path - The path to the theme's CSS file
     */
    syncThemeForLocalDev(path: string): void;
    /**
     * Sets desktop notification on or off.
     *
     * @remarks
     * Has the same effect as toggling the "Desktop notification" toggle in the TalkJS Inbox UI. Use
     * this function to replicate that toggle elsewhere in your UI if you're using TalkJS in a mode
     * that doesn't show this toggle.
     *
     * @param isEnabled - Whether notifications should be enabled.
     * @param alertOnFailure - Whether to show an alert message when enabling notifications fails.
     *
     * @returns a promise that'll resolve if the change succeeds, but rejects if anything goes
     * wrong. If anything goes wrong, the promise will be rejected with a {@link TalkError}, which has a
     * `code` property. Possible values for it are:
     *
     * - `Talk.ErrorCode.NOTIFICATIONS_PERMISSION_DENIED`: The browser or the user didn't grant you
     *   permission to send notifications.
     *
     * - `Talk.ErrorCode.NOTIFICATIONS_NOT_SUPPORTED`: The browser doesn't support desktop
     *   notifications.
     */
    setDesktopNotificationEnabled(isEnabled: boolean, { alertOnFailure }?: {
        alertOnFailure?: boolean;
    }): Promise<void>;
    private _cleanUIBoxes;
    /**
     * Registers mobile device, one user can be connected to one mobile device.
     *
     * @remarks
     * Related method: {@link Session.unregisterDevice | Session.unregisterDevice}
     */
    registerDevice({ platform, pushRegistrationId }: {
        platform: "ios" | "android";
        pushRegistrationId: string;
    }): Promise<void>;
    /**
     * Unregisters mobile device, one user can be connected to one mobile device.
     *
     * @remarks
     * Related method: {@link Session.registerDevice | Session.registerDevice}
     */
    unregisterDevice(): Promise<void>;
    private _selectConversationInActiveInbox;
    /**
     *
     * Used to listen to TalkJS session events
     *
     * @remarks
     * A "message" event is fired every time a message is sent or received by the
     * current user (even if no TalkJS UI is visible). Your `handler` function is passed
     * a {@link Message} object with some information about each message and its conversation.
     *
     * For an example, see {@link https://gist.github.com/eteeselink/607e585eb40be76f2ed150d4090e5261}
     *
     * Related method: {@link Session.off | Session.off}
     *
     */
    on(eventType: "message", handler: (message: Message) => void): void;
    /**
     * Used to stop listening to specific TalkJS session events
     *
     * @remarks
     * Call this with the same `eventType` and `handler` to stop receiving events.
     *
     * Related methods: {@link Session.on | Session.on}
     */
    off(eventType: "message", handler: (message: Message) => void): void;
    /**
     * Disconnects all websockets, removes all UIs, and invalidates this session.
     * You cannot use any objects that were created in this session after you destroy it.
     *
     * If you want to use TalkJS after having called `destroy()` you must instantiate a new
     * Talk.Session instance.
     */
    destroy(): void;
    /**
     * Returns a list of all active {@link Popup} objects linked to this
     * session.
     *
     * @remarks
     * Includes popups actively created using {@link createPopup}, and also
     * popups created on page load, if {@link PopupOptions.keepOpen} was set to
     * `true` on an earlier page.
     *
     * Only includes popups that are still mounted in the DOM. So if you call
     * `createPopup()` but later remove its container element (or an ancestor of
     * the container), then the `Popup` object will have been made invalid and
     * is therefore not included in the results.
     */
    getPopups(): Popup[];
    /**
     * Returns a list of all active {@link Inbox} objects linked to this
     * session.
     *
     * @remarks
     * Only includes inboxes that are still mounted in the DOM. So if you call
     * `createInbox()` but later remove its container element (or an ancestor of
     * the container), then the `Inbox` object will have been made invalid and
     * is therefore not included in the results.
     */
    getInboxes(): Inbox[];
    /**
     * Returns a list of all active {@link Chatbox} objects linked to this
     * session.
     *
     * @remarks
     * Only includes chatboxes that are still mounted in the DOM. So if you call
     * `createChatbox()` but later remove its container element (or an ancestor of
     * the container), then the `Chatbox` object will have been made invalid and
     * is therefore not included in the results.
     */
    getChatboxes(): Chatbox[];
}

/**
 * @public
 */
export declare interface SessionOptions {
    /** Your app's unique TalkJS id. Get it from the dashboard. */
    appId: string;
    /**
     * A `User` object that identifies the currently active user.
     * The user is uniquely identified by their id; all other fields
     * (name, photo, etc) are overwritten in the TalkJS database each
     * time they change.
     * Alternatively, only pass a user ID (as a string) if you are certain
     * that the user object exists. */
    me: User;
    /**
     * If you use
     * {@link https://talkjs.com/docs/Features/Identity_Verification.html | Identitiy verification}
     * make sure you generate and use a signature.
     */
    signature?: string;
}

/**
 * TalkJS Error class, inherits from the global Error class.
 *
 * @remarks
 * TalkJS methods may throw (or reject promises with) instances of this class
 * if specific catchable information can be provided through the `code` property.
 *
 * @public
 */
export declare class TalkError extends Error {
    /**
     * Machine-readable error code
     */
    code: ErrorCode;
    /**
     * Human-readable error message
     */
    message: string;
}

/**
 * @public
 * Used to configure supported third-party integrations with TalkJS. See
 * {@link https://talkjs.com/docs/Features/Customizations/Third_Party_Integrations.html | third party integrations }
 *
 */
export declare interface ThirdPartyOptions {
    fullstory?: FullStoryOptions;
}

/**
 * @public
 * This event is triggered when the user toggles real-time message translation using the built-in toggle.
 */
export declare interface TranslationToggledEvent {
    /**
     * Boolean indicating if translation is enabled or not
     */
    isEnabled: boolean;
    /**
     * Conversation for which translation has been toggled
     */
    conversation: ConversationData;
}

/**
 * @public
 * @hidden
 */
export declare interface UIBox {
    /**
     * Switches the active conversation the conversation.
     *
     * @remarks
     * `conversation` can be either a {@link ConversationBuilder} object or a TalkJS
     * conversation id. Passing `null` means that the conversation will be de-selected in the UI and the message list will disappear.
     * Passing `undefined` means that the last conversation (or "no chats yet" page if there are no other conversations) will be rendered in the message list component.
     */
    select(conversation: string | Conversation | ConversationBuilder | null | undefined): void;
    /**
     * Encapsulates the message entry field tied to the currently selected conversation.
     */
    messageField: MessageField;
    /**
     * Triggers when the user sends a message using the TalkJS UI
     * @namedoverload on("sendMessage")
     */
    on(eventType: "sendMessage", handler: (event: SendMessageEvent) => void): void;
    /**
     * Triggers when the chat UI gets focused (i.e. the user clicks/taps anywhere inside it)
     * @namedoverload on("focus")
     */
    on(eventType: "focus", handler: (event: FocusEvent) => void): void;
    /**
     * Triggers when the chat UI gets unfocused (i.e. the user clicks/taps anywhere outside it)
     * @namedoverload on("blur")
     */
    on(eventType: "blur", handler: (event: BlurEvent) => void): void;
    /**
     * Triggers when the user toggles translation in a conversation
     * @namedoverload on("translationTriggered")
     */
    on(eventType: "translationToggled", handler: (event: TranslationToggledEvent) => void): void;
    /**
     * Used to stop listening to TalkJS events.
     *
     * @remarks
     * Stops listening for the _sendMessage_ event
     * @param eventType
     * @param handler - The handler function must be the same handler function that was passed to `on("sendMessage")`
     */
    off(eventType: "sendMessage", handler: (event: SendMessageEvent) => void): void;
    /**
     * Used to stop listening to TalkJS events.
     *
     * @remarks
     * Stops listening for the _sendMessage_ event
     * @param eventType
     * @param handler - The handler function must be the same handler function that was passed to `on("close")`
     */
    off(eventType: "sendMessage", handler: (event: SendMessageEvent) => void): void;
    /**
     * Used to stop listening to TalkJS events.
     *
     * @remarks
     * Stops listening for the _focus_ event
     * @param eventType
     * @param handler - The handler function must be the same handler function that was passed to `on("focus")`
     */
    off(eventType: "focus", handler: () => void): void;
    /**
     * Used to stop listening to TalkJS events.
     *
     * @remarks
     * Stops listening for the _blur_ event
     * @param eventType
     * @param handler - The handler function must be the same handler function that was passed to `on("blur")`
     */
    off(eventType: "blur", handler: () => void): void;
    /**
     * Used to stop listening to TalkJS events.
     *
     * @remarks
     * Stops listening for the _translationToggled_ event
     * @param eventType
     * @param handler - The handler function must be the same handler function that was passed to `on("translationToggled")`
     */
    off(eventType: "translationToggled", handler: () => void): void;
    /**
     * HTML Panels allow you to place a HTML document in an iframe in your chats, just above the entry box.
     *
     * @remarks
     * Using HTML Panels, you can extend TalkJS UIs to have anything from credit card payments to lead collection forms, or, for instance,
     * to show the product details of a marketplace transaction between your users.
     * See our {@link https://talkjs.com/docs/Features/Customizations/HTML_Panels.html | HTMLPanels documentation} for more info
     *
     */
    createHtmlPanel(options: HtmlPanelOptions): Promise<HtmlPanel>;
    /**
     * Sets metadata for the current session.
     *
     * @param visible - Manually sets the information about the visibility of TalkJS.
     * This is useful when TalkJS is hidden with CSS. TalkJS will assume that UIs
     * marked `visible: false` cannot be seen, and thus messages arriving on this UI will
     * not be marked as read until you set `visible` to true again.
     *
     * @param custom - Additional parameter to store the custom fields, that you
     * may want to use in the REST API call.
     */
    setPresence({ visible, custom }: {
        visible?: boolean;
        custom?: {
            [key: string]: string;
        };
    }): void;
    /**
     * Destroys an inbox and removes all event listeners it has running. Call this before removing the inbox
     * container from the DOM.
     */
    destroy(): void;
    /**
     * Please use {@link Session.setDesktopNotificationEnabled} instead.
     *
     * @remarks
     * This method will keep being supported, but for new projects,
     * we recommend that you use {@link Session.setDesktopNotificationEnabled}.
     *
     * Sets desktop notification on or off. Has the same effect as toggling the
     * "Desktop notification" toggle in the TalkJS Inbox UI. Use this function to replicate that
     * toggle elsewhere in your UI if you're using TalkJS in a mode that doesn't show this toggle.
     *
     * @deprecated
     */
    toggleDesktopNotifications(isEnabled: boolean): void;
    /**
     * Used to control which messages are shown in the message list, depending on a type, origin
     * or custom message attributes.
     *
     * See {@link MessagePredicate} for all available options.
     */
    setMessageFilter(filter: MessagePredicate): void;
    /**
     Enable or disable translation for a conversation.

     @param conversation - The conversation for which this hsould be be set. If not specified, the setting will be applied to the currently selected conversation.
     @param enabled - Whether translation should be enabled
     */
    setTranslationEnabledForConversation(conversation: string | ConversationBuilder, enabled: boolean): void;
    /**
     * Enable/disable translation by default. This setting is applied to any conversation for which you haven't set a specific value.
     * @param enabled - Whether conversations should be translated by default or not. Pass "auto" to enable translation for conversations
     * with users with different locales.
     */
    setTranslationEnabledDefault(enabled: boolean | "auto"): void;
    /**
     * The TalkJS search feature includes the ability to highlight certain words in messages. Call
     * this method to highlight certain words without having the user invoke the search feature.
     * Call again with an empty array to disable highlighting.
     *
     * Note: like the search feature, this option only works in TalkJS Premium and up.
     *
     * Also see {@link ChatboxOptions.highlightedWords}
     */
    setHighlightedWords(words: string[]): void;
}

/**
 * @public
 * Used as part of {@link Unreads.on}.
 */
export declare interface UnreadConversation {
    /**
     * Contains the last {@link Message} for an unread conversation.
     */
    lastMessage: Message;
}

/**
 * This object can notify you when the amount of unread conversations changes.
 * You can't instantiate it - instead, get an instance via {@link Session.unreads}.
 *
 * @public
 */
export declare interface Unreads {
    /**
     * A "change" event is fired on startup right after TalkJS loads, as well as every time the
     * amount of unread conversations changed. The `handler` is invoked with an array of objects with
     * limited information about each conversation, see {@link UnreadConversation}.
     *
     * @remarks
     * Related methods: {@link Unreads.off}
     */
    on(eventType: "change", handler: (messages: UnreadConversation[]) => void): void;
    /**
     * Call this with the same `eventType` and `handler` that you used for `on` to
     * stop receiving events.
     *
     * @remarks
     * Related methods: {@link Unreads.on}
     */
    off(eventType: "change", handler: (messages: UnreadConversation[]) => void): void;
}

/**
 * A user of your app. TalkJS uses the `id` to uniquely identify this user.
 * All other fields of a User are allowed to vary over time and the TalkJS database will update its fields accordingly.
 * @public
 */
export declare class User {
    /**
     * The unqiue ID which is used to identify the user in TalkJS
     */
    readonly id: string;
    /**
     * The User's name which will be displayed on the TalkJS UI
     */
    readonly name: string;
    /**
     * One or more email address belonging to the User. The email addresses will be used for {@link https://talkjs.com/docs/Features/Notifications/Email_Notifications/index.html | Email Notifications}
     * if they are enabled.
     */
    readonly email?: string | Array<string> | null;
    /**
     * One or more phone numbers belonging to the User. The phone number will be used for {@link https://talkjs.com/docs/Features/Notifications/SMS_Notifications.html | SMS Notifications }
     * (this feature requires standard plan and up).
     */
    readonly phone?: string | Array<string> | null;
    /**
     * The default message a user sees when starting a chat with that person
     */
    readonly welcomeMessage?: string | null;
    /**
     * An optional URL to a photo which will be displayed as the user's avatar
     */
    readonly photoUrl?: string | null;
    /**
     * TalkJS supports multiple sets of settings, called "roles". These allow you to change the behavior of TalkJS for different users.
     * You have full control over which user gets which configuration.
     */
    readonly role?: string | null;
    /**
     * @deprecated Please use {@link User.role} instead.
    */
    readonly configuration?: string | null;
    /**
     * Allows you to set custom metadata for the User
     */
    readonly custom?: {
        [name: string]: string | null;
    } | null;
    /**
     * Availability acts similarly to {@link User.welcomeMessage} but appears as a {@link https://talkjs.com/docs/Reference/Concepts/System_Messages.html | system message}.
     */
    readonly availabilityText?: string | null;
    /**
     * The locale field expects an {@link https://www.w3.org/International/articles/language-tags/ | IETF language tag}.
     * See the {@link https://talkjs.com/docs/Features/Multiple_Languages.html | localization documentation}.
     */
    readonly locale?: string | null;
    readonly __sync: boolean;
    /**
     * Create a TalkJS User
     *
     * @remarks
     * Use this constructor to synchronize user data with the TalkJS backend.
     *
     * The fields `id`, `name` and `email` are required.
     * A warning will be emitted if `role` is not specified.
     *
     * Set `email` to `null` if you want to use TalkJS without email fallback.
     */
    constructor(options: UserOptions);
    /**
     * Create a TalkJS User
     *
     * @remarks
     * Only use this constructor if you're sure
     * that a user by the given `id` already exists in TalkJS (for instance, because you
     * synchronized it via the REST API). Otherwise use the `new User(options: object):` constructor instead.
     */
    constructor(id: string | number);
}

declare interface UserData {
    /**
     * The unqiue ID which is used to identify the user in TalkJS
    */
    id: string | number;
    /**
     * The User's name which will be displayed on the TalkJS UI
     */
    name: string;
    /**
     * An optional URL to a photo which will be displayed as the user's avatar
     */
    photoUrl: string | null;
    /**
     * The default message a user sees when starting a chat with that person
     */
    welcomeMessage: string | null;
    /**
     * TalkJS supports multiple sets of settings, called "roles". These allow you to change the behavior of TalkJS for different users.
     * You have full control over which user gets which configuration.
     */
    role: string | null;
    /**
     * @deprecated Please use {@link UserData.role} instead.
    */
    configuration: string | null;
    /**
     * Allows you to set custom metadata for the User
     */
    custom: CustomData;
    /**
     * Availability acts similarly to {@link User.welcomeMessage} but appears as a {@link https://talkjs.com/docs/Reference/Concepts/System_Messages.html | system message}.
     */
    availabilityText: string | null;
    /**
     * The locale field expects an {@link https://www.w3.org/International/articles/language-tags/ | IETF language tag}.
     * See the {@link https://talkjs.com/docs/Features/Multiple_Languages.html | localization documentation}.
     */
    locale: string | null;
}

/**
 * @public
 */
declare interface UserOptions {
    /**
     * The unqiue ID which is used to identify the user in TalkJS
    */
    id: string | number;
    /**
     * The User's name which will be displayed on the TalkJS UI
     */
    name: string;
    /**
     * One or more email address belonging to the User. The email addresses will be used for {@link https://talkjs.com/docs/Features/Notifications/Email_Notifications/index.html | Email Notifications}
     * if they are enabled.
     */
    email?: string | Array<string> | null;
    /**
     * One or more phone numbers belonging to the User. The phone number will be used for {@link https://talkjs.com/docs/Features/Notifications/SMS_Notifications.html | SMS Notifications }
     * (this feature requires standard plan and up).
     */
    phone?: string | Array<string> | null;
    /**
     * An optional URL to a photo which will be displayed as the user's avatar
     */
    photoUrl?: string | null;
    /**
     * The default message a user sees when starting a chat with that person
     */
    welcomeMessage?: string | null;
    /**
     * TalkJS supports multiple sets of settings, called "roles". These allow you to change the behavior of TalkJS for different users.
     * You have full control over which user gets which configuration.
     */
    role?: string | null;
    /**
     * @deprecated Please use {@link UserData.role} instead.
    */
    configuration?: string | null;
    /**
     * Allows you to set custom metadata for the User
     */
    custom?: {
        [name: string]: string | null;
    } | null;
    /**
     * Availability acts similarly to {@link User.welcomeMessage} but appears as a {@link https://talkjs.com/docs/Reference/Concepts/System_Messages.html | system message}.
     */
    availabilityText?: string | null;
    /**
     * The locale field expects an {@link https://www.w3.org/International/articles/language-tags/ | IETF language tag}.
     * See the {@link https://talkjs.com/docs/Features/Multiple_Languages.html | localization documentation}.
     */
    locale?: string | null;
}
