{"ast":null,"code":"/*! Hammer.JS - v2.0.17-rc - 2019-12-16\n * http://naver.github.io/egjs\n *\n * Forked By Naver egjs\n * Copyright (c) hammerjs\n * Licensed under the MIT license */\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\n\n\nvar assign;\n\nif (typeof Object.assign !== 'function') {\n  assign = function assign(target) {\n    if (target === undefined || target === null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    var output = Object(target);\n\n    for (var index = 1; index < arguments.length; index++) {\n      var source = arguments[index];\n\n      if (source !== undefined && source !== null) {\n        for (var nextKey in source) {\n          if (source.hasOwnProperty(nextKey)) {\n            output[nextKey] = source[nextKey];\n          }\n        }\n      }\n    }\n\n    return output;\n  };\n} else {\n  assign = Object.assign;\n}\n\nvar assign$1 = assign;\nvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = typeof document === \"undefined\" ? {\n  style: {}\n} : document.createElement('div');\nvar TYPE_FUNCTION = 'function';\nvar round = Math.round,\n    abs = Math.abs;\nvar now = Date.now;\n/**\n * @private\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\n\nfunction prefixed(obj, property) {\n  var prefix;\n  var prop;\n  var camelProp = property[0].toUpperCase() + property.slice(1);\n  var i = 0;\n\n  while (i < VENDOR_PREFIXES.length) {\n    prefix = VENDOR_PREFIXES[i];\n    prop = prefix ? prefix + camelProp : property;\n\n    if (prop in obj) {\n      return prop;\n    }\n\n    i++;\n  }\n\n  return undefined;\n}\n/* eslint-disable no-new-func, no-nested-ternary */\n\n\nvar win;\n\nif (typeof window === \"undefined\") {\n  // window is undefined in node.js\n  win = {};\n} else {\n  win = window;\n}\n\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\nfunction getTouchActionProps() {\n  if (!NATIVE_TOUCH_ACTION) {\n    return false;\n  }\n\n  var touchMap = {};\n  var cssSupports = win.CSS && win.CSS.supports;\n  ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {\n    // If css.supports is not supported but there is native touch-action assume it supports\n    // all values. This is the case for IE 10 and 11.\n    return touchMap[val] = cssSupports ? win.CSS.supports('touch-action', val) : true;\n  });\n  return touchMap;\n}\n\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\nvar TOUCH_ACTION_MAP = getTouchActionProps();\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\nvar SUPPORT_TOUCH = ('ontouchstart' in win);\nvar SUPPORT_POINTER_EVENTS = prefixed(win, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\nvar COMPUTE_INTERVAL = 25;\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n/**\n * @private\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\n\nfunction each(obj, iterator, context) {\n  var i;\n\n  if (!obj) {\n    return;\n  }\n\n  if (obj.forEach) {\n    obj.forEach(iterator, context);\n  } else if (obj.length !== undefined) {\n    i = 0;\n\n    while (i < obj.length) {\n      iterator.call(context, obj[i], i, obj);\n      i++;\n    }\n  } else {\n    for (i in obj) {\n      obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n    }\n  }\n}\n/**\n * @private\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\n\n\nfunction boolOrFn(val, args) {\n  if (typeof val === TYPE_FUNCTION) {\n    return val.apply(args ? args[0] || undefined : undefined, args);\n  }\n\n  return val;\n}\n/**\n * @private\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\n\n\nfunction inStr(str, find) {\n  return str.indexOf(find) > -1;\n}\n/**\n * @private\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\n\n\nfunction cleanTouchActions(actions) {\n  // none\n  if (inStr(actions, TOUCH_ACTION_NONE)) {\n    return TOUCH_ACTION_NONE;\n  }\n\n  var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n  var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers\n  // for different directions, e.g. horizontal pan but vertical swipe?)\n  // we need none (as otherwise with pan-x pan-y combined none of these\n  // recognizers will work, since the browser would handle all panning\n\n  if (hasPanX && hasPanY) {\n    return TOUCH_ACTION_NONE;\n  } // pan-x OR pan-y\n\n\n  if (hasPanX || hasPanY) {\n    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n  } // manipulation\n\n\n  if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n    return TOUCH_ACTION_MANIPULATION;\n  }\n\n  return TOUCH_ACTION_AUTO;\n}\n/**\n * @private\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\n\n\nvar TouchAction = /*#__PURE__*/function () {\n  function TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n  }\n  /**\n   * @private\n   * set the touchAction value on the element or enable the polyfill\n   * @param {String} value\n   */\n\n\n  var _proto = TouchAction.prototype;\n\n  _proto.set = function set(value) {\n    // find out the touch-action by the event handlers\n    if (value === TOUCH_ACTION_COMPUTE) {\n      value = this.compute();\n    }\n\n    if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n      this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n    }\n\n    this.actions = value.toLowerCase().trim();\n  };\n  /**\n   * @private\n   * just re-set the touchAction value\n   */\n\n\n  _proto.update = function update() {\n    this.set(this.manager.options.touchAction);\n  };\n  /**\n   * @private\n   * compute the value for the touchAction property based on the recognizer's settings\n   * @returns {String} value\n   */\n\n\n  _proto.compute = function compute() {\n    var actions = [];\n    each(this.manager.recognizers, function (recognizer) {\n      if (boolOrFn(recognizer.options.enable, [recognizer])) {\n        actions = actions.concat(recognizer.getTouchAction());\n      }\n    });\n    return cleanTouchActions(actions.join(' '));\n  };\n  /**\n   * @private\n   * this method is called on each input cycle and provides the preventing of the browser behavior\n   * @param {Object} input\n   */\n\n\n  _proto.preventDefaults = function preventDefaults(input) {\n    var srcEvent = input.srcEvent;\n    var direction = input.offsetDirection; // if the touch action did prevented once this session\n\n    if (this.manager.session.prevented) {\n      srcEvent.preventDefault();\n      return;\n    }\n\n    var actions = this.actions;\n    var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n    if (hasNone) {\n      // do not prevent defaults if this is a tap gesture\n      var isTapPointer = input.pointers.length === 1;\n      var isTapMovement = input.distance < 2;\n      var isTapTouchTime = input.deltaTime < 250;\n\n      if (isTapPointer && isTapMovement && isTapTouchTime) {\n        return;\n      }\n    }\n\n    if (hasPanX && hasPanY) {\n      // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n      return;\n    }\n\n    if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {\n      return this.preventSrc(srcEvent);\n    }\n  };\n  /**\n   * @private\n   * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n   * @param {Object} srcEvent\n   */\n\n\n  _proto.preventSrc = function preventSrc(srcEvent) {\n    this.manager.session.prevented = true;\n    srcEvent.preventDefault();\n  };\n\n  return TouchAction;\n}();\n/**\n * @private\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\n\n\nfunction hasParent(node, parent) {\n  while (node) {\n    if (node === parent) {\n      return true;\n    }\n\n    node = node.parentNode;\n  }\n\n  return false;\n}\n/**\n * @private\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\n\n\nfunction getCenter(pointers) {\n  var pointersLength = pointers.length; // no need to loop when only one touch\n\n  if (pointersLength === 1) {\n    return {\n      x: round(pointers[0].clientX),\n      y: round(pointers[0].clientY)\n    };\n  }\n\n  var x = 0;\n  var y = 0;\n  var i = 0;\n\n  while (i < pointersLength) {\n    x += pointers[i].clientX;\n    y += pointers[i].clientY;\n    i++;\n  }\n\n  return {\n    x: round(x / pointersLength),\n    y: round(y / pointersLength)\n  };\n}\n/**\n * @private\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\n\n\nfunction simpleCloneInputData(input) {\n  // make a simple copy of the pointers because we will get a reference if we don't\n  // we only need clientXY for the calculations\n  var pointers = [];\n  var i = 0;\n\n  while (i < input.pointers.length) {\n    pointers[i] = {\n      clientX: round(input.pointers[i].clientX),\n      clientY: round(input.pointers[i].clientY)\n    };\n    i++;\n  }\n\n  return {\n    timeStamp: now(),\n    pointers: pointers,\n    center: getCenter(pointers),\n    deltaX: input.deltaX,\n    deltaY: input.deltaY\n  };\n}\n/**\n * @private\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\n\n\nfunction getDistance(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n\n  var x = p2[props[0]] - p1[props[0]];\n  var y = p2[props[1]] - p1[props[1]];\n  return Math.sqrt(x * x + y * y);\n}\n/**\n * @private\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\n\n\nfunction getAngle(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n\n  var x = p2[props[0]] - p1[props[0]];\n  var y = p2[props[1]] - p1[props[1]];\n  return Math.atan2(y, x) * 180 / Math.PI;\n}\n/**\n * @private\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\n\n\nfunction getDirection(x, y) {\n  if (x === y) {\n    return DIRECTION_NONE;\n  }\n\n  if (abs(x) >= abs(y)) {\n    return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n  }\n\n  return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n\nfunction computeDeltaXY(session, input) {\n  var center = input.center; // let { offsetDelta:offset = {}, prevDelta = {}, prevInput = {} } = session;\n  // jscs throwing error on defalut destructured values and without defaults tests fail\n\n  var offset = session.offsetDelta || {};\n  var prevDelta = session.prevDelta || {};\n  var prevInput = session.prevInput || {};\n\n  if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n    prevDelta = session.prevDelta = {\n      x: prevInput.deltaX || 0,\n      y: prevInput.deltaY || 0\n    };\n    offset = session.offsetDelta = {\n      x: center.x,\n      y: center.y\n    };\n  }\n\n  input.deltaX = prevDelta.x + (center.x - offset.x);\n  input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n/**\n * @private\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\n\n\nfunction getVelocity(deltaTime, x, y) {\n  return {\n    x: x / deltaTime || 0,\n    y: y / deltaTime || 0\n  };\n}\n/**\n * @private\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\n\n\nfunction getScale(start, end) {\n  return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n/**\n * @private\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\n\n\nfunction getRotation(start, end) {\n  return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n/**\n * @private\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\n\n\nfunction computeIntervalInputData(session, input) {\n  var last = session.lastInterval || input;\n  var deltaTime = input.timeStamp - last.timeStamp;\n  var velocity;\n  var velocityX;\n  var velocityY;\n  var direction;\n\n  if (input.eventType !== INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n    var deltaX = input.deltaX - last.deltaX;\n    var deltaY = input.deltaY - last.deltaY;\n    var v = getVelocity(deltaTime, deltaX, deltaY);\n    velocityX = v.x;\n    velocityY = v.y;\n    velocity = abs(v.x) > abs(v.y) ? v.x : v.y;\n    direction = getDirection(deltaX, deltaY);\n    session.lastInterval = input;\n  } else {\n    // use latest velocity info if it doesn't overtake a minimum period\n    velocity = last.velocity;\n    velocityX = last.velocityX;\n    velocityY = last.velocityY;\n    direction = last.direction;\n  }\n\n  input.velocity = velocity;\n  input.velocityX = velocityX;\n  input.velocityY = velocityY;\n  input.direction = direction;\n}\n/**\n* @private\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\n\n\nfunction computeInputData(manager, input) {\n  var session = manager.session;\n  var pointers = input.pointers;\n  var pointersLength = pointers.length; // store the first input to calculate the distance and direction\n\n  if (!session.firstInput) {\n    session.firstInput = simpleCloneInputData(input);\n  } // to compute scale and rotation we need to store the multiple touches\n\n\n  if (pointersLength > 1 && !session.firstMultiple) {\n    session.firstMultiple = simpleCloneInputData(input);\n  } else if (pointersLength === 1) {\n    session.firstMultiple = false;\n  }\n\n  var firstInput = session.firstInput,\n      firstMultiple = session.firstMultiple;\n  var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n  var center = input.center = getCenter(pointers);\n  input.timeStamp = now();\n  input.deltaTime = input.timeStamp - firstInput.timeStamp;\n  input.angle = getAngle(offsetCenter, center);\n  input.distance = getDistance(offsetCenter, center);\n  computeDeltaXY(session, input);\n  input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n  var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n  input.overallVelocityX = overallVelocity.x;\n  input.overallVelocityY = overallVelocity.y;\n  input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;\n  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n  input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n  input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;\n  computeIntervalInputData(session, input); // find the correct target\n\n  var target = manager.element;\n  var srcEvent = input.srcEvent;\n  var srcEventTarget;\n\n  if (srcEvent.composedPath) {\n    srcEventTarget = srcEvent.composedPath()[0];\n  } else if (srcEvent.path) {\n    srcEventTarget = srcEvent.path[0];\n  } else {\n    srcEventTarget = srcEvent.target;\n  }\n\n  if (hasParent(srcEventTarget, target)) {\n    target = srcEventTarget;\n  }\n\n  input.target = target;\n}\n/**\n * @private\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\n\n\nfunction inputHandler(manager, eventType, input) {\n  var pointersLen = input.pointers.length;\n  var changedPointersLen = input.changedPointers.length;\n  var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n  var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\n  input.isFirst = !!isFirst;\n  input.isFinal = !!isFinal;\n\n  if (isFirst) {\n    manager.session = {};\n  } // source event is the normalized value of the domEvents\n  // like 'touchstart, mouseup, pointerdown'\n\n\n  input.eventType = eventType; // compute scale, rotation etc\n\n  computeInputData(manager, input); // emit secret event\n\n  manager.emit('hammer.input', input);\n  manager.recognize(input);\n  manager.session.prevInput = input;\n}\n/**\n * @private\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\n\n\nfunction splitStr(str) {\n  return str.trim().split(/\\s+/g);\n}\n/**\n * @private\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\n\n\nfunction addEventListeners(target, types, handler) {\n  each(splitStr(types), function (type) {\n    target.addEventListener(type, handler, false);\n  });\n}\n/**\n * @private\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\n\n\nfunction removeEventListeners(target, types, handler) {\n  each(splitStr(types), function (type) {\n    target.removeEventListener(type, handler, false);\n  });\n}\n/**\n * @private\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\n\n\nfunction getWindowForElement(element) {\n  var doc = element.ownerDocument || element;\n  return doc.defaultView || doc.parentWindow || window;\n}\n/**\n * @private\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\n\n\nvar Input = /*#__PURE__*/function () {\n  function Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget; // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n\n    this.domHandler = function (ev) {\n      if (boolOrFn(manager.options.enable, [manager])) {\n        self.handler(ev);\n      }\n    };\n\n    this.init();\n  }\n  /**\n   * @private\n   * should handle the inputEvent data and trigger the callback\n   * @virtual\n   */\n\n\n  var _proto = Input.prototype;\n\n  _proto.handler = function handler() {};\n  /**\n   * @private\n   * bind the events\n   */\n\n\n  _proto.init = function init() {\n    this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  };\n  /**\n   * @private\n   * unbind the events\n   */\n\n\n  _proto.destroy = function destroy() {\n    this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  };\n\n  return Input;\n}();\n/**\n * @private\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\n\n\nfunction inArray(src, find, findByKey) {\n  if (src.indexOf && !findByKey) {\n    return src.indexOf(find);\n  } else {\n    var i = 0;\n\n    while (i < src.length) {\n      if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {\n        // do not use === here, test fails\n        return i;\n      }\n\n      i++;\n    }\n\n    return -1;\n  }\n}\n\nvar POINTER_INPUT_MAP = {\n  pointerdown: INPUT_START,\n  pointermove: INPUT_MOVE,\n  pointerup: INPUT_END,\n  pointercancel: INPUT_CANCEL,\n  pointerout: INPUT_CANCEL\n}; // in IE10 the pointer types is defined as an enum\n\nvar IE10_POINTER_TYPE_ENUM = {\n  2: INPUT_TYPE_TOUCH,\n  3: INPUT_TYPE_PEN,\n  4: INPUT_TYPE_MOUSE,\n  5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n\n};\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel'; // IE10 has prefixed support, and case-sensitive\n\nif (win.MSPointerEvent && !win.PointerEvent) {\n  POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n  POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n/**\n * @private\n * Pointer events input\n * @constructor\n * @extends Input\n */\n\n\nvar PointerEventInput = /*#__PURE__*/function (_Input) {\n  _inheritsLoose(PointerEventInput, _Input);\n\n  function PointerEventInput() {\n    var _this;\n\n    var proto = PointerEventInput.prototype;\n    proto.evEl = POINTER_ELEMENT_EVENTS;\n    proto.evWin = POINTER_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.store = _this.manager.session.pointerEvents = [];\n    return _this;\n  }\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n\n\n  var _proto = PointerEventInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var store = this.store;\n    var removePointer = false;\n    var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n    var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n    var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n    var isTouch = pointerType === INPUT_TYPE_TOUCH; // get index of the event in the store\n\n    var storeIndex = inArray(store, ev.pointerId, 'pointerId'); // start and mouse must be down\n\n    if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n      if (storeIndex < 0) {\n        store.push(ev);\n        storeIndex = store.length - 1;\n      }\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n      removePointer = true;\n    } // it not found, so the pointer hasn't been down (so it's probably a hover)\n\n\n    if (storeIndex < 0) {\n      return;\n    } // update the event in the store\n\n\n    store[storeIndex] = ev;\n    this.callback(this.manager, eventType, {\n      pointers: store,\n      changedPointers: [ev],\n      pointerType: pointerType,\n      srcEvent: ev\n    });\n\n    if (removePointer) {\n      // remove from the store\n      store.splice(storeIndex, 1);\n    }\n  };\n\n  return PointerEventInput;\n}(Input);\n/**\n * @private\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\n\n\nfunction toArray(obj) {\n  return Array.prototype.slice.call(obj, 0);\n}\n/**\n * @private\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\n\n\nfunction uniqueArray(src, key, sort) {\n  var results = [];\n  var values = [];\n  var i = 0;\n\n  while (i < src.length) {\n    var val = key ? src[i][key] : src[i];\n\n    if (inArray(values, val) < 0) {\n      results.push(src[i]);\n    }\n\n    values[i] = val;\n    i++;\n  }\n\n  if (sort) {\n    if (!key) {\n      results = results.sort();\n    } else {\n      results = results.sort(function (a, b) {\n        return a[key] > b[key];\n      });\n    }\n  }\n\n  return results;\n}\n\nvar TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n/**\n * @private\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\n\nvar TouchInput = /*#__PURE__*/function (_Input) {\n  _inheritsLoose(TouchInput, _Input);\n\n  function TouchInput() {\n    var _this;\n\n    TouchInput.prototype.evTarget = TOUCH_TARGET_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.targetIds = {}; // this.evTarget = TOUCH_TARGET_EVENTS;\n\n    return _this;\n  }\n\n  var _proto = TouchInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var type = TOUCH_INPUT_MAP[ev.type];\n    var touches = getTouches.call(this, ev, type);\n\n    if (!touches) {\n      return;\n    }\n\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  };\n\n  return TouchInput;\n}(Input);\n\nfunction getTouches(ev, type) {\n  var allTouches = toArray(ev.touches);\n  var targetIds = this.targetIds; // when there is only one touch, the process can be simplified\n\n  if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n    targetIds[allTouches[0].identifier] = true;\n    return [allTouches, allTouches];\n  }\n\n  var i;\n  var targetTouches;\n  var changedTouches = toArray(ev.changedTouches);\n  var changedTargetTouches = [];\n  var target = this.target; // get target touches from touches\n\n  targetTouches = allTouches.filter(function (touch) {\n    return hasParent(touch.target, target);\n  }); // collect touches\n\n  if (type === INPUT_START) {\n    i = 0;\n\n    while (i < targetTouches.length) {\n      targetIds[targetTouches[i].identifier] = true;\n      i++;\n    }\n  } // filter changed touches to only contain touches that exist in the collected target ids\n\n\n  i = 0;\n\n  while (i < changedTouches.length) {\n    if (targetIds[changedTouches[i].identifier]) {\n      changedTargetTouches.push(changedTouches[i]);\n    } // cleanup removed touches\n\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n      delete targetIds[changedTouches[i].identifier];\n    }\n\n    i++;\n  }\n\n  if (!changedTargetTouches.length) {\n    return;\n  }\n\n  return [// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n  uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];\n}\n\nvar MOUSE_INPUT_MAP = {\n  mousedown: INPUT_START,\n  mousemove: INPUT_MOVE,\n  mouseup: INPUT_END\n};\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n/**\n * @private\n * Mouse events input\n * @constructor\n * @extends Input\n */\n\nvar MouseInput = /*#__PURE__*/function (_Input) {\n  _inheritsLoose(MouseInput, _Input);\n\n  function MouseInput() {\n    var _this;\n\n    var proto = MouseInput.prototype;\n    proto.evEl = MOUSE_ELEMENT_EVENTS;\n    proto.evWin = MOUSE_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.pressed = false; // mousedown state\n\n    return _this;\n  }\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n\n\n  var _proto = MouseInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the left mouse button down\n\n    if (eventType & INPUT_START && ev.button === 0) {\n      this.pressed = true;\n    }\n\n    if (eventType & INPUT_MOVE && ev.which !== 1) {\n      eventType = INPUT_END;\n    } // mouse must be down\n\n\n    if (!this.pressed) {\n      return;\n    }\n\n    if (eventType & INPUT_END) {\n      this.pressed = false;\n    }\n\n    this.callback(this.manager, eventType, {\n      pointers: [ev],\n      changedPointers: [ev],\n      pointerType: INPUT_TYPE_MOUSE,\n      srcEvent: ev\n    });\n  };\n\n  return MouseInput;\n}(Input);\n/**\n * @private\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\n\nvar DEDUP_TIMEOUT = 2500;\nvar DEDUP_DISTANCE = 25;\n\nfunction setLastTouch(eventData) {\n  var _eventData$changedPoi = eventData.changedPointers,\n      touch = _eventData$changedPoi[0];\n\n  if (touch.identifier === this.primaryTouch) {\n    var lastTouch = {\n      x: touch.clientX,\n      y: touch.clientY\n    };\n    var lts = this.lastTouches;\n    this.lastTouches.push(lastTouch);\n\n    var removeLastTouch = function removeLastTouch() {\n      var i = lts.indexOf(lastTouch);\n\n      if (i > -1) {\n        lts.splice(i, 1);\n      }\n    };\n\n    setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n  }\n}\n\nfunction recordTouches(eventType, eventData) {\n  if (eventType & INPUT_START) {\n    this.primaryTouch = eventData.changedPointers[0].identifier;\n    setLastTouch.call(this, eventData);\n  } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n    setLastTouch.call(this, eventData);\n  }\n}\n\nfunction isSyntheticEvent(eventData) {\n  var x = eventData.srcEvent.clientX;\n  var y = eventData.srcEvent.clientY;\n\n  for (var i = 0; i < this.lastTouches.length; i++) {\n    var t = this.lastTouches[i];\n    var dx = Math.abs(x - t.x);\n    var dy = Math.abs(y - t.y);\n\n    if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar TouchMouseInput = /*#__PURE__*/function () {\n  var TouchMouseInput = /*#__PURE__*/function (_Input) {\n    _inheritsLoose(TouchMouseInput, _Input);\n\n    function TouchMouseInput(_manager, callback) {\n      var _this;\n\n      _this = _Input.call(this, _manager, callback) || this;\n\n      _this.handler = function (manager, inputEvent, inputData) {\n        var isTouch = inputData.pointerType === INPUT_TYPE_TOUCH;\n        var isMouse = inputData.pointerType === INPUT_TYPE_MOUSE;\n\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n          return;\n        } // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n\n\n        if (isTouch) {\n          recordTouches.call(_assertThisInitialized(_assertThisInitialized(_this)), inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent.call(_assertThisInitialized(_assertThisInitialized(_this)), inputData)) {\n          return;\n        }\n\n        _this.callback(manager, inputEvent, inputData);\n      };\n\n      _this.touch = new TouchInput(_this.manager, _this.handler);\n      _this.mouse = new MouseInput(_this.manager, _this.handler);\n      _this.primaryTouch = null;\n      _this.lastTouches = [];\n      return _this;\n    }\n    /**\n     * @private\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n\n\n    var _proto = TouchMouseInput.prototype;\n    /**\n     * @private\n     * remove the event listeners\n     */\n\n    _proto.destroy = function destroy() {\n      this.touch.destroy();\n      this.mouse.destroy();\n    };\n\n    return TouchMouseInput;\n  }(Input);\n\n  return TouchMouseInput;\n}();\n/**\n * @private\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\n\n\nfunction createInputInstance(manager) {\n  var Type; // let inputClass = manager.options.inputClass;\n\n  var inputClass = manager.options.inputClass;\n\n  if (inputClass) {\n    Type = inputClass;\n  } else if (SUPPORT_POINTER_EVENTS) {\n    Type = PointerEventInput;\n  } else if (SUPPORT_ONLY_TOUCH) {\n    Type = TouchInput;\n  } else if (!SUPPORT_TOUCH) {\n    Type = MouseInput;\n  } else {\n    Type = TouchMouseInput;\n  }\n\n  return new Type(manager, inputHandler);\n}\n/**\n * @private\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\n\n\nfunction invokeArrayArg(arg, fn, context) {\n  if (Array.isArray(arg)) {\n    each(arg, context[fn], context);\n    return true;\n  }\n\n  return false;\n}\n\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n/**\n * @private\n * get a unique id\n * @returns {number} uniqueId\n */\n\nvar _uniqueId = 1;\n\nfunction uniqueId() {\n  return _uniqueId++;\n}\n/**\n * @private\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\n\n\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n  var manager = recognizer.manager;\n\n  if (manager) {\n    return manager.get(otherRecognizer);\n  }\n\n  return otherRecognizer;\n}\n/**\n * @private\n * get a usable string, used as event postfix\n * @param {constant} state\n * @returns {String} state\n */\n\n\nfunction stateStr(state) {\n  if (state & STATE_CANCELLED) {\n    return 'cancel';\n  } else if (state & STATE_ENDED) {\n    return 'end';\n  } else if (state & STATE_CHANGED) {\n    return 'move';\n  } else if (state & STATE_BEGAN) {\n    return 'start';\n  }\n\n  return '';\n}\n/**\n * @private\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\n\n/**\n * @private\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\n\n\nvar Recognizer = /*#__PURE__*/function () {\n  function Recognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.options = _extends({\n      enable: true\n    }, options);\n    this.id = uniqueId();\n    this.manager = null; // default is enable true\n\n    this.state = STATE_POSSIBLE;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n  /**\n   * @private\n   * set options\n   * @param {Object} options\n   * @return {Recognizer}\n   */\n\n\n  var _proto = Recognizer.prototype;\n\n  _proto.set = function set(options) {\n    assign$1(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state\n\n    this.manager && this.manager.touchAction.update();\n    return this;\n  };\n  /**\n   * @private\n   * recognize simultaneous with an other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  _proto.recognizeWith = function recognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n      return this;\n    }\n\n    var simultaneous = this.simultaneous;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\n    if (!simultaneous[otherRecognizer.id]) {\n      simultaneous[otherRecognizer.id] = otherRecognizer;\n      otherRecognizer.recognizeWith(this);\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  _proto.dropRecognizeWith = function dropRecognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n      return this;\n    }\n\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    delete this.simultaneous[otherRecognizer.id];\n    return this;\n  };\n  /**\n   * @private\n   * recognizer can only run when an other is failing\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  _proto.requireFailure = function requireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n      return this;\n    }\n\n    var requireFail = this.requireFail;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\n    if (inArray(requireFail, otherRecognizer) === -1) {\n      requireFail.push(otherRecognizer);\n      otherRecognizer.requireFailure(this);\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * drop the requireFailure link. it does not remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  _proto.dropRequireFailure = function dropRequireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n      return this;\n    }\n\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    var index = inArray(this.requireFail, otherRecognizer);\n\n    if (index > -1) {\n      this.requireFail.splice(index, 1);\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * has require failures boolean\n   * @returns {boolean}\n   */\n\n\n  _proto.hasRequireFailures = function hasRequireFailures() {\n    return this.requireFail.length > 0;\n  };\n  /**\n   * @private\n   * if the recognizer can recognize simultaneous with an other recognizer\n   * @param {Recognizer} otherRecognizer\n   * @returns {Boolean}\n   */\n\n\n  _proto.canRecognizeWith = function canRecognizeWith(otherRecognizer) {\n    return !!this.simultaneous[otherRecognizer.id];\n  };\n  /**\n   * @private\n   * You should use `tryEmit` instead of `emit` directly to check\n   * that all the needed recognizers has failed before emitting.\n   * @param {Object} input\n   */\n\n\n  _proto.emit = function emit(input) {\n    var self = this;\n    var state = this.state;\n\n    function emit(event) {\n      self.manager.emit(event, input);\n    } // 'panstart' and 'panmove'\n\n\n    if (state < STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n\n    emit(self.options.event); // simple 'eventName' events\n\n    if (input.additionalEvent) {\n      // additional event(panleft, panright, pinchin, pinchout...)\n      emit(input.additionalEvent);\n    } // panend and pancancel\n\n\n    if (state >= STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n  };\n  /**\n   * @private\n   * Check that all the require failure recognizers has failed,\n   * if true, it emits a gesture event,\n   * otherwise, setup the state to FAILED.\n   * @param {Object} input\n   */\n\n\n  _proto.tryEmit = function tryEmit(input) {\n    if (this.canEmit()) {\n      return this.emit(input);\n    } // it's failing anyway\n\n\n    this.state = STATE_FAILED;\n  };\n  /**\n   * @private\n   * can we emit?\n   * @returns {boolean}\n   */\n\n\n  _proto.canEmit = function canEmit() {\n    var i = 0;\n\n    while (i < this.requireFail.length) {\n      if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n        return false;\n      }\n\n      i++;\n    }\n\n    return true;\n  };\n  /**\n   * @private\n   * update the recognizer\n   * @param {Object} inputData\n   */\n\n\n  _proto.recognize = function recognize(inputData) {\n    // make a new copy of the inputData\n    // so we can change the inputData without messing up the other recognizers\n    var inputDataClone = assign$1({}, inputData); // is is enabled and allow recognizing?\n\n    if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n      this.reset();\n      this.state = STATE_FAILED;\n      return;\n    } // reset when we've reached the end\n\n\n    if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n      this.state = STATE_POSSIBLE;\n    }\n\n    this.state = this.process(inputDataClone); // the recognizer has recognized a gesture\n    // so trigger an event\n\n    if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n      this.tryEmit(inputDataClone);\n    }\n  };\n  /**\n   * @private\n   * return the state of the recognizer\n   * the actual recognizing happens in this method\n   * @virtual\n   * @param {Object} inputData\n   * @returns {constant} STATE\n   */\n\n  /* jshint ignore:start */\n\n\n  _proto.process = function process(inputData) {};\n  /* jshint ignore:end */\n\n  /**\n   * @private\n   * return the preferred touch-action\n   * @virtual\n   * @returns {Array}\n   */\n\n\n  _proto.getTouchAction = function getTouchAction() {};\n  /**\n   * @private\n   * called when the gesture isn't allowed to recognize\n   * like when another is being recognized or it is disabled\n   * @virtual\n   */\n\n\n  _proto.reset = function reset() {};\n\n  return Recognizer;\n}();\n/**\n * @private\n * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\n\n\nvar TapRecognizer = /*#__PURE__*/function (_Recognizer) {\n  _inheritsLoose(TapRecognizer, _Recognizer);\n\n  function TapRecognizer(options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _Recognizer.call(this, _extends({\n      event: 'tap',\n      pointers: 1,\n      taps: 1,\n      interval: 300,\n      // max time between the multi-tap taps\n      time: 250,\n      // max time of the pointer to be down (like finger on the screen)\n      threshold: 9,\n      // a minimal movement is ok, but keep it low\n      posThreshold: 10\n    }, options)) || this; // previous time and center,\n    // used for tap counting\n\n    _this.pTime = false;\n    _this.pCenter = false;\n    _this._timer = null;\n    _this._input = null;\n    _this.count = 0;\n    return _this;\n  }\n\n  var _proto = TapRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_MANIPULATION];\n  };\n\n  _proto.process = function process(input) {\n    var _this2 = this;\n\n    var options = this.options;\n    var validPointers = input.pointers.length === options.pointers;\n    var validMovement = input.distance < options.threshold;\n    var validTouchTime = input.deltaTime < options.time;\n    this.reset();\n\n    if (input.eventType & INPUT_START && this.count === 0) {\n      return this.failTimeout();\n    } // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n\n\n    if (validMovement && validTouchTime && validPointers) {\n      if (input.eventType !== INPUT_END) {\n        return this.failTimeout();\n      }\n\n      var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n      var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n      this.pTime = input.timeStamp;\n      this.pCenter = input.center;\n\n      if (!validMultiTap || !validInterval) {\n        this.count = 1;\n      } else {\n        this.count += 1;\n      }\n\n      this._input = input; // if tap count matches we have recognized it,\n      // else it has began recognizing...\n\n      var tapCount = this.count % options.taps;\n\n      if (tapCount === 0) {\n        // no failing requirements, immediately trigger the tap event\n        // or wait as long as the multitap interval to trigger\n        if (!this.hasRequireFailures()) {\n          return STATE_RECOGNIZED;\n        } else {\n          this._timer = setTimeout(function () {\n            _this2.state = STATE_RECOGNIZED;\n\n            _this2.tryEmit();\n          }, options.interval);\n          return STATE_BEGAN;\n        }\n      }\n    }\n\n    return STATE_FAILED;\n  };\n\n  _proto.failTimeout = function failTimeout() {\n    var _this3 = this;\n\n    this._timer = setTimeout(function () {\n      _this3.state = STATE_FAILED;\n    }, this.options.interval);\n    return STATE_FAILED;\n  };\n\n  _proto.reset = function reset() {\n    clearTimeout(this._timer);\n  };\n\n  _proto.emit = function emit() {\n    if (this.state === STATE_RECOGNIZED) {\n      this._input.tapCount = this.count;\n      this.manager.emit(this.options.event, this._input);\n    }\n  };\n\n  return TapRecognizer;\n}(Recognizer);\n/**\n * @private\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\n\n\nvar AttrRecognizer = /*#__PURE__*/function (_Recognizer) {\n  _inheritsLoose(AttrRecognizer, _Recognizer);\n\n  function AttrRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _Recognizer.call(this, _extends({\n      pointers: 1\n    }, options)) || this;\n  }\n  /**\n   * @private\n   * Used to check if it the recognizer receives valid input, like input.distance > 10.\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {Boolean} recognized\n   */\n\n\n  var _proto = AttrRecognizer.prototype;\n\n  _proto.attrTest = function attrTest(input) {\n    var optionPointers = this.options.pointers;\n    return optionPointers === 0 || input.pointers.length === optionPointers;\n  };\n  /**\n   * @private\n   * Process the input and return the state for the recognizer\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {*} State\n   */\n\n\n  _proto.process = function process(input) {\n    var state = this.state;\n    var eventType = input.eventType;\n    var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n    var isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED\n\n    if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n      return state | STATE_CANCELLED;\n    } else if (isRecognized || isValid) {\n      if (eventType & INPUT_END) {\n        return state | STATE_ENDED;\n      } else if (!(state & STATE_BEGAN)) {\n        return STATE_BEGAN;\n      }\n\n      return state | STATE_CHANGED;\n    }\n\n    return STATE_FAILED;\n  };\n\n  return AttrRecognizer;\n}(Recognizer);\n/**\n * @private\n * direction cons to string\n * @param {constant} direction\n * @returns {String}\n */\n\n\nfunction directionStr(direction) {\n  if (direction === DIRECTION_DOWN) {\n    return 'down';\n  } else if (direction === DIRECTION_UP) {\n    return 'up';\n  } else if (direction === DIRECTION_LEFT) {\n    return 'left';\n  } else if (direction === DIRECTION_RIGHT) {\n    return 'right';\n  }\n\n  return '';\n}\n/**\n * @private\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\n\n\nvar PanRecognizer = /*#__PURE__*/function (_AttrRecognizer) {\n  _inheritsLoose(PanRecognizer, _AttrRecognizer);\n\n  function PanRecognizer(options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _AttrRecognizer.call(this, _extends({\n      event: 'pan',\n      threshold: 10,\n      pointers: 1,\n      direction: DIRECTION_ALL\n    }, options)) || this;\n    _this.pX = null;\n    _this.pY = null;\n    return _this;\n  }\n\n  var _proto = PanRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    var direction = this.options.direction;\n    var actions = [];\n\n    if (direction & DIRECTION_HORIZONTAL) {\n      actions.push(TOUCH_ACTION_PAN_Y);\n    }\n\n    if (direction & DIRECTION_VERTICAL) {\n      actions.push(TOUCH_ACTION_PAN_X);\n    }\n\n    return actions;\n  };\n\n  _proto.directionTest = function directionTest(input) {\n    var options = this.options;\n    var hasMoved = true;\n    var distance = input.distance;\n    var direction = input.direction;\n    var x = input.deltaX;\n    var y = input.deltaY; // lock to axis?\n\n    if (!(direction & options.direction)) {\n      if (options.direction & DIRECTION_HORIZONTAL) {\n        direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n        hasMoved = x !== this.pX;\n        distance = Math.abs(input.deltaX);\n      } else {\n        direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n        hasMoved = y !== this.pY;\n        distance = Math.abs(input.deltaY);\n      }\n    }\n\n    input.direction = direction;\n    return hasMoved && distance > options.threshold && direction & options.direction;\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    return AttrRecognizer.prototype.attrTest.call(this, input) && ( // replace with a super call\n    this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));\n  };\n\n  _proto.emit = function emit(input) {\n    this.pX = input.deltaX;\n    this.pY = input.deltaY;\n    var direction = directionStr(input.direction);\n\n    if (direction) {\n      input.additionalEvent = this.options.event + direction;\n    }\n\n    _AttrRecognizer.prototype.emit.call(this, input);\n  };\n\n  return PanRecognizer;\n}(AttrRecognizer);\n/**\n * @private\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\n\n\nvar SwipeRecognizer = /*#__PURE__*/function (_AttrRecognizer) {\n  _inheritsLoose(SwipeRecognizer, _AttrRecognizer);\n\n  function SwipeRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _AttrRecognizer.call(this, _extends({\n      event: 'swipe',\n      threshold: 10,\n      velocity: 0.3,\n      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n      pointers: 1\n    }, options)) || this;\n  }\n\n  var _proto = SwipeRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return PanRecognizer.prototype.getTouchAction.call(this);\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    var direction = this.options.direction;\n    var velocity;\n\n    if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n      velocity = input.overallVelocity;\n    } else if (direction & DIRECTION_HORIZONTAL) {\n      velocity = input.overallVelocityX;\n    } else if (direction & DIRECTION_VERTICAL) {\n      velocity = input.overallVelocityY;\n    }\n\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers === this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n  };\n\n  _proto.emit = function emit(input) {\n    var direction = directionStr(input.offsetDirection);\n\n    if (direction) {\n      this.manager.emit(this.options.event + direction, input);\n    }\n\n    this.manager.emit(this.options.event, input);\n  };\n\n  return SwipeRecognizer;\n}(AttrRecognizer);\n/**\n * @private\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\n\n\nvar PinchRecognizer = /*#__PURE__*/function (_AttrRecognizer) {\n  _inheritsLoose(PinchRecognizer, _AttrRecognizer);\n\n  function PinchRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _AttrRecognizer.call(this, _extends({\n      event: 'pinch',\n      threshold: 0,\n      pointers: 2\n    }, options)) || this;\n  }\n\n  var _proto = PinchRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n  };\n\n  _proto.emit = function emit(input) {\n    if (input.scale !== 1) {\n      var inOut = input.scale < 1 ? 'in' : 'out';\n      input.additionalEvent = this.options.event + inOut;\n    }\n\n    _AttrRecognizer.prototype.emit.call(this, input);\n  };\n\n  return PinchRecognizer;\n}(AttrRecognizer);\n/**\n * @private\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\n\n\nvar RotateRecognizer = /*#__PURE__*/function (_AttrRecognizer) {\n  _inheritsLoose(RotateRecognizer, _AttrRecognizer);\n\n  function RotateRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _AttrRecognizer.call(this, _extends({\n      event: 'rotate',\n      threshold: 0,\n      pointers: 2\n    }, options)) || this;\n  }\n\n  var _proto = RotateRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n  };\n\n  return RotateRecognizer;\n}(AttrRecognizer);\n/**\n * @private\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\n\n\nvar PressRecognizer = /*#__PURE__*/function (_Recognizer) {\n  _inheritsLoose(PressRecognizer, _Recognizer);\n\n  function PressRecognizer(options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _Recognizer.call(this, _extends({\n      event: 'press',\n      pointers: 1,\n      time: 251,\n      // minimal time of the pointer to be pressed\n      threshold: 9\n    }, options)) || this;\n    _this._timer = null;\n    _this._input = null;\n    return _this;\n  }\n\n  var _proto = PressRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_AUTO];\n  };\n\n  _proto.process = function process(input) {\n    var _this2 = this;\n\n    var options = this.options;\n    var validPointers = input.pointers.length === options.pointers;\n    var validMovement = input.distance < options.threshold;\n    var validTime = input.deltaTime > options.time;\n    this._input = input; // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n\n    if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {\n      this.reset();\n    } else if (input.eventType & INPUT_START) {\n      this.reset();\n      this._timer = setTimeout(function () {\n        _this2.state = STATE_RECOGNIZED;\n\n        _this2.tryEmit();\n      }, options.time);\n    } else if (input.eventType & INPUT_END) {\n      return STATE_RECOGNIZED;\n    }\n\n    return STATE_FAILED;\n  };\n\n  _proto.reset = function reset() {\n    clearTimeout(this._timer);\n  };\n\n  _proto.emit = function emit(input) {\n    if (this.state !== STATE_RECOGNIZED) {\n      return;\n    }\n\n    if (input && input.eventType & INPUT_END) {\n      this.manager.emit(this.options.event + \"up\", input);\n    } else {\n      this._input.timeStamp = now();\n      this.manager.emit(this.options.event, this._input);\n    }\n  };\n\n  return PressRecognizer;\n}(Recognizer);\n\nvar defaults = {\n  /**\n   * @private\n   * set if DOM events are being triggered.\n   * But this is slower and unused by simple implementations, so disabled by default.\n   * @type {Boolean}\n   * @default false\n   */\n  domEvents: false,\n\n  /**\n   * @private\n   * The value for the touchAction property/fallback.\n   * When set to `compute` it will magically set the correct value based on the added recognizers.\n   * @type {String}\n   * @default compute\n   */\n  touchAction: TOUCH_ACTION_COMPUTE,\n\n  /**\n   * @private\n   * @type {Boolean}\n   * @default true\n   */\n  enable: true,\n\n  /**\n   * @private\n   * EXPERIMENTAL FEATURE -- can be removed/changed\n   * Change the parent input target element.\n   * If Null, then it is being set the to main element.\n   * @type {Null|EventTarget}\n   * @default null\n   */\n  inputTarget: null,\n\n  /**\n   * @private\n   * force an input class\n   * @type {Null|Function}\n   * @default null\n   */\n  inputClass: null,\n\n  /**\n   * @private\n   * Some CSS properties can be used to improve the working of Hammer.\n   * Add them to this method and they will be set when creating a new Manager.\n   * @namespace\n   */\n  cssProps: {\n    /**\n     * @private\n     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n     * @type {String}\n     * @default 'none'\n     */\n    userSelect: \"none\",\n\n    /**\n     * @private\n     * Disable the Windows Phone grippers when pressing an element.\n     * @type {String}\n     * @default 'none'\n     */\n    touchSelect: \"none\",\n\n    /**\n     * @private\n     * Disables the default callout shown when you touch and hold a touch target.\n     * On iOS, when you touch and hold a touch target such as a link, Safari displays\n     * a callout containing information about the link. This property allows you to disable that callout.\n     * @type {String}\n     * @default 'none'\n     */\n    touchCallout: \"none\",\n\n    /**\n     * @private\n     * Specifies whether zooming is enabled. Used by IE10>\n     * @type {String}\n     * @default 'none'\n     */\n    contentZooming: \"none\",\n\n    /**\n     * @private\n     * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n     * @type {String}\n     * @default 'none'\n     */\n    userDrag: \"none\",\n\n    /**\n     * @private\n     * Overrides the highlight color shown when the user taps a link or a JavaScript\n     * clickable element in iOS. This property obeys the alpha value, if specified.\n     * @type {String}\n     * @default 'rgba(0,0,0,0)'\n     */\n    tapHighlightColor: \"rgba(0,0,0,0)\"\n  }\n};\n/**\n * @private\n * Default recognizer setup when calling `Hammer()`\n * When creating a new Manager these will be skipped.\n * This is separated with other defaults because of tree-shaking.\n * @type {Array}\n */\n\nvar preset = [[RotateRecognizer, {\n  enable: false\n}], [PinchRecognizer, {\n  enable: false\n}, ['rotate']], [SwipeRecognizer, {\n  direction: DIRECTION_HORIZONTAL\n}], [PanRecognizer, {\n  direction: DIRECTION_HORIZONTAL\n}, ['swipe']], [TapRecognizer], [TapRecognizer, {\n  event: 'doubletap',\n  taps: 2\n}, ['tap']], [PressRecognizer]];\nvar STOP = 1;\nvar FORCED_STOP = 2;\n/**\n * @private\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\n\nfunction toggleCssProps(manager, add) {\n  var element = manager.element;\n\n  if (!element.style) {\n    return;\n  }\n\n  var prop;\n  each(manager.options.cssProps, function (value, name) {\n    prop = prefixed(element.style, name);\n\n    if (add) {\n      manager.oldCssProps[prop] = element.style[prop];\n      element.style[prop] = value;\n    } else {\n      element.style[prop] = manager.oldCssProps[prop] || \"\";\n    }\n  });\n\n  if (!add) {\n    manager.oldCssProps = {};\n  }\n}\n/**\n * @private\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\n\n\nfunction triggerDomEvent(event, data) {\n  var gestureEvent = document.createEvent(\"Event\");\n  gestureEvent.initEvent(event, true, true);\n  gestureEvent.gesture = data;\n  data.target.dispatchEvent(gestureEvent);\n}\n/**\n* @private\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\n\n\nvar Manager = /*#__PURE__*/function () {\n  function Manager(element, options) {\n    var _this = this;\n\n    this.options = assign$1({}, defaults, options || {});\n    this.options.inputTarget = this.options.inputTarget || element;\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n    toggleCssProps(this, true);\n    each(this.options.recognizers, function (item) {\n      var recognizer = _this.add(new item[0](item[1]));\n\n      item[2] && recognizer.recognizeWith(item[2]);\n      item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n  }\n  /**\n   * @private\n   * set options\n   * @param {Object} options\n   * @returns {Manager}\n   */\n\n\n  var _proto = Manager.prototype;\n\n  _proto.set = function set(options) {\n    assign$1(this.options, options); // Options that need a little more setup\n\n    if (options.touchAction) {\n      this.touchAction.update();\n    }\n\n    if (options.inputTarget) {\n      // Clean up existing event listeners and reinitialize\n      this.input.destroy();\n      this.input.target = options.inputTarget;\n      this.input.init();\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * stop recognizing for this session.\n   * This session will be discarded, when a new [input]start event is fired.\n   * When forced, the recognizer cycle is stopped immediately.\n   * @param {Boolean} [force]\n   */\n\n\n  _proto.stop = function stop(force) {\n    this.session.stopped = force ? FORCED_STOP : STOP;\n  };\n  /**\n   * @private\n   * run the recognizers!\n   * called by the inputHandler function on every movement of the pointers (touches)\n   * it walks through all the recognizers and tries to detect the gesture that is being made\n   * @param {Object} inputData\n   */\n\n\n  _proto.recognize = function recognize(inputData) {\n    var session = this.session;\n\n    if (session.stopped) {\n      return;\n    } // run the touch-action polyfill\n\n\n    this.touchAction.preventDefaults(inputData);\n    var recognizer;\n    var recognizers = this.recognizers; // this holds the recognizer that is being recognized.\n    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n    // if no recognizer is detecting a thing, it is set to `null`\n\n    var curRecognizer = session.curRecognizer; // reset when the last recognizer is recognized\n    // or when we're in a new session\n\n    if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {\n      session.curRecognizer = null;\n      curRecognizer = null;\n    }\n\n    var i = 0;\n\n    while (i < recognizers.length) {\n      recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.\n      // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n      // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n      //      that is being recognized.\n      // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n      //      this can be setup with the `recognizeWith()` method on the recognizer.\n\n      if (session.stopped !== FORCED_STOP && ( // 1\n      !curRecognizer || recognizer === curRecognizer || // 2\n      recognizer.canRecognizeWith(curRecognizer))) {\n        // 3\n        recognizer.recognize(inputData);\n      } else {\n        recognizer.reset();\n      } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n      // current active recognizer. but only if we don't already have an active recognizer\n\n\n      if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n        session.curRecognizer = recognizer;\n        curRecognizer = recognizer;\n      }\n\n      i++;\n    }\n  };\n  /**\n   * @private\n   * get a recognizer by its event name.\n   * @param {Recognizer|String} recognizer\n   * @returns {Recognizer|Null}\n   */\n\n\n  _proto.get = function get(recognizer) {\n    if (recognizer instanceof Recognizer) {\n      return recognizer;\n    }\n\n    var recognizers = this.recognizers;\n\n    for (var i = 0; i < recognizers.length; i++) {\n      if (recognizers[i].options.event === recognizer) {\n        return recognizers[i];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * @private add a recognizer to the manager\n   * existing recognizers with the same event name will be removed\n   * @param {Recognizer} recognizer\n   * @returns {Recognizer|Manager}\n   */\n\n\n  _proto.add = function add(recognizer) {\n    if (invokeArrayArg(recognizer, \"add\", this)) {\n      return this;\n    } // remove existing\n\n\n    var existing = this.get(recognizer.options.event);\n\n    if (existing) {\n      this.remove(existing);\n    }\n\n    this.recognizers.push(recognizer);\n    recognizer.manager = this;\n    this.touchAction.update();\n    return recognizer;\n  };\n  /**\n   * @private\n   * remove a recognizer by name or instance\n   * @param {Recognizer|String} recognizer\n   * @returns {Manager}\n   */\n\n\n  _proto.remove = function remove(recognizer) {\n    if (invokeArrayArg(recognizer, \"remove\", this)) {\n      return this;\n    }\n\n    var targetRecognizer = this.get(recognizer); // let's make sure this recognizer exists\n\n    if (recognizer) {\n      var recognizers = this.recognizers;\n      var index = inArray(recognizers, targetRecognizer);\n\n      if (index !== -1) {\n        recognizers.splice(index, 1);\n        this.touchAction.update();\n      }\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * bind event\n   * @param {String} events\n   * @param {Function} handler\n   * @returns {EventEmitter} this\n   */\n\n\n  _proto.on = function on(events, handler) {\n    if (events === undefined || handler === undefined) {\n      return this;\n    }\n\n    var handlers = this.handlers;\n    each(splitStr(events), function (event) {\n      handlers[event] = handlers[event] || [];\n      handlers[event].push(handler);\n    });\n    return this;\n  };\n  /**\n   * @private unbind event, leave emit blank to remove all handlers\n   * @param {String} events\n   * @param {Function} [handler]\n   * @returns {EventEmitter} this\n   */\n\n\n  _proto.off = function off(events, handler) {\n    if (events === undefined) {\n      return this;\n    }\n\n    var handlers = this.handlers;\n    each(splitStr(events), function (event) {\n      if (!handler) {\n        delete handlers[event];\n      } else {\n        handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n      }\n    });\n    return this;\n  };\n  /**\n   * @private emit event to the listeners\n   * @param {String} event\n   * @param {Object} data\n   */\n\n\n  _proto.emit = function emit(event, data) {\n    // we also want to trigger dom events\n    if (this.options.domEvents) {\n      triggerDomEvent(event, data);\n    } // no handlers, so skip it all\n\n\n    var handlers = this.handlers[event] && this.handlers[event].slice();\n\n    if (!handlers || !handlers.length) {\n      return;\n    }\n\n    data.type = event;\n\n    data.preventDefault = function () {\n      data.srcEvent.preventDefault();\n    };\n\n    var i = 0;\n\n    while (i < handlers.length) {\n      handlers[i](data);\n      i++;\n    }\n  };\n  /**\n   * @private\n   * destroy the manager and unbinds all events\n   * it doesn't unbind dom events, that is the user own responsibility\n   */\n\n\n  _proto.destroy = function destroy() {\n    this.element && toggleCssProps(this, false);\n    this.handlers = {};\n    this.session = {};\n    this.input.destroy();\n    this.element = null;\n  };\n\n  return Manager;\n}();\n\nvar SINGLE_TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n/**\n * @private\n * Touch events input\n * @constructor\n * @extends Input\n */\n\nvar SingleTouchInput = /*#__PURE__*/function (_Input) {\n  _inheritsLoose(SingleTouchInput, _Input);\n\n  function SingleTouchInput() {\n    var _this;\n\n    var proto = SingleTouchInput.prototype;\n    proto.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    proto.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.started = false;\n    return _this;\n  }\n\n  var _proto = SingleTouchInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var type = SINGLE_TOUCH_INPUT_MAP[ev.type]; // should we handle the touch events?\n\n    if (type === INPUT_START) {\n      this.started = true;\n    }\n\n    if (!this.started) {\n      return;\n    }\n\n    var touches = normalizeSingleTouches.call(this, ev, type); // when done, reset the started state\n\n    if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n      this.started = false;\n    }\n\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  };\n\n  return SingleTouchInput;\n}(Input);\n\nfunction normalizeSingleTouches(ev, type) {\n  var all = toArray(ev.touches);\n  var changed = toArray(ev.changedTouches);\n\n  if (type & (INPUT_END | INPUT_CANCEL)) {\n    all = uniqueArray(all.concat(changed), 'identifier', true);\n  }\n\n  return [all, changed];\n}\n/**\n * @private\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\n\n\nfunction deprecate(method, name, message) {\n  var deprecationMessage = \"DEPRECATED METHOD: \" + name + \"\\n\" + message + \" AT \\n\";\n  return function () {\n    var e = new Error('get-stack-trace');\n    var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '').replace(/^\\s+at\\s+/gm, '').replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n    var log = window.console && (window.console.warn || window.console.log);\n\n    if (log) {\n      log.call(window.console, deprecationMessage, stack);\n    }\n\n    return method.apply(this, arguments);\n  };\n}\n/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\n\n\nvar extend = deprecate(function (dest, src, merge) {\n  var keys = Object.keys(src);\n  var i = 0;\n\n  while (i < keys.length) {\n    if (!merge || merge && dest[keys[i]] === undefined) {\n      dest[keys[i]] = src[keys[i]];\n    }\n\n    i++;\n  }\n\n  return dest;\n}, 'extend', 'Use `assign`.');\n/**\n * @private\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\n\nvar merge = deprecate(function (dest, src) {\n  return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n/**\n * @private\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\n\nfunction inherit(child, base, properties) {\n  var baseP = base.prototype;\n  var childP;\n  childP = child.prototype = Object.create(baseP);\n  childP.constructor = child;\n  childP._super = baseP;\n\n  if (properties) {\n    assign$1(childP, properties);\n  }\n}\n/**\n * @private\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\n\n\nfunction bindFn(fn, context) {\n  return function boundFn() {\n    return fn.apply(context, arguments);\n  };\n}\n/**\n * @private\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\n\n\nvar Hammer = /*#__PURE__*/function () {\n  var Hammer =\n  /**\n    * @private\n    * @const {string}\n    */\n  function Hammer(element, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return new Manager(element, _extends({\n      recognizers: preset.concat()\n    }, options));\n  };\n\n  Hammer.VERSION = \"2.0.17-rc\";\n  Hammer.DIRECTION_ALL = DIRECTION_ALL;\n  Hammer.DIRECTION_DOWN = DIRECTION_DOWN;\n  Hammer.DIRECTION_LEFT = DIRECTION_LEFT;\n  Hammer.DIRECTION_RIGHT = DIRECTION_RIGHT;\n  Hammer.DIRECTION_UP = DIRECTION_UP;\n  Hammer.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;\n  Hammer.DIRECTION_VERTICAL = DIRECTION_VERTICAL;\n  Hammer.DIRECTION_NONE = DIRECTION_NONE;\n  Hammer.DIRECTION_DOWN = DIRECTION_DOWN;\n  Hammer.INPUT_START = INPUT_START;\n  Hammer.INPUT_MOVE = INPUT_MOVE;\n  Hammer.INPUT_END = INPUT_END;\n  Hammer.INPUT_CANCEL = INPUT_CANCEL;\n  Hammer.STATE_POSSIBLE = STATE_POSSIBLE;\n  Hammer.STATE_BEGAN = STATE_BEGAN;\n  Hammer.STATE_CHANGED = STATE_CHANGED;\n  Hammer.STATE_ENDED = STATE_ENDED;\n  Hammer.STATE_RECOGNIZED = STATE_RECOGNIZED;\n  Hammer.STATE_CANCELLED = STATE_CANCELLED;\n  Hammer.STATE_FAILED = STATE_FAILED;\n  Hammer.Manager = Manager;\n  Hammer.Input = Input;\n  Hammer.TouchAction = TouchAction;\n  Hammer.TouchInput = TouchInput;\n  Hammer.MouseInput = MouseInput;\n  Hammer.PointerEventInput = PointerEventInput;\n  Hammer.TouchMouseInput = TouchMouseInput;\n  Hammer.SingleTouchInput = SingleTouchInput;\n  Hammer.Recognizer = Recognizer;\n  Hammer.AttrRecognizer = AttrRecognizer;\n  Hammer.Tap = TapRecognizer;\n  Hammer.Pan = PanRecognizer;\n  Hammer.Swipe = SwipeRecognizer;\n  Hammer.Pinch = PinchRecognizer;\n  Hammer.Rotate = RotateRecognizer;\n  Hammer.Press = PressRecognizer;\n  Hammer.on = addEventListeners;\n  Hammer.off = removeEventListeners;\n  Hammer.each = each;\n  Hammer.merge = merge;\n  Hammer.extend = extend;\n  Hammer.bindFn = bindFn;\n  Hammer.assign = assign$1;\n  Hammer.inherit = inherit;\n  Hammer.bindFn = bindFn;\n  Hammer.prefixed = prefixed;\n  Hammer.toArray = toArray;\n  Hammer.inArray = inArray;\n  Hammer.uniqueArray = uniqueArray;\n  Hammer.splitStr = splitStr;\n  Hammer.boolOrFn = boolOrFn;\n  Hammer.hasParent = hasParent;\n  Hammer.addEventListeners = addEventListeners;\n  Hammer.removeEventListeners = removeEventListeners;\n  Hammer.defaults = assign$1({}, defaults, {\n    preset: preset\n  });\n  return Hammer;\n}(); //  style loader but by script tag, not by the loader.\n\n\nvar defaults$1 = Hammer.defaults;\nexport default Hammer;\nexport { INPUT_START, INPUT_MOVE, INPUT_END, INPUT_CANCEL, STATE_POSSIBLE, STATE_BEGAN, STATE_CHANGED, STATE_ENDED, STATE_RECOGNIZED, STATE_CANCELLED, STATE_FAILED, DIRECTION_NONE, DIRECTION_LEFT, DIRECTION_RIGHT, DIRECTION_UP, DIRECTION_DOWN, DIRECTION_HORIZONTAL, DIRECTION_VERTICAL, DIRECTION_ALL, Manager, Input, TouchAction, TouchInput, MouseInput, PointerEventInput, TouchMouseInput, SingleTouchInput, Recognizer, AttrRecognizer, TapRecognizer as Tap, PanRecognizer as Pan, SwipeRecognizer as Swipe, PinchRecognizer as Pinch, RotateRecognizer as Rotate, PressRecognizer as Press, addEventListeners as on, removeEventListeners as off, each, merge, extend, assign$1 as assign, inherit, bindFn, prefixed, toArray, inArray, uniqueArray, splitStr, boolOrFn, hasParent, addEventListeners, removeEventListeners, defaults$1 as defaults };","map":{"version":3,"sources":["../src/utils/assign.js","../src/utils/utils-consts.js","../src/utils/prefixed.js","../src/browser.js","../src/touchactionjs/get-touchaction-props.js","../src/touchactionjs/touchaction-Consts.js","../src/inputjs/input-consts.js","../src/utils/each.js","../src/utils/bool-or-fn.js","../src/utils/in-str.js","../src/touchactionjs/clean-touch-actions.js","../src/touchactionjs/touchaction-constructor.js","../src/utils/has-parent.js","../src/inputjs/get-center.js","../src/inputjs/simple-clone-input-data.js","../src/inputjs/get-distance.js","../src/inputjs/get-angle.js","../src/inputjs/get-direction.js","../src/inputjs/compute-delta-xy.js","../src/inputjs/get-velocity.js","../src/inputjs/get-scale.js","../src/inputjs/get-rotation.js","../src/inputjs/compute-interval-input-data.js","../src/inputjs/compute-input-data.js","../src/inputjs/input-handler.js","../src/utils/split-str.js","../src/utils/add-event-listeners.js","../src/utils/remove-event-listeners.js","../src/utils/get-window-for-element.js","../src/inputjs/input-constructor.js","../src/utils/in-array.js","../src/input/pointerevent.js","../src/utils/to-array.js","../src/utils/unique-array.js","../src/input/touch.js","../src/input/mouse.js","../src/input/touchmouse.js","../src/inputjs/create-input-instance.js","../src/utils/invoke-array-arg.js","../src/recognizerjs/recognizer-consts.js","../src/utils/unique-id.js","../src/recognizerjs/get-recognizer-by-name-if-manager.js","../src/recognizerjs/state-str.js","../src/recognizerjs/recognizer-constructor.js","../src/recognizers/tap.js","../src/recognizers/attribute.js","../src/recognizerjs/direction-str.js","../src/recognizers/pan.js","../src/recognizers/swipe.js","../src/recognizers/pinch.js","../src/recognizers/rotate.js","../src/recognizers/press.js","../src/defaults.js","../src/manager.js","../src/input/singletouch.js","../src/utils/deprecate.js","../src/utils/extend.js","../src/utils/merge.js","../src/utils/inherit.js","../src/utils/bind-fn.js","../src/hammer.js","../src/index.js"],"names":["Object","assign","target","output","index","arguments","source","VENDOR_PREFIXES","TEST_ELEMENT","style","document","TYPE_FUNCTION","round","abs","Math","now","Date","camelProp","property","i","prefix","prop","win","PREFIXED_TOUCH_ACTION","prefixed","NATIVE_TOUCH_ACTION","touchMap","cssSupports","window","TOUCH_ACTION_COMPUTE","TOUCH_ACTION_AUTO","TOUCH_ACTION_MANIPULATION","TOUCH_ACTION_NONE","TOUCH_ACTION_PAN_X","TOUCH_ACTION_PAN_Y","TOUCH_ACTION_MAP","getTouchActionProps","MOBILE_REGEX","SUPPORT_TOUCH","SUPPORT_POINTER_EVENTS","SUPPORT_ONLY_TOUCH","navigator","INPUT_TYPE_TOUCH","INPUT_TYPE_PEN","INPUT_TYPE_MOUSE","INPUT_TYPE_KINECT","COMPUTE_INTERVAL","INPUT_START","INPUT_MOVE","INPUT_END","INPUT_CANCEL","DIRECTION_NONE","DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_UP","DIRECTION_DOWN","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","DIRECTION_ALL","PROPS_XY","PROPS_CLIENT_XY","obj","iterator","val","args","str","inStr","hasPanX","hasPanY","TouchAction","set","value","update","compute","actions","each","boolOrFn","recognizer","cleanTouchActions","preventDefaults","input","srcEvent","direction","hasNone","isTapPointer","isTapMovement","isTapTouchTime","preventSrc","node","pointersLength","pointers","x","y","clientX","clientY","timeStamp","center","getCenter","deltaX","deltaY","props","p2","p1","offset","session","prevDelta","prevInput","getDistance","end","start","getAngle","last","deltaTime","v","getVelocity","velocityX","velocityY","velocity","getDirection","manager","simpleCloneInputData","firstInput","firstMultiple","offsetCenter","computeDeltaXY","overallVelocity","getScale","getRotation","computeIntervalInputData","srcEventTarget","hasParent","pointersLen","changedPointersLen","isFirst","eventType","isFinal","computeInputData","splitStr","doc","element","Input","self","handler","init","addEventListeners","getWindowForElement","destroy","removeEventListeners","src","findByKey","POINTER_INPUT_MAP","pointerdown","pointermove","pointerup","pointercancel","pointerout","IE10_POINTER_TYPE_ENUM","POINTER_ELEMENT_EVENTS","POINTER_WINDOW_EVENTS","PointerEventInput","proto","ev","store","removePointer","eventTypeNormalized","pointerType","isTouch","storeIndex","inArray","changedPointers","Array","results","values","key","a","b","TOUCH_INPUT_MAP","touchstart","touchmove","touchend","touchcancel","TOUCH_TARGET_EVENTS","TouchInput","type","touches","getTouches","allTouches","toArray","targetIds","changedTouches","changedTargetTouches","targetTouches","touch","uniqueArray","MOUSE_INPUT_MAP","mousedown","mousemove","mouseup","MOUSE_ELEMENT_EVENTS","MOUSE_WINDOW_EVENTS","MouseInput","DEDUP_TIMEOUT","DEDUP_DISTANCE","eventData","lastTouch","lts","removeLastTouch","setTimeout","setLastTouch","t","dx","dy","TouchMouseInput","inputData","isMouse","recordTouches","isSyntheticEvent","inputClass","Type","context","STATE_POSSIBLE","STATE_BEGAN","STATE_CHANGED","STATE_ENDED","STATE_RECOGNIZED","STATE_CANCELLED","STATE_FAILED","_uniqueId","state","Recognizer","options","enable","uniqueId","recognizeWith","otherRecognizer","invokeArrayArg","simultaneous","getRecognizerByNameIfManager","dropRecognizeWith","requireFailure","requireFail","dropRequireFailure","hasRequireFailures","canRecognizeWith","emit","stateStr","tryEmit","canEmit","recognize","inputDataClone","process","getTouchAction","reset","TapRecognizer","event","taps","interval","time","threshold","posThreshold","validPointers","validMovement","validTouchTime","validInterval","validMultiTap","tapCount","failTimeout","clearTimeout","AttrRecognizer","attrTest","optionPointers","isRecognized","isValid","PanRecognizer","directionTest","hasMoved","distance","directionStr","SwipeRecognizer","PinchRecognizer","inOut","RotateRecognizer","PressRecognizer","validTime","domEvents","touchAction","inputTarget","cssProps","userSelect","touchSelect","touchCallout","contentZooming","userDrag","tapHighlightColor","preset","STOP","FORCED_STOP","gestureEvent","data","Manager","createInputInstance","toggleCssProps","item","stop","force","recognizers","curRecognizer","get","add","existing","remove","targetRecognizer","on","events","handlers","off","triggerDomEvent","SINGLE_TOUCH_INPUT_MAP","SINGLE_TOUCH_TARGET_EVENTS","SINGLE_TOUCH_WINDOW_EVENTS","SingleTouchInput","normalizeSingleTouches","all","changed","deprecationMessage","e","stack","log","method","extend","deprecate","keys","merge","dest","baseP","base","childP","child","fn","Hammer","VERSION","Tap","Pan","Swipe","Pinch","Rotate","Press","bindFn","inherit","defaults"],"mappings":"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","sourcesContent":["/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nlet assign;\nif (typeof Object.assign !== 'function') {\n  assign = function assign(target) {\n    if (target === undefined || target === null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    let output = Object(target);\n    for (let index = 1; index < arguments.length; index++) {\n      const source = arguments[index];\n      if (source !== undefined && source !== null) {\n        for (const nextKey in source) {\n          if (source.hasOwnProperty(nextKey)) {\n            output[nextKey] = source[nextKey];\n          }\n        }\n      }\n    }\n    return output;\n  };\n} else {\n  assign = Object.assign;\n}\n\nexport default assign;","\nconst VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nconst TEST_ELEMENT = typeof document === \"undefined\" ? {style: {}} : document.createElement('div');\n\nconst TYPE_FUNCTION = 'function';\n\nconst { round, abs } = Math;\nconst { now } = Date;\n\nexport {\n    VENDOR_PREFIXES,\n    TEST_ELEMENT,\n    TYPE_FUNCTION,\n    round,\n    abs,\n    now\n};\n","import { VENDOR_PREFIXES } from './utils-consts';\n/**\n * @private\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\nexport default function prefixed(obj, property) {\n  let prefix;\n  let prop;\n  let camelProp = property[0].toUpperCase() + property.slice(1);\n\n  let i = 0;\n  while (i < VENDOR_PREFIXES.length) {\n    prefix = VENDOR_PREFIXES[i];\n    prop = (prefix) ? prefix + camelProp : property;\n\n    if (prop in obj) {\n      return prop;\n    }\n    i++;\n  }\n  return undefined;\n}\n","/* eslint-disable no-new-func, no-nested-ternary */\n\nlet win;\n\nif (typeof window === \"undefined\") {\n\t// window is undefined in node.js\n\twin = {};\n} else {\n\twin = window;\n}\n/* eslint-enable no-new-func, no-nested-ternary */\n\nexport {win as window};\n","import prefixed from '../utils/prefixed';\nimport { TEST_ELEMENT } from '../utils/utils-consts';\nimport {window} from '../browser';\n\nexport const PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nexport const NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\nexport default function getTouchActionProps() {\n  if (!NATIVE_TOUCH_ACTION) {\n    return false;\n  }\n  let touchMap = {};\n  let cssSupports = window.CSS && window.CSS.supports;\n  ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach((val) => {\n\n    // If css.supports is not supported but there is native touch-action assume it supports\n    // all values. This is the case for IE 10 and 11.\n    return touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n  });\n  return touchMap;\n}\n","import getTouchActionProps from './get-touchaction-props';\n\n\n\n// magical touchAction value\nconst TOUCH_ACTION_COMPUTE = 'compute';\nconst TOUCH_ACTION_AUTO = 'auto';\nconst TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\nconst TOUCH_ACTION_NONE = 'none';\nconst TOUCH_ACTION_PAN_X = 'pan-x';\nconst TOUCH_ACTION_PAN_Y = 'pan-y';\nconst TOUCH_ACTION_MAP = getTouchActionProps();\n\nexport {\n  TOUCH_ACTION_AUTO,\n  TOUCH_ACTION_COMPUTE,\n  TOUCH_ACTION_MANIPULATION,\n  TOUCH_ACTION_NONE,\n  TOUCH_ACTION_PAN_X,\n  TOUCH_ACTION_PAN_Y,\n  TOUCH_ACTION_MAP\n};\n","import prefixed from '../utils/prefixed';\nimport {window} from \"../browser\";\n\nconst MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\nconst SUPPORT_TOUCH = ('ontouchstart' in window);\nconst SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\nconst SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\nconst INPUT_TYPE_TOUCH = 'touch';\nconst INPUT_TYPE_PEN = 'pen';\nconst INPUT_TYPE_MOUSE = 'mouse';\nconst INPUT_TYPE_KINECT = 'kinect';\n\nconst COMPUTE_INTERVAL = 25;\n\nconst INPUT_START = 1;\nconst INPUT_MOVE = 2;\nconst INPUT_END = 4;\nconst INPUT_CANCEL = 8;\n\nconst DIRECTION_NONE = 1;\nconst DIRECTION_LEFT = 2;\nconst DIRECTION_RIGHT = 4;\nconst DIRECTION_UP = 8;\nconst DIRECTION_DOWN = 16;\n\nconst DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nconst DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nconst DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\nconst PROPS_XY = ['x', 'y'];\nconst PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\nexport {\n    MOBILE_REGEX,\n    SUPPORT_ONLY_TOUCH,\n    SUPPORT_POINTER_EVENTS,\n    SUPPORT_TOUCH,\n    INPUT_TYPE_KINECT,\n    INPUT_TYPE_MOUSE,\n    INPUT_TYPE_PEN,\n    INPUT_TYPE_TOUCH,\n    COMPUTE_INTERVAL,\n    INPUT_START,\n    INPUT_MOVE,\n    INPUT_END,\n    INPUT_CANCEL,\n    DIRECTION_NONE,\n    DIRECTION_LEFT,\n    DIRECTION_RIGHT,\n    DIRECTION_UP,\n    DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL,\n    DIRECTION_ALL,\n    PROPS_XY,\n    PROPS_CLIENT_XY\n};\n","/**\n * @private\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nexport default function each(obj, iterator, context) {\n  let i;\n\n  if (!obj) {\n    return;\n  }\n\n  if (obj.forEach) {\n    obj.forEach(iterator, context);\n  } else if (obj.length !== undefined) {\n    i = 0;\n    while (i < obj.length) {\n      iterator.call(context, obj[i], i, obj);\n      i++;\n    }\n  } else {\n    for (i in obj) {\n      obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n    }\n  }\n}\n","import { TYPE_FUNCTION } from './utils-consts';\n/**\n * @private\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\nexport default function boolOrFn(val, args) {\n  if (typeof val === TYPE_FUNCTION) {\n    return val.apply(args ? args[0] || undefined : undefined, args);\n  }\n  return val;\n}\n","/**\n * @private\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nexport default function inStr(str, find) {\n  return str.indexOf(find) > -1;\n}\n","import inStr from '../utils/in-str';\nimport {\n    TOUCH_ACTION_NONE,\n    TOUCH_ACTION_PAN_X,\n    TOUCH_ACTION_PAN_Y,\n    TOUCH_ACTION_MANIPULATION,\n    TOUCH_ACTION_AUTO\n} from './touchaction-Consts';\n\n/**\n * @private\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\nexport default function cleanTouchActions(actions) {\n  // none\n  if (inStr(actions, TOUCH_ACTION_NONE)) {\n    return TOUCH_ACTION_NONE;\n  }\n\n  let hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n  let hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n  // if both pan-x and pan-y are set (different recognizers\n  // for different directions, e.g. horizontal pan but vertical swipe?)\n  // we need none (as otherwise with pan-x pan-y combined none of these\n  // recognizers will work, since the browser would handle all panning\n  if (hasPanX && hasPanY) {\n    return TOUCH_ACTION_NONE;\n  }\n\n  // pan-x OR pan-y\n  if (hasPanX || hasPanY) {\n    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n  }\n\n  // manipulation\n  if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n    return TOUCH_ACTION_MANIPULATION;\n  }\n\n  return TOUCH_ACTION_AUTO;\n}\n","import {\n    TOUCH_ACTION_COMPUTE,\n    TOUCH_ACTION_MAP,\n    TOUCH_ACTION_NONE,\n    TOUCH_ACTION_PAN_X,\n    TOUCH_ACTION_PAN_Y\n} from './touchaction-Consts';\nimport {\n  NATIVE_TOUCH_ACTION,\n  PREFIXED_TOUCH_ACTION,\n} from \"./get-touchaction-props\";\nimport {\n    DIRECTION_VERTICAL,\n    DIRECTION_HORIZONTAL\n} from '../inputjs/input-consts';\nimport each from '../utils/each';\nimport boolOrFn from '../utils/bool-or-fn';\nimport inStr from '../utils/in-str';\nimport cleanTouchActions from './clean-touch-actions';\n\n/**\n * @private\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\nexport default class TouchAction {\n  constructor(manager, value) {\n    this.manager = manager;\n    this.set(value);\n  }\n\n  /**\n   * @private\n   * set the touchAction value on the element or enable the polyfill\n   * @param {String} value\n   */\n  set(value) {\n    // find out the touch-action by the event handlers\n    if (value === TOUCH_ACTION_COMPUTE) {\n      value = this.compute();\n    }\n\n    if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n      this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n    }\n    this.actions = value.toLowerCase().trim();\n  }\n\n  /**\n   * @private\n   * just re-set the touchAction value\n   */\n  update() {\n    this.set(this.manager.options.touchAction);\n  }\n\n  /**\n   * @private\n   * compute the value for the touchAction property based on the recognizer's settings\n   * @returns {String} value\n   */\n  compute() {\n    let actions = [];\n    each(this.manager.recognizers, (recognizer) => {\n      if (boolOrFn(recognizer.options.enable, [recognizer])) {\n        actions = actions.concat(recognizer.getTouchAction());\n      }\n    });\n    return cleanTouchActions(actions.join(' '));\n  }\n\n  /**\n   * @private\n   * this method is called on each input cycle and provides the preventing of the browser behavior\n   * @param {Object} input\n   */\n  preventDefaults(input) {\n    let { srcEvent } = input;\n    let direction = input.offsetDirection;\n\n    // if the touch action did prevented once this session\n    if (this.manager.session.prevented) {\n      srcEvent.preventDefault();\n      return;\n    }\n\n    let { actions } = this;\n    let hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n    let hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n    let hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n    if (hasNone) {\n      // do not prevent defaults if this is a tap gesture\n      let isTapPointer = input.pointers.length === 1;\n      let isTapMovement = input.distance < 2;\n      let isTapTouchTime = input.deltaTime < 250;\n\n      if (isTapPointer && isTapMovement && isTapTouchTime) {\n        return;\n      }\n    }\n\n    if (hasPanX && hasPanY) {\n      // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n      return;\n    }\n\n    if (hasNone ||\n        (hasPanY && direction & DIRECTION_HORIZONTAL) ||\n        (hasPanX && direction & DIRECTION_VERTICAL)) {\n      return this.preventSrc(srcEvent);\n    }\n  }\n\n  /**\n   * @private\n   * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n   * @param {Object} srcEvent\n   */\n  preventSrc(srcEvent) {\n    this.manager.session.prevented = true;\n    srcEvent.preventDefault();\n  }\n}\n","/**\n * @private\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nexport default function hasParent(node, parent) {\n  while (node) {\n    if (node === parent) {\n      return true;\n    }\n    node = node.parentNode;\n  }\n  return false;\n}\n","import { round } from '../utils/utils-consts';\n\n/**\n * @private\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\nexport default function getCenter(pointers) {\n  let pointersLength = pointers.length;\n\n  // no need to loop when only one touch\n  if (pointersLength === 1) {\n    return {\n      x: round(pointers[0].clientX),\n      y: round(pointers[0].clientY)\n    };\n  }\n\n  let x = 0;\n  let y = 0;\n  let i = 0;\n  while (i < pointersLength) {\n    x += pointers[i].clientX;\n    y += pointers[i].clientY;\n    i++;\n  }\n\n  return {\n    x: round(x / pointersLength),\n    y: round(y / pointersLength)\n  };\n}\n","import { now,round } from '../utils/utils-consts';\nimport getCenter from './get-center';\n\n/**\n * @private\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\nexport default function simpleCloneInputData(input) {\n  // make a simple copy of the pointers because we will get a reference if we don't\n  // we only need clientXY for the calculations\n  let pointers = [];\n  let i = 0;\n  while (i < input.pointers.length) {\n    pointers[i] = {\n      clientX: round(input.pointers[i].clientX),\n      clientY: round(input.pointers[i].clientY)\n    };\n    i++;\n  }\n\n  return {\n    timeStamp: now(),\n    pointers,\n    center: getCenter(pointers),\n    deltaX: input.deltaX,\n    deltaY: input.deltaY\n  };\n}\n","import { PROPS_XY } from './input-consts';\n\n/**\n * @private\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\nexport default function getDistance(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n  let x = p2[props[0]] - p1[props[0]];\n  let y = p2[props[1]] - p1[props[1]];\n\n  return Math.sqrt((x * x) + (y * y));\n}\n","import { PROPS_XY } from './input-consts';\n\n/**\n * @private\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\nexport default function getAngle(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n  let x = p2[props[0]] - p1[props[0]];\n  let y = p2[props[1]] - p1[props[1]];\n  return Math.atan2(y, x) * 180 / Math.PI;\n}\n","import { abs } from '../utils/utils-consts';\nimport { DIRECTION_NONE,DIRECTION_LEFT,DIRECTION_RIGHT,DIRECTION_UP,DIRECTION_DOWN } from './input-consts';\n\n/**\n * @private\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\nexport default function getDirection(x, y) {\n  if (x === y) {\n    return DIRECTION_NONE;\n  }\n\n  if (abs(x) >= abs(y)) {\n    return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n  }\n  return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n","import { INPUT_START, INPUT_END } from './input-consts';\n\nexport default function computeDeltaXY(session, input) {\n  let { center } = input;\n  // let { offsetDelta:offset = {}, prevDelta = {}, prevInput = {} } = session;\n  // jscs throwing error on defalut destructured values and without defaults tests fail\n  let offset = session.offsetDelta || {};\n  let prevDelta = session.prevDelta || {};\n  let prevInput = session.prevInput || {};\n\n  if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n    prevDelta = session.prevDelta = {\n      x: prevInput.deltaX || 0,\n      y: prevInput.deltaY || 0\n    };\n\n    offset = session.offsetDelta = {\n      x: center.x,\n      y: center.y\n    };\n  }\n\n  input.deltaX = prevDelta.x + (center.x - offset.x);\n  input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n","/**\n * @private\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nexport default function getVelocity(deltaTime, x, y) {\n  return {\n    x: x / deltaTime || 0,\n    y: y / deltaTime || 0\n  };\n}\n","import { PROPS_CLIENT_XY } from './input-consts';\nimport getDistance from './get-distance';\n/**\n * @private\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\nexport default function getScale(start, end) {\n  return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n","import getAngle from './get-angle';\nimport { PROPS_CLIENT_XY } from './input-consts';\n\n/**\n * @private\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\nexport default function getRotation(start, end) {\n  return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n","import { INPUT_CANCEL,COMPUTE_INTERVAL } from './input-consts';\nimport { abs } from '../utils/utils-consts';\nimport getVelocity from './get-velocity';\nimport getDirection from './get-direction';\n\n/**\n * @private\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\nexport default function computeIntervalInputData(session, input) {\n  let last = session.lastInterval || input;\n  let deltaTime = input.timeStamp - last.timeStamp;\n  let velocity;\n  let velocityX;\n  let velocityY;\n  let direction;\n\n  if (input.eventType !== INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n    let deltaX = input.deltaX - last.deltaX;\n    let deltaY = input.deltaY - last.deltaY;\n\n    let v = getVelocity(deltaTime, deltaX, deltaY);\n    velocityX = v.x;\n    velocityY = v.y;\n    velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n    direction = getDirection(deltaX, deltaY);\n\n    session.lastInterval = input;\n  } else {\n    // use latest velocity info if it doesn't overtake a minimum period\n    velocity = last.velocity;\n    velocityX = last.velocityX;\n    velocityY = last.velocityY;\n    direction = last.direction;\n  }\n\n  input.velocity = velocity;\n  input.velocityX = velocityX;\n  input.velocityY = velocityY;\n  input.direction = direction;\n}\n","import { now } from '../utils/utils-consts';\nimport { abs } from '../utils/utils-consts';\nimport hasParent from '../utils/has-parent';\nimport simpleCloneInputData from './simple-clone-input-data';\nimport getCenter from './get-center';\nimport getDistance from './get-distance';\nimport getAngle from './get-angle';\nimport getDirection from './get-direction';\nimport computeDeltaXY from './compute-delta-xy';\nimport getVelocity from './get-velocity';\nimport getScale from './get-scale';\nimport getRotation from './get-rotation';\nimport computeIntervalInputData from './compute-interval-input-data';\n\n/**\n* @private\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\nexport default function computeInputData(manager, input) {\n  let { session } = manager;\n  let { pointers } = input;\n  let { length:pointersLength } = pointers;\n\n  // store the first input to calculate the distance and direction\n  if (!session.firstInput) {\n    session.firstInput = simpleCloneInputData(input);\n  }\n\n  // to compute scale and rotation we need to store the multiple touches\n  if (pointersLength > 1 && !session.firstMultiple) {\n    session.firstMultiple = simpleCloneInputData(input);\n  } else if (pointersLength === 1) {\n    session.firstMultiple = false;\n  }\n\n  let { firstInput, firstMultiple } = session;\n  let offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n  let center = input.center = getCenter(pointers);\n  input.timeStamp = now();\n  input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n  input.angle = getAngle(offsetCenter, center);\n  input.distance = getDistance(offsetCenter, center);\n\n  computeDeltaXY(session, input);\n  input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n  let overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n  input.overallVelocityX = overallVelocity.x;\n  input.overallVelocityY = overallVelocity.y;\n  input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;\n\n  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n  input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n  input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >\n  session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);\n\n  computeIntervalInputData(session, input);\n\n  // find the correct target\n  let target = manager.element;\n  const srcEvent = input.srcEvent;\n  let srcEventTarget;\n\n  if (srcEvent.composedPath) {\n    srcEventTarget = srcEvent.composedPath()[0];\n  } else if (srcEvent.path) {\n    srcEventTarget = srcEvent.path[0];\n  } else {\n    srcEventTarget = srcEvent.target;\n  }\n\n  if (hasParent(srcEventTarget, target)) {\n    target = srcEventTarget;\n  }\n  input.target = target;\n}\n","import { INPUT_START,INPUT_END,INPUT_CANCEL } from './input-consts';\nimport computeInputData from './compute-input-data';\n\n/**\n * @private\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\nexport default function inputHandler(manager, eventType, input) {\n  let pointersLen = input.pointers.length;\n  let changedPointersLen = input.changedPointers.length;\n  let isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\n  let isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\n\n  input.isFirst = !!isFirst;\n  input.isFinal = !!isFinal;\n\n  if (isFirst) {\n    manager.session = {};\n  }\n\n  // source event is the normalized value of the domEvents\n  // like 'touchstart, mouseup, pointerdown'\n  input.eventType = eventType;\n\n  // compute scale, rotation etc\n  computeInputData(manager, input);\n\n  // emit secret event\n  manager.emit('hammer.input', input);\n\n  manager.recognize(input);\n  manager.session.prevInput = input;\n}\n","/**\n * @private\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\n\nexport default function splitStr(str) {\n  return str.trim().split(/\\s+/g);\n}\n","import each from './each';\nimport splitStr from './split-str';\n/**\n * @private\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nexport default function addEventListeners(target, types, handler) {\n  each(splitStr(types), (type) => {\n    target.addEventListener(type, handler, false);\n  });\n}\n","import each from './each';\nimport splitStr from './split-str';\n/**\n * @private\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nexport default function removeEventListeners(target, types, handler) {\n  each(splitStr(types), (type) => {\n    target.removeEventListener(type, handler, false);\n  });\n}\n","/**\n * @private\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nexport default function getWindowForElement(element) {\n  let doc = element.ownerDocument || element;\n  return (doc.defaultView || doc.parentWindow || window);\n}\n","import boolOrFn from '../utils/bool-or-fn';\nimport addEventListeners from '../utils/add-event-listeners';\nimport removeEventListeners from '../utils/remove-event-listeners';\nimport getWindowForElement from '../utils/get-window-for-element';\n\n/**\n * @private\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\nexport default class Input {\n  constructor(manager, callback) {\n    let self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.domHandler = function(ev) {\n      if (boolOrFn(manager.options.enable, [manager])) {\n        self.handler(ev);\n      }\n    };\n\n    this.init();\n\n  }\n  /**\n   * @private\n   * should handle the inputEvent data and trigger the callback\n   * @virtual\n   */\n  handler() { }\n\n  /**\n   * @private\n   * bind the events\n   */\n  init() {\n    this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  }\n\n  /**\n   * @private\n   * unbind the events\n   */\n  destroy() {\n    this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  }\n}\n","/**\n * @private\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nexport default function inArray(src, find, findByKey) {\n  if (src.indexOf && !findByKey) {\n    return src.indexOf(find);\n  } else {\n    let i = 0;\n    while (i < src.length) {\n      if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {// do not use === here, test fails\n        return i;\n      }\n      i++;\n    }\n    return -1;\n  }\n}\n","import {\n    INPUT_START,\n    INPUT_END,\n    INPUT_CANCEL,\n    INPUT_MOVE,\n    INPUT_TYPE_TOUCH,\n    INPUT_TYPE_MOUSE,\n    INPUT_TYPE_PEN,\n    INPUT_TYPE_KINECT\n} from '../inputjs/input-consts';\nimport {window} from \"../browser\";\nimport Input from '../inputjs/input-constructor';\nimport inArray from '../utils/in-array';\n\nconst POINTER_INPUT_MAP = {\n  pointerdown: INPUT_START,\n  pointermove: INPUT_MOVE,\n  pointerup: INPUT_END,\n  pointercancel: INPUT_CANCEL,\n  pointerout: INPUT_CANCEL\n};\n\n// in IE10 the pointer types is defined as an enum\nconst IE10_POINTER_TYPE_ENUM = {\n  2: INPUT_TYPE_TOUCH,\n  3: INPUT_TYPE_PEN,\n  4: INPUT_TYPE_MOUSE,\n  5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n};\n\nlet POINTER_ELEMENT_EVENTS = 'pointerdown';\nlet POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n// IE10 has prefixed support, and case-sensitive\nif (window.MSPointerEvent && !window.PointerEvent) {\n  POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n  POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n\n/**\n * @private\n * Pointer events input\n * @constructor\n * @extends Input\n */\nexport default class PointerEventInput extends Input {\n  constructor() {\n    var proto = PointerEventInput.prototype;\n\n    proto.evEl = POINTER_ELEMENT_EVENTS;\n    proto.evWin = POINTER_WINDOW_EVENTS;\n    super(...arguments);\n    this.store = (this.manager.session.pointerEvents = []);\n  }\n\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n  handler(ev) {\n    let { store } = this;\n    let removePointer = false;\n\n    let eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n    let eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n    let pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\n    let isTouch = (pointerType === INPUT_TYPE_TOUCH);\n\n    // get index of the event in the store\n    let storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n    // start and mouse must be down\n    if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n      if (storeIndex < 0) {\n        store.push(ev);\n        storeIndex = store.length - 1;\n      }\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n      removePointer = true;\n    }\n\n    // it not found, so the pointer hasn't been down (so it's probably a hover)\n    if (storeIndex < 0) {\n      return;\n    }\n\n    // update the event in the store\n    store[storeIndex] = ev;\n\n    this.callback(this.manager, eventType, {\n      pointers: store,\n      changedPointers: [ev],\n      pointerType,\n      srcEvent: ev\n    });\n\n    if (removePointer) {\n      // remove from the store\n      store.splice(storeIndex, 1);\n    }\n  }\n}\n","/**\n * @private\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nexport default function toArray(obj) {\n  return Array.prototype.slice.call(obj, 0);\n}\n","import inArray from './in-array';\n\n/**\n * @private\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\nexport default function uniqueArray(src, key, sort) {\n  let results = [];\n  let values = [];\n  let i = 0;\n\n  while (i < src.length) {\n    let val = key ? src[i][key] : src[i];\n    if (inArray(values, val) < 0) {\n      results.push(src[i]);\n    }\n    values[i] = val;\n    i++;\n  }\n\n  if (sort) {\n    if (!key) {\n      results = results.sort();\n    } else {\n      results = results.sort((a, b) => {\n        return a[key] > b[key];\n      });\n    }\n  }\n\n  return results;\n}\n","import {\n  INPUT_START,\n  INPUT_MOVE,\n  INPUT_END,\n  INPUT_CANCEL,\n  INPUT_TYPE_TOUCH\n} from '../inputjs/input-consts';\nimport Input from '../inputjs/input-constructor';\nimport toArray from '../utils/to-array';\nimport hasParent from '../utils/has-parent';\nimport uniqueArray from '../utils/unique-array';\n\nconst TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\n\nconst TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * @private\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\nexport default class TouchInput extends Input {\n  constructor() {\n    TouchInput.prototype.evTarget = TOUCH_TARGET_EVENTS;\n    super(...arguments);\n    this.targetIds = {};\n    // this.evTarget = TOUCH_TARGET_EVENTS;\n  }\n  handler(ev) {\n    let type = TOUCH_INPUT_MAP[ev.type];\n    let touches = getTouches.call(this, ev, type);\n    if (!touches) {\n      return;\n    }\n\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  }\n}\n\n/**\n * @private\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction getTouches(ev, type) {\n  let allTouches = toArray(ev.touches);\n  let { targetIds } = this;\n\n  // when there is only one touch, the process can be simplified\n  if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n    targetIds[allTouches[0].identifier] = true;\n    return [allTouches, allTouches];\n  }\n\n  let i;\n  let targetTouches;\n  let changedTouches = toArray(ev.changedTouches);\n  let changedTargetTouches = [];\n  let { target } = this;\n\n  // get target touches from touches\n  targetTouches = allTouches.filter((touch) => {\n    return hasParent(touch.target, target);\n  });\n\n  // collect touches\n  if (type === INPUT_START) {\n    i = 0;\n    while (i < targetTouches.length) {\n      targetIds[targetTouches[i].identifier] = true;\n      i++;\n    }\n  }\n\n  // filter changed touches to only contain touches that exist in the collected target ids\n  i = 0;\n  while (i < changedTouches.length) {\n    if (targetIds[changedTouches[i].identifier]) {\n      changedTargetTouches.push(changedTouches[i]);\n    }\n\n    // cleanup removed touches\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n      delete targetIds[changedTouches[i].identifier];\n    }\n    i++;\n  }\n\n  if (!changedTargetTouches.length) {\n    return;\n  }\n\n  return [\n    // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n    uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\n    changedTargetTouches\n  ];\n}\n","import {\n    INPUT_START,\n    INPUT_MOVE,\n    INPUT_END,\n    INPUT_TYPE_MOUSE\n} from '../inputjs/input-consts';\nimport Input from '../inputjs/input-constructor';\n\nconst MOUSE_INPUT_MAP = {\n  mousedown: INPUT_START,\n  mousemove: INPUT_MOVE,\n  mouseup: INPUT_END\n};\n\nconst MOUSE_ELEMENT_EVENTS = 'mousedown';\nconst MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n/**\n * @private\n * Mouse events input\n * @constructor\n * @extends Input\n */\nexport default class MouseInput extends Input {\n  constructor() {\n    var proto = MouseInput.prototype;\n    proto.evEl = MOUSE_ELEMENT_EVENTS;\n    proto.evWin = MOUSE_WINDOW_EVENTS;\n\n    super(...arguments);\n    this.pressed = false; // mousedown state\n  }\n\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n  handler(ev) {\n    let eventType = MOUSE_INPUT_MAP[ev.type];\n\n    // on start we want to have the left mouse button down\n    if (eventType & INPUT_START && ev.button === 0) {\n      this.pressed = true;\n    }\n\n    if (eventType & INPUT_MOVE && ev.which !== 1) {\n      eventType = INPUT_END;\n    }\n\n    // mouse must be down\n    if (!this.pressed) {\n      return;\n    }\n\n    if (eventType & INPUT_END) {\n      this.pressed = false;\n    }\n\n    this.callback(this.manager, eventType, {\n      pointers: [ev],\n      changedPointers: [ev],\n      pointerType: INPUT_TYPE_MOUSE,\n      srcEvent: ev\n    });\n  }\n}\n","import Input from \"../inputjs/input-constructor\";\nimport TouchInput from \"./touch\";\nimport MouseInput from \"./mouse\";\nimport {\n\tINPUT_START,\n\tINPUT_END,\n\tINPUT_CANCEL,\n\tINPUT_TYPE_TOUCH,\n\tINPUT_TYPE_MOUSE,\n} from \"../inputjs/input-consts\";\n\n/**\n * @private\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\nconst DEDUP_TIMEOUT = 2500;\nconst DEDUP_DISTANCE = 25;\n\nfunction setLastTouch(eventData) {\n\tconst { changedPointers: [touch] } = eventData;\n\n\tif (touch.identifier === this.primaryTouch) {\n\t\tconst lastTouch = { x: touch.clientX, y: touch.clientY };\n\t\tconst lts = this.lastTouches;\n\n\t\tthis.lastTouches.push(lastTouch);\n\n\n\t\tconst removeLastTouch = function() {\n\t\t\tconst i = lts.indexOf(lastTouch);\n\n\t\t\tif (i > -1) {\n\t\t\t\tlts.splice(i, 1);\n\t\t\t}\n\t\t};\n\n\t\tsetTimeout(removeLastTouch, DEDUP_TIMEOUT);\n\t}\n}\n\n\nfunction recordTouches(eventType, eventData) {\n\tif (eventType & INPUT_START) {\n\t\tthis.primaryTouch = eventData.changedPointers[0].identifier;\n\t\tsetLastTouch.call(this, eventData);\n\t} else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n\t\tsetLastTouch.call(this, eventData);\n\t}\n}\nfunction isSyntheticEvent(eventData) {\n\tconst x = eventData.srcEvent.clientX;\n\tconst y = eventData.srcEvent.clientY;\n\n\tfor (let i = 0; i < this.lastTouches.length; i++) {\n\t\tconst t = this.lastTouches[i];\n\t\tconst dx = Math.abs(x - t.x);\n\t\tconst dy = Math.abs(y - t.y);\n\n\t\tif (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n\nexport default class TouchMouseInput extends Input {\n\tconstructor(manager, callback) {\n\t\tsuper(manager, callback);\n\n\t\tthis.touch = new TouchInput(this.manager, this.handler);\n\t\tthis.mouse = new MouseInput(this.manager, this.handler);\n\t\tthis.primaryTouch = null;\n\t\tthis.lastTouches = [];\n\t}\n\n\t/**\n\t * @private\n\t * handle mouse and touch events\n\t * @param {Hammer} manager\n\t * @param {String} inputEvent\n\t * @param {Object} inputData\n\t */\n\thandler = (manager, inputEvent, inputData) => {\n\t\tconst isTouch = (inputData.pointerType === INPUT_TYPE_TOUCH);\n\t\tconst isMouse = (inputData.pointerType === INPUT_TYPE_MOUSE);\n\n\t\tif (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n\t\t\treturn;\n\t\t}\n\n\t\t// when we're in a touch event, record touches to  de-dupe synthetic mouse event\n\t\tif (isTouch) {\n\t\t\trecordTouches.call(this, inputEvent, inputData);\n\t\t} else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.callback(manager, inputEvent, inputData);\n\t}\n\n\t/**\n\t * @private\n\t * remove the event listeners\n\t */\n\tdestroy() {\n\t\tthis.touch.destroy();\n\t\tthis.mouse.destroy();\n\t}\n}\n","import { SUPPORT_POINTER_EVENTS,SUPPORT_ONLY_TOUCH,SUPPORT_TOUCH } from './input-consts';\nimport inputHandler from './input-handler';\nimport PointerEventInput from '../input/pointerevent';\nimport TouchInput from '../input/touch';\nimport MouseInput from '../input/mouse';\nimport TouchMouseInput from '../input/touchmouse';\n\n/**\n * @private\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\nexport default function createInputInstance(manager) {\n  let Type;\n  // let inputClass = manager.options.inputClass;\n  let { options:{ inputClass } } = manager;\n  if (inputClass) {\n    Type = inputClass;\n  } else if (SUPPORT_POINTER_EVENTS) {\n    Type = PointerEventInput;\n  } else if (SUPPORT_ONLY_TOUCH) {\n    Type = TouchInput;\n  } else if (!SUPPORT_TOUCH) {\n    Type = MouseInput;\n  } else {\n    Type = TouchMouseInput;\n  }\n  return new (Type)(manager, inputHandler);\n}\n","import each from './each';\n/**\n * @private\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\nexport default function invokeArrayArg(arg, fn, context) {\n  if (Array.isArray(arg)) {\n    each(arg, context[fn], context);\n    return true;\n  }\n  return false;\n}\n","const STATE_POSSIBLE = 1;\nconst STATE_BEGAN = 2;\nconst STATE_CHANGED = 4;\nconst STATE_ENDED = 8;\nconst STATE_RECOGNIZED = STATE_ENDED;\nconst STATE_CANCELLED = 16;\nconst STATE_FAILED = 32;\n\nexport {\n    STATE_POSSIBLE,\n    STATE_BEGAN,\n    STATE_CHANGED,\n    STATE_ENDED,\n    STATE_RECOGNIZED,\n    STATE_CANCELLED,\n    STATE_FAILED\n};\n","/**\n * @private\n * get a unique id\n * @returns {number} uniqueId\n */\nlet _uniqueId = 1;\nexport default function uniqueId() {\n  return _uniqueId++;\n}\n","/**\n * @private\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nexport default function getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n  let { manager } = recognizer;\n  if (manager) {\n    return manager.get(otherRecognizer);\n  }\n  return otherRecognizer;\n}\n","import {\n    STATE_CANCELLED,\n    STATE_ENDED,\n    STATE_CHANGED,\n    STATE_BEGAN\n} from './recognizer-consts';\n\n/**\n * @private\n * get a usable string, used as event postfix\n * @param {constant} state\n * @returns {String} state\n */\nexport default function stateStr(state) {\n  if (state & STATE_CANCELLED) {\n    return 'cancel';\n  } else if (state & STATE_ENDED) {\n    return 'end';\n  } else if (state & STATE_CHANGED) {\n    return 'move';\n  } else if (state & STATE_BEGAN) {\n    return 'start';\n  }\n  return '';\n}\n","import {\n    STATE_POSSIBLE,\n    STATE_ENDED,\n    STATE_FAILED,\n    STATE_RECOGNIZED,\n    STATE_CANCELLED,\n    STATE_BEGAN,\n    STATE_CHANGED\n} from './recognizer-consts';\nimport assign from '../utils/assign';\nimport uniqueId from '../utils/unique-id';\nimport invokeArrayArg from '../utils/invoke-array-arg';\nimport inArray from '../utils/in-array';\nimport boolOrFn from '../utils/bool-or-fn';\nimport getRecognizerByNameIfManager from './get-recognizer-by-name-if-manager';\nimport stateStr from './state-str';\n\n/**\n * @private\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\n\n/**\n * @private\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\nexport default class Recognizer {\n  constructor(options = {}) {\n    this.options = {\n      enable: true,\n      ...options,\n    };\n\n    this.id = uniqueId();\n\n    this.manager = null;\n\n    // default is enable true\n    this.state = STATE_POSSIBLE;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n\n  /**\n   * @private\n   * set options\n   * @param {Object} options\n   * @return {Recognizer}\n   */\n  set(options) {\n    assign(this.options, options);\n\n    // also update the touchAction, in case something changed about the directions/enabled state\n    this.manager && this.manager.touchAction.update();\n    return this;\n  }\n\n  /**\n   * @private\n   * recognize simultaneous with an other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n  recognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n      return this;\n    }\n\n    let { simultaneous } = this;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    if (!simultaneous[otherRecognizer.id]) {\n      simultaneous[otherRecognizer.id] = otherRecognizer;\n      otherRecognizer.recognizeWith(this);\n    }\n    return this;\n  }\n\n  /**\n   * @private\n   * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n  dropRecognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n      return this;\n    }\n\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    delete this.simultaneous[otherRecognizer.id];\n    return this;\n  }\n\n  /**\n   * @private\n   * recognizer can only run when an other is failing\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n  requireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n      return this;\n    }\n\n    let { requireFail } = this;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    if (inArray(requireFail, otherRecognizer) === -1) {\n      requireFail.push(otherRecognizer);\n      otherRecognizer.requireFailure(this);\n    }\n    return this;\n  }\n\n  /**\n   * @private\n   * drop the requireFailure link. it does not remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n  dropRequireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n      return this;\n    }\n\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    let index = inArray(this.requireFail, otherRecognizer);\n    if (index > -1) {\n      this.requireFail.splice(index, 1);\n    }\n    return this;\n  }\n\n  /**\n   * @private\n   * has require failures boolean\n   * @returns {boolean}\n   */\n  hasRequireFailures() {\n    return this.requireFail.length > 0;\n  }\n\n  /**\n   * @private\n   * if the recognizer can recognize simultaneous with an other recognizer\n   * @param {Recognizer} otherRecognizer\n   * @returns {Boolean}\n   */\n  canRecognizeWith(otherRecognizer) {\n    return !!this.simultaneous[otherRecognizer.id];\n  }\n\n  /**\n   * @private\n   * You should use `tryEmit` instead of `emit` directly to check\n   * that all the needed recognizers has failed before emitting.\n   * @param {Object} input\n   */\n  emit(input) {\n    let self = this;\n    let { state } = this;\n\n    function emit(event) {\n      self.manager.emit(event, input);\n    }\n\n    // 'panstart' and 'panmove'\n    if (state < STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n\n    emit(self.options.event); // simple 'eventName' events\n\n    if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)\n      emit(input.additionalEvent);\n    }\n\n    // panend and pancancel\n    if (state >= STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n  }\n\n  /**\n   * @private\n   * Check that all the require failure recognizers has failed,\n   * if true, it emits a gesture event,\n   * otherwise, setup the state to FAILED.\n   * @param {Object} input\n   */\n  tryEmit(input) {\n    if (this.canEmit()) {\n      return this.emit(input);\n    }\n    // it's failing anyway\n    this.state = STATE_FAILED;\n  }\n\n  /**\n   * @private\n   * can we emit?\n   * @returns {boolean}\n   */\n  canEmit() {\n    let i = 0;\n    while (i < this.requireFail.length) {\n      if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n        return false;\n      }\n      i++;\n    }\n    return true;\n  }\n\n  /**\n   * @private\n   * update the recognizer\n   * @param {Object} inputData\n   */\n  recognize(inputData) {\n    // make a new copy of the inputData\n    // so we can change the inputData without messing up the other recognizers\n    let inputDataClone = assign({}, inputData);\n\n    // is is enabled and allow recognizing?\n    if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n      this.reset();\n      this.state = STATE_FAILED;\n      return;\n    }\n\n    // reset when we've reached the end\n    if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n      this.state = STATE_POSSIBLE;\n    }\n\n    this.state = this.process(inputDataClone);\n\n    // the recognizer has recognized a gesture\n    // so trigger an event\n    if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n      this.tryEmit(inputDataClone);\n    }\n  }\n\n  /**\n   * @private\n   * return the state of the recognizer\n   * the actual recognizing happens in this method\n   * @virtual\n   * @param {Object} inputData\n   * @returns {constant} STATE\n   */\n\n  /* jshint ignore:start */\n  process(inputData) { }\n  /* jshint ignore:end */\n\n  /**\n   * @private\n   * return the preferred touch-action\n   * @virtual\n   * @returns {Array}\n   */\n  getTouchAction() { }\n\n  /**\n   * @private\n   * called when the gesture isn't allowed to recognize\n   * like when another is being recognized or it is disabled\n   * @virtual\n   */\n  reset() { }\n}","import Recognizer from '../recognizerjs/recognizer-constructor';\nimport { TOUCH_ACTION_MANIPULATION } from '../touchactionjs/touchaction-Consts';\nimport {INPUT_START,INPUT_END } from '../inputjs/input-consts';\nimport {\n    STATE_RECOGNIZED,\n    STATE_BEGAN,\n    STATE_FAILED\n} from '../recognizerjs/recognizer-consts';\nimport getDistance from '../inputjs/get-distance';\n\n/**\n * @private\n * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\nexport default class TapRecognizer extends Recognizer {\n  constructor(options = {}) {\n    super({\n      event: 'tap',\n      pointers: 1,\n      taps: 1,\n      interval: 300, // max time between the multi-tap taps\n      time: 250, // max time of the pointer to be down (like finger on the screen)\n      threshold: 9, // a minimal movement is ok, but keep it low\n      posThreshold: 10, // a multi-tap can be a bit off the initial position\n      ...options,\n    });\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n  }\n\n  getTouchAction() {\n    return [TOUCH_ACTION_MANIPULATION];\n  }\n\n  process(input) {\n    let { options } = this;\n\n    let validPointers = input.pointers.length === options.pointers;\n    let validMovement = input.distance < options.threshold;\n    let validTouchTime = input.deltaTime < options.time;\n\n    this.reset();\n\n    if ((input.eventType & INPUT_START) && (this.count === 0)) {\n      return this.failTimeout();\n    }\n\n    // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n    if (validMovement && validTouchTime && validPointers) {\n      if (input.eventType !== INPUT_END) {\n        return this.failTimeout();\n      }\n\n      let validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\n      let validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\n      this.pTime = input.timeStamp;\n      this.pCenter = input.center;\n\n      if (!validMultiTap || !validInterval) {\n        this.count = 1;\n      } else {\n        this.count += 1;\n      }\n\n      this._input = input;\n\n      // if tap count matches we have recognized it,\n      // else it has began recognizing...\n      let tapCount = this.count % options.taps;\n      if (tapCount === 0) {\n        // no failing requirements, immediately trigger the tap event\n        // or wait as long as the multitap interval to trigger\n        if (!this.hasRequireFailures()) {\n          return STATE_RECOGNIZED;\n        } else {\n          this._timer = setTimeout(() => {\n            this.state = STATE_RECOGNIZED;\n            this.tryEmit();\n          }, options.interval);\n          return STATE_BEGAN;\n        }\n      }\n    }\n    return STATE_FAILED;\n  }\n\n  failTimeout() {\n    this._timer = setTimeout(() => {\n      this.state = STATE_FAILED;\n    }, this.options.interval);\n    return STATE_FAILED;\n  }\n\n  reset() {\n    clearTimeout(this._timer);\n  }\n\n  emit() {\n    if (this.state === STATE_RECOGNIZED) {\n      this._input.tapCount = this.count;\n      this.manager.emit(this.options.event, this._input);\n    }\n  }\n}\n","import Recognizer from '../recognizerjs/recognizer-constructor';\nimport {\n    STATE_BEGAN,\n    STATE_CHANGED,\n    STATE_CANCELLED,\n    STATE_ENDED,\n    STATE_FAILED\n} from '../recognizerjs/recognizer-consts';\nimport {\n    INPUT_CANCEL,\n    INPUT_END\n} from '../inputjs/input-consts';\n\n/**\n * @private\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\nexport default class AttrRecognizer extends Recognizer {\n  constructor(options = {}) {\n    super({\n      pointers: 1,\n      ...options,\n    });\n  }\n\n  /**\n   * @private\n   * Used to check if it the recognizer receives valid input, like input.distance > 10.\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {Boolean} recognized\n   */\n  attrTest(input) {\n    let optionPointers = this.options.pointers;\n    return optionPointers === 0 || input.pointers.length === optionPointers;\n  }\n\n  /**\n   * @private\n   * Process the input and return the state for the recognizer\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {*} State\n   */\n  process(input) {\n    let { state } = this;\n    let { eventType } = input;\n\n    let isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n    let isValid = this.attrTest(input);\n\n    // on cancel input and we've recognized before, return STATE_CANCELLED\n    if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n      return state | STATE_CANCELLED;\n    } else if (isRecognized || isValid) {\n      if (eventType & INPUT_END) {\n        return state | STATE_ENDED;\n      } else if (!(state & STATE_BEGAN)) {\n        return STATE_BEGAN;\n      }\n      return state | STATE_CHANGED;\n    }\n    return STATE_FAILED;\n  }\n}\n","import {\n    DIRECTION_LEFT,\n    DIRECTION_RIGHT,\n    DIRECTION_UP,\n    DIRECTION_DOWN\n} from '../inputjs/input-consts';\n\n/**\n * @private\n * direction cons to string\n * @param {constant} direction\n * @returns {String}\n */\nexport default function directionStr(direction) {\n  if (direction === DIRECTION_DOWN) {\n    return 'down';\n  } else if (direction === DIRECTION_UP) {\n    return 'up';\n  } else if (direction === DIRECTION_LEFT) {\n    return 'left';\n  } else if (direction === DIRECTION_RIGHT) {\n    return 'right';\n  }\n  return '';\n}\n","import  AttrRecognizer from './attribute';\nimport {\n    DIRECTION_ALL,\n    DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL,\n    DIRECTION_NONE,\n    DIRECTION_UP,\n    DIRECTION_DOWN,\n    DIRECTION_LEFT,\n    DIRECTION_RIGHT\n} from '../inputjs/input-consts';\nimport { STATE_BEGAN } from '../recognizerjs/recognizer-consts';\nimport { TOUCH_ACTION_PAN_X,TOUCH_ACTION_PAN_Y } from '../touchactionjs/touchaction-Consts';\nimport directionStr from '../recognizerjs/direction-str';\n\n/**\n * @private\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nexport default class PanRecognizer extends AttrRecognizer {\n  constructor(options = {}) {\n    super({\n      event: 'pan',\n      threshold: 10,\n      pointers: 1,\n      direction: DIRECTION_ALL,\n      ...options,\n    });\n    this.pX = null;\n    this.pY = null;\n  }\n\n  getTouchAction() {\n    let { options:{ direction } } = this;\n    let actions = [];\n    if (direction & DIRECTION_HORIZONTAL) {\n      actions.push(TOUCH_ACTION_PAN_Y);\n    }\n    if (direction & DIRECTION_VERTICAL) {\n      actions.push(TOUCH_ACTION_PAN_X);\n    }\n    return actions;\n  }\n\n  directionTest(input) {\n    let { options } = this;\n    let hasMoved = true;\n    let { distance } = input;\n    let { direction } = input;\n    let x = input.deltaX;\n    let y = input.deltaY;\n\n    // lock to axis?\n    if (!(direction & options.direction)) {\n      if (options.direction & DIRECTION_HORIZONTAL) {\n        direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n        hasMoved = x !== this.pX;\n        distance = Math.abs(input.deltaX);\n      } else {\n        direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n        hasMoved = y !== this.pY;\n        distance = Math.abs(input.deltaY);\n      }\n    }\n    input.direction = direction;\n    return hasMoved && distance > options.threshold && direction & options.direction;\n  }\n\n  attrTest(input) {\n    return AttrRecognizer.prototype.attrTest.call(this, input) && // replace with a super call\n        (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\n  }\n\n  emit(input) {\n\n    this.pX = input.deltaX;\n    this.pY = input.deltaY;\n\n    let direction = directionStr(input.direction);\n\n    if (direction) {\n      input.additionalEvent = this.options.event + direction;\n    }\n    super.emit(input);\n  }\n}\n","import AttrRecognizer from '../recognizers/attribute';\nimport { abs } from '../utils/utils-consts';\nimport { DIRECTION_HORIZONTAL,DIRECTION_VERTICAL } from '../inputjs/input-consts';\nimport PanRecognizer from './pan';\nimport { INPUT_END } from '../inputjs/input-consts';\nimport directionStr from '../recognizerjs/direction-str';\n\n/**\n * @private\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nexport default class SwipeRecognizer extends AttrRecognizer {\n  constructor(options = {}) {\n    super({\n      event: 'swipe',\n      threshold: 10,\n      velocity: 0.3,\n      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n      pointers: 1,\n      ...options,\n    });\n  }\n\n  getTouchAction() {\n    return PanRecognizer.prototype.getTouchAction.call(this);\n  }\n\n  attrTest(input) {\n    let { direction } = this.options;\n    let velocity;\n\n    if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n      velocity = input.overallVelocity;\n    } else if (direction & DIRECTION_HORIZONTAL) {\n      velocity = input.overallVelocityX;\n    } else if (direction & DIRECTION_VERTICAL) {\n      velocity = input.overallVelocityY;\n    }\n\n    return super.attrTest(input) &&\n        direction & input.offsetDirection &&\n        input.distance > this.options.threshold &&\n        input.maxPointers === this.options.pointers &&\n        abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n  }\n\n  emit(input) {\n    let direction = directionStr(input.offsetDirection);\n    if (direction) {\n      this.manager.emit(this.options.event + direction, input);\n    }\n\n    this.manager.emit(this.options.event, input);\n  }\n}\n","import AttrRecognizer from './attribute';\nimport { TOUCH_ACTION_NONE } from '../touchactionjs/touchaction-Consts';\nimport { STATE_BEGAN } from '../recognizerjs/recognizer-consts';\n\n/**\n * @private\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\nexport default class PinchRecognizer extends AttrRecognizer {\n  constructor(options = {}) {\n    super({\n      event: 'pinch',\n      threshold: 0,\n      pointers: 2,\n      ...options,\n    });\n  }\n\n  getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  }\n\n  attrTest(input) {\n    return super.attrTest(input) &&\n        (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n  }\n\n  emit(input) {\n    if (input.scale !== 1) {\n      let inOut = input.scale < 1 ? 'in' : 'out';\n      input.additionalEvent = this.options.event + inOut;\n    }\n    super.emit(input);\n  }\n}\n","import AttrRecognizer from './attribute';\nimport { TOUCH_ACTION_NONE } from '../touchactionjs/touchaction-Consts';\nimport { STATE_BEGAN } from '../recognizerjs/recognizer-consts';\n\n/**\n * @private\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\nexport default class RotateRecognizer extends AttrRecognizer {\n  constructor(options = {}) {\n    super( {\n      event: 'rotate',\n      threshold: 0,\n      pointers: 2,\n      ...options,\n    });\n  }\n\n  getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  }\n\n  attrTest(input) {\n    return super.attrTest(input) &&\n        (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n  }\n}","import Recognizer from '../recognizerjs/recognizer-constructor';\nimport {\n    STATE_RECOGNIZED,\n    STATE_FAILED\n} from '../recognizerjs/recognizer-consts';\nimport { now } from '../utils/utils-consts';\nimport { TOUCH_ACTION_AUTO } from '../touchactionjs/touchaction-Consts';\nimport {\n    INPUT_START,\n    INPUT_END,\n    INPUT_CANCEL\n} from '../inputjs/input-consts';\n\n/**\n * @private\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\nexport default class PressRecognizer extends Recognizer {\n  constructor(options = {}) {\n    super({\n      event: 'press',\n      pointers: 1,\n      time: 251, // minimal time of the pointer to be pressed\n      threshold: 9, // a minimal movement is ok, but keep it low\n      ...options,\n    });\n    this._timer = null;\n    this._input = null;\n  }\n\n  getTouchAction() {\n    return [TOUCH_ACTION_AUTO];\n  }\n\n  process(input) {\n    let { options } = this;\n    let validPointers = input.pointers.length === options.pointers;\n    let validMovement = input.distance < options.threshold;\n    let validTime = input.deltaTime > options.time;\n\n    this._input = input;\n\n    // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n    if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\n      this.reset();\n    } else if (input.eventType & INPUT_START) {\n      this.reset();\n      this._timer = setTimeout(() => {\n        this.state = STATE_RECOGNIZED;\n        this.tryEmit();\n      }, options.time);\n    } else if (input.eventType & INPUT_END) {\n      return STATE_RECOGNIZED;\n    }\n    return STATE_FAILED;\n  }\n\n  reset() {\n    clearTimeout(this._timer);\n  }\n\n  emit(input) {\n    if (this.state !== STATE_RECOGNIZED) {\n      return;\n    }\n\n    if (input && (input.eventType & INPUT_END)) {\n      this.manager.emit(`${this.options.event}up`, input);\n    } else {\n      this._input.timeStamp = now();\n      this.manager.emit(this.options.event, this._input);\n    }\n  }\n}\n\n","import { TOUCH_ACTION_COMPUTE } from \"./touchactionjs/touchaction-Consts\";\nimport TapRecognizer from \"./recognizers/tap\";\nimport PanRecognizer from \"./recognizers/pan\";\nimport SwipeRecognizer from \"./recognizers/swipe\";\nimport PinchRecognizer from \"./recognizers/pinch\";\nimport RotateRecognizer from \"./recognizers/rotate\";\nimport PressRecognizer from \"./recognizers/press\";\nimport {DIRECTION_HORIZONTAL} from \"./inputjs/input-consts\";\n\nexport default {\n\t/**\n\t * @private\n\t * set if DOM events are being triggered.\n\t * But this is slower and unused by simple implementations, so disabled by default.\n\t * @type {Boolean}\n\t * @default false\n\t */\n\tdomEvents: false,\n\n\t/**\n\t * @private\n\t * The value for the touchAction property/fallback.\n\t * When set to `compute` it will magically set the correct value based on the added recognizers.\n\t * @type {String}\n\t * @default compute\n\t */\n\ttouchAction: TOUCH_ACTION_COMPUTE,\n\n\t/**\n\t * @private\n\t * @type {Boolean}\n\t * @default true\n\t */\n\tenable: true,\n\n\t/**\n\t * @private\n\t * EXPERIMENTAL FEATURE -- can be removed/changed\n\t * Change the parent input target element.\n\t * If Null, then it is being set the to main element.\n\t * @type {Null|EventTarget}\n\t * @default null\n\t */\n\tinputTarget: null,\n\n\t/**\n\t * @private\n\t * force an input class\n\t * @type {Null|Function}\n\t * @default null\n\t */\n\tinputClass: null,\n\n\t/**\n\t * @private\n\t * Some CSS properties can be used to improve the working of Hammer.\n\t * Add them to this method and they will be set when creating a new Manager.\n\t * @namespace\n\t */\n\tcssProps: {\n\t\t/**\n\t\t * @private\n\t\t * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n\t\t * @type {String}\n\t\t * @default 'none'\n\t\t */\n\t\tuserSelect: \"none\",\n\n\t\t/**\n\t\t * @private\n\t\t * Disable the Windows Phone grippers when pressing an element.\n\t\t * @type {String}\n\t\t * @default 'none'\n\t\t */\n\t\ttouchSelect: \"none\",\n\n\t\t/**\n\t\t * @private\n\t\t * Disables the default callout shown when you touch and hold a touch target.\n\t\t * On iOS, when you touch and hold a touch target such as a link, Safari displays\n\t\t * a callout containing information about the link. This property allows you to disable that callout.\n\t\t * @type {String}\n\t\t * @default 'none'\n\t\t */\n\t\ttouchCallout: \"none\",\n\n\t\t/**\n\t\t * @private\n\t\t * Specifies whether zooming is enabled. Used by IE10>\n\t\t * @type {String}\n\t\t * @default 'none'\n\t\t */\n\t\tcontentZooming: \"none\",\n\n\t\t/**\n\t\t * @private\n\t\t * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n\t\t * @type {String}\n\t\t * @default 'none'\n\t\t */\n\t\tuserDrag: \"none\",\n\n\t\t/**\n\t\t * @private\n\t\t * Overrides the highlight color shown when the user taps a link or a JavaScript\n\t\t * clickable element in iOS. This property obeys the alpha value, if specified.\n\t\t * @type {String}\n\t\t * @default 'rgba(0,0,0,0)'\n\t\t */\n\t\ttapHighlightColor: \"rgba(0,0,0,0)\",\n\t},\n};\n\n/**\n * @private\n * Default recognizer setup when calling `Hammer()`\n * When creating a new Manager these will be skipped.\n * This is separated with other defaults because of tree-shaking.\n * @type {Array}\n */\nexport const preset = [\n  [RotateRecognizer, { enable: false }],\n  [PinchRecognizer, { enable: false }, ['rotate']],\n  [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],\n  [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],\n  [TapRecognizer],\n  [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],\n  [PressRecognizer]\n];\n","import assign from \"./utils/assign\";\nimport TouchAction from \"./touchactionjs/touchaction-constructor\";\nimport createInputInstance from \"./inputjs/create-input-instance\";\nimport each from \"./utils/each\";\nimport inArray from \"./utils/in-array\";\nimport invokeArrayArg from \"./utils/invoke-array-arg\";\nimport splitStr from \"./utils/split-str\";\nimport prefixed from \"./utils/prefixed\";\nimport Recognizer from \"./recognizerjs/recognizer-constructor\";\nimport {\n  STATE_BEGAN,\n  STATE_ENDED,\n  STATE_CHANGED,\n  STATE_RECOGNIZED,\n} from \"./recognizerjs/recognizer-consts\";\nimport defaults from \"./defaults\";\n\nconst STOP = 1;\nconst FORCED_STOP = 2;\n\n\n/**\n * @private\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\nfunction toggleCssProps(manager, add) {\n  const { element } = manager;\n\n  if (!element.style) {\n    return;\n  }\n  let prop;\n\n  each(manager.options.cssProps, (value, name) => {\n    prop = prefixed(element.style, name);\n    if (add) {\n      manager.oldCssProps[prop] = element.style[prop];\n      element.style[prop] = value;\n    } else {\n      element.style[prop] = manager.oldCssProps[prop] || \"\";\n    }\n  });\n  if (!add) {\n    manager.oldCssProps = {};\n  }\n}\n\n/**\n * @private\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\nfunction triggerDomEvent(event, data) {\n  const gestureEvent = document.createEvent(\"Event\");\n\n  gestureEvent.initEvent(event, true, true);\n  gestureEvent.gesture = data;\n  data.target.dispatchEvent(gestureEvent);\n}\n\n\n/**\n* @private\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nexport default class Manager {\n  constructor(element, options) {\n    this.options = assign({}, defaults, options || {});\n\n    this.options.inputTarget = this.options.inputTarget || element;\n\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n\n    toggleCssProps(this, true);\n\n    each(this.options.recognizers, item => {\n      const recognizer = this.add(new (item[0])(item[1]));\n\n      item[2] && recognizer.recognizeWith(item[2]);\n      item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n  }\n\n\t/**\n\t * @private\n\t * set options\n\t * @param {Object} options\n\t * @returns {Manager}\n\t */\n  set(options) {\n    assign(this.options, options);\n\n    // Options that need a little more setup\n    if (options.touchAction) {\n      this.touchAction.update();\n    }\n    if (options.inputTarget) {\n      // Clean up existing event listeners and reinitialize\n      this.input.destroy();\n      this.input.target = options.inputTarget;\n      this.input.init();\n    }\n    return this;\n  }\n\n\t/**\n\t * @private\n\t * stop recognizing for this session.\n\t * This session will be discarded, when a new [input]start event is fired.\n\t * When forced, the recognizer cycle is stopped immediately.\n\t * @param {Boolean} [force]\n\t */\n  stop(force) {\n    this.session.stopped = force ? FORCED_STOP : STOP;\n  }\n\n\t/**\n\t * @private\n\t * run the recognizers!\n\t * called by the inputHandler function on every movement of the pointers (touches)\n\t * it walks through all the recognizers and tries to detect the gesture that is being made\n\t * @param {Object} inputData\n\t */\n  recognize(inputData) {\n    const { session } = this;\n\n    if (session.stopped) {\n      return;\n    }\n\n    // run the touch-action polyfill\n    this.touchAction.preventDefaults(inputData);\n\n    let recognizer;\n    const { recognizers } = this;\n\n    // this holds the recognizer that is being recognized.\n    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n    // if no recognizer is detecting a thing, it is set to `null`\n    let { curRecognizer } = session;\n\n    // reset when the last recognizer is recognized\n    // or when we're in a new session\n    if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\n      session.curRecognizer = null;\n      curRecognizer = null;\n    }\n\n    let i = 0;\n\n    while (i < recognizers.length) {\n      recognizer = recognizers[i];\n\n      // find out if we are allowed try to recognize the input for this one.\n      // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n      // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n      //      that is being recognized.\n      // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n      //      this can be setup with the `recognizeWith()` method on the recognizer.\n      if (session.stopped !== FORCED_STOP && (// 1\n        !curRecognizer || recognizer === curRecognizer || // 2\n        recognizer.canRecognizeWith(curRecognizer))) { // 3\n        recognizer.recognize(inputData);\n      } else {\n        recognizer.reset();\n      }\n\n      // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n      // current active recognizer. but only if we don't already have an active recognizer\n      if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n        session.curRecognizer = recognizer;\n        curRecognizer = recognizer;\n      }\n      i++;\n    }\n  }\n\n\t/**\n\t * @private\n\t * get a recognizer by its event name.\n\t * @param {Recognizer|String} recognizer\n\t * @returns {Recognizer|Null}\n\t */\n  get(recognizer) {\n    if (recognizer instanceof Recognizer) {\n      return recognizer;\n    }\n\n    const { recognizers } = this;\n\n    for (let i = 0; i < recognizers.length; i++) {\n      if (recognizers[i].options.event === recognizer) {\n        return recognizers[i];\n      }\n    }\n    return null;\n  }\n\n\t/**\n\t * @private add a recognizer to the manager\n\t * existing recognizers with the same event name will be removed\n\t * @param {Recognizer} recognizer\n\t * @returns {Recognizer|Manager}\n\t */\n  add(recognizer) {\n    if (invokeArrayArg(recognizer, \"add\", this)) {\n      return this;\n    }\n\n    // remove existing\n    const existing = this.get(recognizer.options.event);\n\n    if (existing) {\n      this.remove(existing);\n    }\n\n    this.recognizers.push(recognizer);\n    recognizer.manager = this;\n\n    this.touchAction.update();\n    return recognizer;\n  }\n\n\t/**\n\t * @private\n\t * remove a recognizer by name or instance\n\t * @param {Recognizer|String} recognizer\n\t * @returns {Manager}\n\t */\n  remove(recognizer) {\n    if (invokeArrayArg(recognizer, \"remove\", this)) {\n      return this;\n    }\n\n    const targetRecognizer = this.get(recognizer);\n\n    // let's make sure this recognizer exists\n    if (recognizer) {\n      const { recognizers } = this;\n      const index = inArray(recognizers, targetRecognizer);\n\n      if (index !== -1) {\n        recognizers.splice(index, 1);\n        this.touchAction.update();\n      }\n    }\n\n    return this;\n  }\n\n\t/**\n\t * @private\n\t * bind event\n\t * @param {String} events\n\t * @param {Function} handler\n\t * @returns {EventEmitter} this\n\t */\n  on(events, handler) {\n    if (events === undefined || handler === undefined) {\n      return this;\n    }\n\n    const { handlers } = this;\n\n    each(splitStr(events), event => {\n      handlers[event] = handlers[event] || [];\n      handlers[event].push(handler);\n    });\n    return this;\n  }\n\n\t/**\n\t * @private unbind event, leave emit blank to remove all handlers\n\t * @param {String} events\n\t * @param {Function} [handler]\n\t * @returns {EventEmitter} this\n\t */\n  off(events, handler) {\n    if (events === undefined) {\n      return this;\n    }\n\n    const { handlers } = this;\n\n    each(splitStr(events), event => {\n      if (!handler) {\n        delete handlers[event];\n      } else {\n        handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n      }\n    });\n    return this;\n  }\n\n\t/**\n\t * @private emit event to the listeners\n\t * @param {String} event\n\t * @param {Object} data\n\t */\n  emit(event, data) {\n    // we also want to trigger dom events\n    if (this.options.domEvents) {\n      triggerDomEvent(event, data);\n    }\n\n    // no handlers, so skip it all\n    const handlers = this.handlers[event] && this.handlers[event].slice();\n\n    if (!handlers || !handlers.length) {\n      return;\n    }\n\n    data.type = event;\n    data.preventDefault = function () {\n      data.srcEvent.preventDefault();\n    };\n\n    let i = 0;\n\n    while (i < handlers.length) {\n      handlers[i](data);\n      i++;\n    }\n  }\n\n\t/**\n\t * @private\n\t * destroy the manager and unbinds all events\n\t * it doesn't unbind dom events, that is the user own responsibility\n\t */\n  destroy() {\n    this.element && toggleCssProps(this, false);\n\n    this.handlers = {};\n    this.session = {};\n    this.input.destroy();\n    this.element = null;\n  }\n}\n","import {\n    INPUT_START,\n    INPUT_MOVE,\n    INPUT_END,\n    INPUT_CANCEL,\n    INPUT_TYPE_TOUCH\n} from '../inputjs/input-consts';\nimport Input from '../inputjs/input-constructor';\nimport toArray from '../utils/to-array';\nimport uniqueArray from '../utils/unique-array';\n\nconst SINGLE_TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\n\nconst SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nconst SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * @private\n * Touch events input\n * @constructor\n * @extends Input\n */\nexport default class SingleTouchInput extends Input {\n  constructor() {\n    var proto = SingleTouchInput.prototype;\n    proto.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    proto.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n\n    super(...arguments);\n    this.started = false;\n  }\n\n  handler(ev) {\n    let type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n    // should we handle the touch events?\n    if (type === INPUT_START) {\n      this.started = true;\n    }\n\n    if (!this.started) {\n      return;\n    }\n\n    let touches = normalizeSingleTouches.call(this, ev, type);\n\n    // when done, reset the started state\n    if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n      this.started = false;\n    }\n\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  }\n}\n\n/**\n * @private\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction normalizeSingleTouches(ev, type) {\n  let all = toArray(ev.touches);\n  let changed = toArray(ev.changedTouches);\n\n  if (type & (INPUT_END | INPUT_CANCEL)) {\n    all = uniqueArray(all.concat(changed), 'identifier', true);\n  }\n\n  return [all, changed];\n}\n","/**\n * @private\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nexport default function deprecate(method, name, message) {\n  let deprecationMessage = `DEPRECATED METHOD: ${name}\\n${message} AT \\n`;\n  return function() {\n    let e = new Error('get-stack-trace');\n    let stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '')\n        .replace(/^\\s+at\\s+/gm, '')\n        .replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n\n    let log = window.console && (window.console.warn || window.console.log);\n    if (log) {\n      log.call(window.console, deprecationMessage, stack);\n    }\n    return method.apply(this, arguments);\n  };\n}\n","import deprecate from './deprecate';\n/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\nconst extend = deprecate((dest, src, merge) => {\n  let keys = Object.keys(src);\n  let i = 0;\n  while (i < keys.length) {\n    if (!merge || (merge && dest[keys[i]] === undefined)) {\n      dest[keys[i]] = src[keys[i]];\n    }\n    i++;\n  }\n  return dest;\n}, 'extend', 'Use `assign`.');\n\nexport default extend;\n","import deprecate from './deprecate';\nimport extend from './extend';\n/**\n * @private\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\nconst merge = deprecate((dest, src) => {\n  return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n\nexport default merge;\n","import assign from './assign';\n/**\n * @private\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\nexport default function inherit(child, base, properties) {\n  let baseP = base.prototype;\n  let childP;\n\n  childP = child.prototype = Object.create(baseP);\n  childP.constructor = child;\n  childP._super = baseP;\n\n  if (properties) {\n    assign(childP, properties);\n  }\n}\n","/**\n * @private\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nexport default function bindFn(fn, context) {\n  return function boundFn() {\n    return fn.apply(context, arguments);\n  };\n}\n","import Manager from \"./manager\";\nimport defaults, { preset } from \"./defaults\";\nimport assign from './utils/assign';\nimport {\n  INPUT_START,\n  INPUT_MOVE,\n  INPUT_END,\n  INPUT_CANCEL,\n  DIRECTION_NONE,\n  DIRECTION_LEFT,\n  DIRECTION_RIGHT,\n  DIRECTION_UP,\n  DIRECTION_DOWN,\n  DIRECTION_HORIZONTAL,\n  DIRECTION_VERTICAL,\n  DIRECTION_ALL,\n} from \"./inputjs/input-consts\";\nimport {\n  STATE_POSSIBLE,\n  STATE_BEGAN,\n  STATE_CHANGED,\n  STATE_ENDED,\n  STATE_RECOGNIZED,\n  STATE_CANCELLED,\n  STATE_FAILED,\n} from \"./recognizerjs/recognizer-consts\";\n\nimport Input from \"./inputjs/input-constructor\";\nimport TouchAction from \"./touchactionjs/touchaction-constructor\";\nimport TouchInput from \"./input/touch\";\nimport MouseInput from \"./input/mouse\";\nimport PointerEventInput from \"./input/pointerevent\";\nimport SingleTouchInput from \"./input/singletouch\";\nimport TouchMouseInput from \"./input/touchmouse\";\n\nimport Recognizer from \"./recognizerjs/recognizer-constructor\";\nimport AttrRecognizer from \"./recognizers/attribute\";\nimport TapRecognizer from \"./recognizers/tap\";\nimport PanRecognizer from \"./recognizers/pan\";\nimport SwipeRecognizer from \"./recognizers/swipe\";\nimport PinchRecognizer from \"./recognizers/pinch\";\nimport RotateRecognizer from \"./recognizers/rotate\";\nimport PressRecognizer from \"./recognizers/press\";\n\nimport addEventListeners from \"./utils/add-event-listeners\";\nimport removeEventListeners from \"./utils/remove-event-listeners\";\nimport each from \"./utils/each\";\nimport merge from \"./utils/merge\";\nimport extend from \"./utils/extend\";\nimport inherit from \"./utils/inherit\";\nimport bindFn from \"./utils/bind-fn\";\nimport prefixed from \"./utils/prefixed\";\nimport toArray from \"./utils/to-array\";\nimport uniqueArray from \"./utils/unique-array\";\nimport splitStr from \"./utils/split-str\";\nimport inArray from \"./utils/in-array\";\nimport boolOrFn from \"./utils/bool-or-fn\";\nimport hasParent from \"./utils/has-parent\";\n/**\n * @private\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nexport default class Hammer {\n\t/**\n   * @private\n   * @const {string}\n   */\n\tstatic VERSION = \"#__VERSION__#\";\n\tstatic DIRECTION_ALL = DIRECTION_ALL;\n\tstatic DIRECTION_DOWN = DIRECTION_DOWN;\n\tstatic DIRECTION_LEFT = DIRECTION_LEFT;\n\tstatic DIRECTION_RIGHT = DIRECTION_RIGHT;\n\tstatic DIRECTION_UP = DIRECTION_UP;\n\tstatic DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;\n\tstatic DIRECTION_VERTICAL = DIRECTION_VERTICAL;\n\tstatic DIRECTION_NONE = DIRECTION_NONE;\n\tstatic DIRECTION_DOWN = DIRECTION_DOWN;\n\tstatic INPUT_START = INPUT_START;\n\tstatic INPUT_MOVE = INPUT_MOVE;\n  static INPUT_END = INPUT_END;\n\tstatic INPUT_CANCEL = INPUT_CANCEL;\n\tstatic STATE_POSSIBLE = STATE_POSSIBLE;\n\tstatic STATE_BEGAN = STATE_BEGAN;\n\tstatic STATE_CHANGED = STATE_CHANGED;\n\tstatic STATE_ENDED = STATE_ENDED;\n\tstatic STATE_RECOGNIZED = STATE_RECOGNIZED;\n\tstatic STATE_CANCELLED = STATE_CANCELLED;\n\tstatic STATE_FAILED = STATE_FAILED;\n\tstatic Manager = Manager;\n\tstatic Input = Input;\n\tstatic TouchAction = TouchAction;\n\tstatic TouchInput = TouchInput;\n\tstatic MouseInput = MouseInput;\n\tstatic PointerEventInput = PointerEventInput;\n\tstatic TouchMouseInput = TouchMouseInput;\n\tstatic SingleTouchInput = SingleTouchInput;\n\tstatic Recognizer = Recognizer;\n\tstatic AttrRecognizer = AttrRecognizer;\n\tstatic Tap = TapRecognizer;\n\tstatic Pan = PanRecognizer;\n\tstatic Swipe = SwipeRecognizer;\n\tstatic Pinch = PinchRecognizer;\n\tstatic Rotate = RotateRecognizer;\n\tstatic Press = PressRecognizer;\n\tstatic on = addEventListeners;\n\tstatic off = removeEventListeners;\n\tstatic each = each;\n\tstatic merge = merge;\n\tstatic extend = extend;\n\tstatic bindFn = bindFn;\n\tstatic assign = assign;\n\tstatic inherit = inherit;\n\tstatic bindFn = bindFn;\n\tstatic prefixed = prefixed;\n\tstatic toArray = toArray;\n\tstatic inArray = inArray;\n\tstatic uniqueArray = uniqueArray;\n\tstatic splitStr = splitStr;\n\tstatic boolOrFn = boolOrFn;\n\tstatic hasParent = hasParent;\n\tstatic addEventListeners = addEventListeners;\n\tstatic removeEventListeners = removeEventListeners;\n\tstatic defaults = assign({}, defaults, { preset });\n\tconstructor(element, options = {}) {\n\t\treturn new Manager(element, {\n\t\t\trecognizers: [\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n        ...preset\n\t\t\t],\n\t\t\t...options,\n\t\t});\n\t}\n}\n","\nimport Hammer from \"./hammer\";\nimport assign from \"./utils/assign\";\n\nimport {\n  INPUT_START,\n  INPUT_MOVE,\n  INPUT_END,\n  INPUT_CANCEL,\n  DIRECTION_NONE,\n  DIRECTION_LEFT,\n  DIRECTION_RIGHT,\n  DIRECTION_UP,\n  DIRECTION_DOWN,\n  DIRECTION_HORIZONTAL,\n  DIRECTION_VERTICAL,\n  DIRECTION_ALL,\n} from \"./inputjs/input-consts\";\nimport {\n  STATE_POSSIBLE,\n  STATE_BEGAN,\n  STATE_CHANGED,\n  STATE_ENDED,\n  STATE_RECOGNIZED,\n  STATE_CANCELLED,\n  STATE_FAILED,\n} from \"./recognizerjs/recognizer-consts\";\n\nimport Manager from \"./manager\";\nimport Input from \"./inputjs/input-constructor\";\nimport TouchAction from \"./touchactionjs/touchaction-constructor\";\nimport TouchInput from \"./input/touch\";\nimport MouseInput from \"./input/mouse\";\nimport PointerEventInput from \"./input/pointerevent\";\nimport SingleTouchInput from \"./input/singletouch\";\nimport TouchMouseInput from \"./input/touchmouse\";\n\nimport Recognizer from \"./recognizerjs/recognizer-constructor\";\nimport AttrRecognizer from \"./recognizers/attribute\";\nimport TapRecognizer from \"./recognizers/tap\";\nimport PanRecognizer from \"./recognizers/pan\";\nimport SwipeRecognizer from \"./recognizers/swipe\";\nimport PinchRecognizer from \"./recognizers/pinch\";\nimport RotateRecognizer from \"./recognizers/rotate\";\nimport PressRecognizer from \"./recognizers/press\";\n\nimport addEventListeners from \"./utils/add-event-listeners\";\nimport removeEventListeners from \"./utils/remove-event-listeners\";\nimport each from \"./utils/each\";\nimport merge from \"./utils/merge\";\nimport extend from \"./utils/extend\";\nimport inherit from \"./utils/inherit\";\nimport bindFn from \"./utils/bind-fn\";\nimport prefixed from \"./utils/prefixed\";\nimport toArray from \"./utils/to-array\";\nimport uniqueArray from \"./utils/unique-array\";\nimport splitStr from \"./utils/split-str\";\nimport inArray from \"./utils/in-array\";\nimport boolOrFn from \"./utils/bool-or-fn\";\nimport hasParent from \"./utils/has-parent\";\n\n// this prevents errors when Hammer is loaded in the presence of an AMD\n//  style loader but by script tag, not by the loader.\n\nconst defaults = Hammer.defaults;\n\nexport {\n  Hammer as default,\n  INPUT_START,\n  INPUT_MOVE,\n  INPUT_END,\n  INPUT_CANCEL,\n  STATE_POSSIBLE,\n  STATE_BEGAN,\n  STATE_CHANGED,\n  STATE_ENDED,\n  STATE_RECOGNIZED,\n  STATE_CANCELLED,\n  STATE_FAILED,\n\n  DIRECTION_NONE,\n  DIRECTION_LEFT,\n  DIRECTION_RIGHT,\n  DIRECTION_UP,\n  DIRECTION_DOWN,\n  DIRECTION_HORIZONTAL,\n  DIRECTION_VERTICAL,\n  DIRECTION_ALL,\n  Manager,\n  Input,\n  TouchAction,\n  TouchInput,\n  MouseInput,\n  PointerEventInput,\n  TouchMouseInput,\n  SingleTouchInput,\n  Recognizer,\n  AttrRecognizer,\n  TapRecognizer as Tap,\n  PanRecognizer as Pan,\n  SwipeRecognizer as Swipe,\n  PinchRecognizer as Pinch,\n  RotateRecognizer as Rotate,\n  PressRecognizer as Press,\n  addEventListeners as on,\n  removeEventListeners as off,\n  each,\n  merge,\n  extend,\n  assign,\n  inherit,\n  bindFn,\n  prefixed,\n  toArray,\n  inArray,\n  uniqueArray,\n  splitStr,\n  boolOrFn,\n  hasParent,\n  addEventListeners,\n  removeEventListeners,\n  defaults,\n};\n"]},"metadata":{},"sourceType":"module"}