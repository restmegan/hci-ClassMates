{"ast":null,"code":"import { createContext, forwardRef, useState, useImperativeHandle, createElement, useLayoutEffect, useEffect, useCallback, useContext } from 'react';\nimport { tap, init, curry1to0, subscribe, reset, always, publish, eventHandler, curry2to1, getValue } from '@virtuoso.dev/urx';\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  it = o[Symbol.iterator]();\n  return it.next.bind(it);\n}\n/** @internal */\n\n\nfunction omit(keys, obj) {\n  var result = {};\n  var index = {};\n  var idx = 0;\n  var len = keys.length;\n\n  while (idx < len) {\n    index[keys[idx]] = 1;\n    idx += 1;\n  }\n\n  for (var prop in obj) {\n    if (!index.hasOwnProperty(prop)) {\n      result[prop] = obj[prop];\n    }\n  }\n\n  return result;\n}\n\nvar useIsomorphicLayoutEffect = typeof document !== 'undefined' ? useLayoutEffect : useEffect;\n/**\r\n * Converts a system spec to React component by mapping the system streams to component properties, events and methods. Returns hooks for querying and modifying\r\n * the system streams from the component's child components.\r\n * @param systemSpec The return value from a [[system]] call.\r\n * @param map The streams to props / events / methods mapping Check [[SystemPropsMap]] for more details.\r\n * @param Root The optional React component to render. By default, the resulting component renders nothing, acting as a logical wrapper for its children.\r\n * @returns an object containing the following:\r\n *  - `Component`: the React component.\r\n *  - `useEmitterValue`: a hook that lets child components use values emitted from the specified output stream.\r\n *  - `useEmitter`: a hook that calls the provided callback whenever the specified stream emits a value.\r\n *  - `usePublisher`: a hook which lets child components publish values to the specified stream.\r\n *  <hr />\r\n */\n\nfunction systemToComponent(systemSpec, map, Root) {\n  var requiredPropNames = Object.keys(map.required || {});\n  var optionalPropNames = Object.keys(map.optional || {});\n  var methodNames = Object.keys(map.methods || {});\n  var eventNames = Object.keys(map.events || {});\n  var Context = createContext({});\n\n  function applyPropsToSystem(system, props) {\n    if (system['propsReady']) {\n      publish(system['propsReady'], false);\n    }\n\n    for (var _iterator = _createForOfIteratorHelperLoose(requiredPropNames), _step; !(_step = _iterator()).done;) {\n      var requiredPropName = _step.value;\n      var stream = system[map.required[requiredPropName]];\n      publish(stream, props[requiredPropName]);\n    }\n\n    for (var _iterator2 = _createForOfIteratorHelperLoose(optionalPropNames), _step2; !(_step2 = _iterator2()).done;) {\n      var optionalPropName = _step2.value;\n\n      if (optionalPropName in props) {\n        var _stream = system[map.optional[optionalPropName]];\n        publish(_stream, props[optionalPropName]);\n      }\n    }\n\n    if (system['propsReady']) {\n      publish(system['propsReady'], true);\n    }\n  }\n\n  function buildMethods(system) {\n    return methodNames.reduce(function (acc, methodName) {\n      acc[methodName] = function (value) {\n        var stream = system[map.methods[methodName]];\n        publish(stream, value);\n      };\n\n      return acc;\n    }, {});\n  }\n\n  function buildEventHandlers(system) {\n    return eventNames.reduce(function (handlers, eventName) {\n      handlers[eventName] = eventHandler(system[map.events[eventName]]);\n      return handlers;\n    }, {});\n  }\n  /**\r\n   * A React component generated from an urx system\r\n   */\n\n\n  var Component = forwardRef(function (propsWithChildren, ref) {\n    var children = propsWithChildren.children,\n        props = _objectWithoutPropertiesLoose(propsWithChildren, [\"children\"]);\n\n    var _useState = useState(function () {\n      return tap(init(systemSpec), function (system) {\n        return applyPropsToSystem(system, props);\n      });\n    }),\n        system = _useState[0];\n\n    var _useState2 = useState(curry1to0(buildEventHandlers, system)),\n        handlers = _useState2[0];\n\n    useIsomorphicLayoutEffect(function () {\n      for (var _iterator3 = _createForOfIteratorHelperLoose(eventNames), _step3; !(_step3 = _iterator3()).done;) {\n        var eventName = _step3.value;\n\n        if (eventName in props) {\n          subscribe(handlers[eventName], props[eventName]);\n        }\n      }\n\n      return function () {\n        Object.values(handlers).map(reset);\n      };\n    }, [props, handlers, system]);\n    useIsomorphicLayoutEffect(function () {\n      applyPropsToSystem(system, props);\n    });\n    useImperativeHandle(ref, always(buildMethods(system)));\n    return createElement(Context.Provider, {\n      value: system\n    }, Root ? createElement(Root, omit([].concat(requiredPropNames, optionalPropNames, eventNames), props), children) : children);\n  });\n\n  var usePublisher = function usePublisher(key) {\n    return useCallback(curry2to1(publish, useContext(Context)[key]), [key]);\n  };\n  /**\r\n   * Returns the value emitted from the stream.\r\n   */\n\n\n  var useEmitterValue = function useEmitterValue(key) {\n    var context = useContext(Context);\n    var source = context[key];\n\n    var _useState3 = useState(curry1to0(getValue, source)),\n        value = _useState3[0],\n        setValue = _useState3[1];\n\n    useIsomorphicLayoutEffect(function () {\n      return subscribe(source, function (next) {\n        if (next !== value) {\n          setValue(always(next));\n        }\n      });\n    }, [source, value]);\n    return value;\n  };\n\n  var useEmitter = function useEmitter(key, callback) {\n    var context = useContext(Context);\n    var source = context[key];\n    useIsomorphicLayoutEffect(function () {\n      return subscribe(source, callback);\n    }, [callback, source]);\n  };\n\n  return {\n    Component: Component,\n    usePublisher: usePublisher,\n    useEmitterValue: useEmitterValue,\n    useEmitter: useEmitter\n  };\n}\n\nexport { systemToComponent };","map":{"version":3,"sources":["../src/index.ts"],"names":["result","index","idx","len","keys","obj","useIsomorphicLayoutEffect","systemToComponent","systemSpec","map","Root","requiredPropNames","Object","optionalPropNames","methodNames","eventNames","Context","createContext","system","publish","requiredPropName","stream","props","optionalPropName","acc","handlers","eventHandler","Component","forwardRef","children","propsWithChildren","useState","tap","init","applyPropsToSystem","curry1to0","eventName","subscribe","useImperativeHandle","always","buildMethods","createElement","value","omit","usePublisher","useCallback","curry2to1","React","useEmitterValue","context","useContext","source","setValue","next","useEmitter"],"mappings":"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","sourcesContent":["/**\n * `@virtuoso.dev/react-urx` exports the [[systemToComponent]] function.\n * It wraps urx systems in to UI **logic provider components**,\n * mapping the system input and output streams to the component input / output points.\n *\n * ### Simple System wrapped as React Component\n *\n * ```tsx\n * const sys = system(() => {\n *   const foo = statefulStream(42)\n *   return { foo }\n * })\n *\n * const { Component: MyComponent, useEmitterValue } = systemToComponent(sys, {\n *   required: { fooProp: 'foo' },\n * })\n *\n * const Child = () => {\n *   const foo = useEmitterValue('foo')\n *   return <div>{foo}</div>\n * }\n *\n * const App = () => {\n *   return <Comp fooProp={42}><Child /><Comp>\n * }\n * ```\n *\n * @packageDocumentation\n */\nimport * as React from 'react'\nimport {\n  ComponentType,\n  createContext,\n  createElement,\n  forwardRef,\n  ForwardRefExoticComponent,\n  ReactNode,\n  RefAttributes,\n  useContext,\n  useImperativeHandle,\n  useState,\n  useCallback,\n} from 'react'\nimport {\n  AnySystemSpec,\n  reset,\n  curry1to0,\n  curry2to1,\n  Emitter,\n  SR,\n  eventHandler,\n  getValue,\n  publish,\n  Publisher,\n  init,\n  StatefulStream,\n  Stream,\n  subscribe,\n  always,\n  tap,\n} from '@virtuoso.dev/urx'\n\n/** @internal */\ninterface Dict<T> {\n  [key: string]: T\n}\n\n/** @internal */\nfunction omit<O extends Dict<any>, K extends readonly string[]>(keys: K, obj: O): Omit<O, K[number]> {\n  var result = {} as Dict<any>\n  var index = {} as Dict<1>\n  var idx = 0\n  var len = keys.length\n\n  while (idx < len) {\n    index[keys[idx]] = 1\n    idx += 1\n  }\n\n  for (var prop in obj) {\n    if (!index.hasOwnProperty(prop)) {\n      result[prop] = obj[prop]\n    }\n  }\n\n  return result as any\n}\n\nconst useIsomorphicLayoutEffect = typeof document !== 'undefined' ? React.useLayoutEffect : React.useEffect\n\n/** @internal */\nexport type Observable<T> = Emitter<T> | Publisher<T>\n\n/**\n * Describes the mapping between the system streams and the component properties.\n * Each property uses the keys as the names of the properties and the values as the corresponding stream names.\n * @typeParam SS the type of the system.\n */\nexport interface SystemPropsMap<SS extends AnySystemSpec, K = keyof SR<SS>, D = { [key: string]: K }> {\n  /**\n   * Specifies the required component properties.\n   */\n  required?: D\n  /**\n   * Specifies the optional component properties.\n   */\n  optional?: D\n  /**\n   * Specifies the component methods, if any. Streams are converted to methods with a single argument.\n   * When invoked, the method publishes the value of the argument to the specified stream.\n   */\n  methods?: D\n  /**\n   * Specifies the component \"event\" properties, if any.\n   * Event properties accept callback functions which get executed when the stream emits a new value.\n   */\n  events?: D\n}\n\n/** @internal */\nexport type PropsFromPropMap<E extends AnySystemSpec, M extends SystemPropsMap<E>> = {\n  [K in Extract<keyof M['required'], string>]: M['required'][K] extends string\n    ? SR<E>[M['required'][K]] extends Observable<infer R>\n      ? R\n      : never\n    : never\n} &\n  {\n    [K in Extract<keyof M['optional'], string>]?: M['optional'][K] extends string\n      ? SR<E>[M['optional'][K]] extends Observable<infer R>\n        ? R\n        : never\n      : never\n  } &\n  {\n    [K in Extract<keyof M['events'], string>]?: M['events'][K] extends string\n      ? SR<E>[M['events'][K]] extends Observable<infer R>\n        ? (value: R) => void\n        : never\n      : never\n  }\n\n/** @internal */\nexport type MethodsFromPropMap<E extends AnySystemSpec, M extends SystemPropsMap<E>> = {\n  [K in Extract<keyof M['methods'], string>]: M['methods'][K] extends string\n    ? SR<E>[M['methods'][K]] extends Observable<infer R>\n      ? (value: R) => void\n      : never\n    : never\n}\n\n/**\n * Used to correctly specify type refs for system components\n *\n * ```tsx\n * const s = system(() => { return { a: statefulStream(0) } })\n * const { Component } = systemToComponent(s)\n *\n * const App = () => {\n *  const ref = useRef<RefHandle<typeof Component>>()\n *  return <Component ref={ref} />\n * }\n * ```\n *\n * @typeParam T the type of the component\n */\nexport type RefHandle<T> = T extends ForwardRefExoticComponent<RefAttributes<infer Handle>> ? Handle : never\n\n/**\n * Converts a system spec to React component by mapping the system streams to component properties, events and methods. Returns hooks for querying and modifying\n * the system streams from the component's child components.\n * @param systemSpec The return value from a [[system]] call.\n * @param map The streams to props / events / methods mapping Check [[SystemPropsMap]] for more details.\n * @param Root The optional React component to render. By default, the resulting component renders nothing, acting as a logical wrapper for its children.\n * @returns an object containing the following:\n *  - `Component`: the React component.\n *  - `useEmitterValue`: a hook that lets child components use values emitted from the specified output stream.\n *  - `useEmitter`: a hook that calls the provided callback whenever the specified stream emits a value.\n *  - `usePublisher`: a hook which lets child components publish values to the specified stream.\n *  <hr />\n */\nexport function systemToComponent<SS extends AnySystemSpec, M extends SystemPropsMap<SS>, S extends SR<SS>, R>(\n  systemSpec: SS,\n  map: M,\n  Root?: R\n) {\n  const requiredPropNames = Object.keys(map.required || {})\n  const optionalPropNames = Object.keys(map.optional || {})\n  const methodNames = Object.keys(map.methods || {})\n  const eventNames = Object.keys(map.events || {})\n  const Context = createContext<SR<SS>>(({} as unknown) as any)\n\n  type RootCompProps = R extends ComponentType<infer RP> ? RP : { children?: ReactNode }\n\n  type CompProps = PropsFromPropMap<SS, M> & RootCompProps\n\n  type CompMethods = MethodsFromPropMap<SS, M>\n\n  function applyPropsToSystem(system: ReturnType<SS['constructor']>, props: any) {\n    if (system['propsReady']) {\n      publish(system['propsReady'], false)\n    }\n\n    for (const requiredPropName of requiredPropNames) {\n      const stream = system[map.required![requiredPropName]]\n      publish(stream, (props as any)[requiredPropName])\n    }\n\n    for (const optionalPropName of optionalPropNames) {\n      if (optionalPropName in props) {\n        const stream = system[map.optional![optionalPropName]]\n        publish(stream, (props as any)[optionalPropName])\n      }\n    }\n\n    if (system['propsReady']) {\n      publish(system['propsReady'], true)\n    }\n  }\n\n  function buildMethods(system: ReturnType<SS['constructor']>) {\n    return methodNames.reduce((acc, methodName) => {\n      ;(acc as any)[methodName] = (value: any) => {\n        const stream = system[map.methods![methodName]]\n        publish(stream, value)\n      }\n      return acc\n    }, {} as CompMethods)\n  }\n\n  function buildEventHandlers(system: ReturnType<SS['constructor']>) {\n    return eventNames.reduce((handlers, eventName) => {\n      handlers[eventName] = eventHandler(system[map.events![eventName]])\n      return handlers\n    }, {} as { [key: string]: Emitter<any> })\n  }\n\n  /**\n   * A React component generated from an urx system\n   */\n  const Component = forwardRef<CompMethods, CompProps>((propsWithChildren, ref) => {\n    const { children, ...props } = propsWithChildren as any\n\n    const [system] = useState(() => {\n      return tap(init(systemSpec), system => applyPropsToSystem(system, props))\n    })\n\n    const [handlers] = useState(curry1to0(buildEventHandlers, system))\n\n    useIsomorphicLayoutEffect(() => {\n      for (const eventName of eventNames) {\n        if (eventName in props) {\n          subscribe(handlers[eventName], props[eventName])\n        }\n      }\n      return () => {\n        Object.values(handlers).map(reset)\n      }\n    }, [props, handlers, system])\n\n    useIsomorphicLayoutEffect(() => {\n      applyPropsToSystem(system, props)\n    })\n\n    useImperativeHandle(ref, always(buildMethods(system)))\n\n    return createElement(\n      Context.Provider,\n      { value: system },\n      Root\n        ? createElement(\n            (Root as unknown) as ComponentType,\n            omit([...requiredPropNames, ...optionalPropNames, ...eventNames], props),\n            children\n          )\n        : children\n    )\n  })\n\n  const usePublisher = <K extends keyof S>(key: K) => {\n    return useCallback(curry2to1(publish, React.useContext(Context)[key]), [key]) as (\n      value: S[K] extends Stream<infer R> ? R : never\n    ) => void\n  }\n\n  /**\n   * Returns the value emitted from the stream.\n   */\n  const useEmitterValue = <K extends keyof S, V = S[K] extends StatefulStream<infer R> ? R : never>(key: K) => {\n    const context = useContext(Context)\n    const source: StatefulStream<V> = context[key]\n\n    const [value, setValue] = useState(curry1to0(getValue, source))\n\n    useIsomorphicLayoutEffect(\n      () =>\n        subscribe(source, (next: V) => {\n          if (next !== value) {\n            setValue(always(next))\n          }\n        }),\n      [source, value]\n    )\n\n    return value\n  }\n\n  const useEmitter = <K extends keyof S, V = S[K] extends Stream<infer R> ? R : never>(key: K, callback: (value: V) => void) => {\n    const context = useContext(Context)\n    const source: Stream<V> = context[key]\n    useIsomorphicLayoutEffect(() => subscribe(source, callback), [callback, source])\n  }\n\n  return {\n    Component,\n    usePublisher,\n    useEmitterValue,\n    useEmitter,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}