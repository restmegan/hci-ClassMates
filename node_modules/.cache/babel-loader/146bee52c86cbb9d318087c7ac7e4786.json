{"ast":null,"code":"/*\n * JavaScript Load Image Meta\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Image metadata handling implementation\n * based on the help and contribution of\n * Achim St√∂hr.\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require, Promise, DataView, Uint8Array, ArrayBuffer */\n;\n\n(function (factory) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image'], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'));\n  } else {\n    // Browser globals:\n    factory(window.loadImage);\n  }\n})(function (loadImage) {\n  'use strict';\n\n  var global = loadImage.global;\n  var originalTransform = loadImage.transform;\n  var blobSlice = global.Blob && (Blob.prototype.slice || Blob.prototype.webkitSlice || Blob.prototype.mozSlice);\n\n  var bufferSlice = global.ArrayBuffer && ArrayBuffer.prototype.slice || function (begin, end) {\n    // Polyfill for IE10, which does not support ArrayBuffer.slice\n    // eslint-disable-next-line no-param-reassign\n    end = end || this.byteLength - begin;\n    var arr1 = new Uint8Array(this, begin, end);\n    var arr2 = new Uint8Array(end);\n    arr2.set(arr1);\n    return arr2.buffer;\n  };\n\n  var metaDataParsers = {\n    jpeg: {\n      0xffe1: [],\n      // APP1 marker\n      0xffed: [] // APP13 marker\n\n    }\n  };\n  /**\n   * Parses image metadata and calls the callback with an object argument\n   * with the following property:\n   * - imageHead: The complete image head as ArrayBuffer\n   * The options argument accepts an object and supports the following\n   * properties:\n   * - maxMetaDataSize: Defines the maximum number of bytes to parse.\n   * - disableImageHead: Disables creating the imageHead property.\n   *\n   * @param {Blob} file Blob object\n   * @param {Function} [callback] Callback function\n   * @param {object} [options] Parsing options\n   * @param {object} [data] Result data object\n   * @returns {Promise<object>|undefined} Returns Promise if no callback given.\n   */\n\n  function parseMetaData(file, callback, options, data) {\n    var that = this;\n    /**\n     * Promise executor\n     *\n     * @param {Function} resolve Resolution function\n     * @param {Function} reject Rejection function\n     * @returns {undefined} Undefined\n     */\n\n    function executor(resolve, reject) {\n      if (!(global.DataView && blobSlice && file && file.size >= 12 && file.type === 'image/jpeg')) {\n        // Nothing to parse\n        return resolve(data);\n      } // 256 KiB should contain all EXIF/ICC/IPTC segments:\n\n\n      var maxMetaDataSize = options.maxMetaDataSize || 262144;\n\n      if (!loadImage.readFile(blobSlice.call(file, 0, maxMetaDataSize), function (buffer) {\n        // Note on endianness:\n        // Since the marker and length bytes in JPEG files are always\n        // stored in big endian order, we can leave the endian parameter\n        // of the DataView methods undefined, defaulting to big endian.\n        var dataView = new DataView(buffer); // Check for the JPEG marker (0xffd8):\n\n        if (dataView.getUint16(0) !== 0xffd8) {\n          return reject(new Error('Invalid JPEG file: Missing JPEG marker.'));\n        }\n\n        var offset = 2;\n        var maxOffset = dataView.byteLength - 4;\n        var headLength = offset;\n        var markerBytes;\n        var markerLength;\n        var parsers;\n        var i;\n\n        while (offset < maxOffset) {\n          markerBytes = dataView.getUint16(offset); // Search for APPn (0xffeN) and COM (0xfffe) markers,\n          // which contain application-specific metadata like\n          // Exif, ICC and IPTC data and text comments:\n\n          if (markerBytes >= 0xffe0 && markerBytes <= 0xffef || markerBytes === 0xfffe) {\n            // The marker bytes (2) are always followed by\n            // the length bytes (2), indicating the length of the\n            // marker segment, which includes the length bytes,\n            // but not the marker bytes, so we add 2:\n            markerLength = dataView.getUint16(offset + 2) + 2;\n\n            if (offset + markerLength > dataView.byteLength) {\n              // eslint-disable-next-line no-console\n              console.log('Invalid JPEG metadata: Invalid segment size.');\n              break;\n            }\n\n            parsers = metaDataParsers.jpeg[markerBytes];\n\n            if (parsers && !options.disableMetaDataParsers) {\n              for (i = 0; i < parsers.length; i += 1) {\n                parsers[i].call(that, dataView, offset, markerLength, data, options);\n              }\n            }\n\n            offset += markerLength;\n            headLength = offset;\n          } else {\n            // Not an APPn or COM marker, probably safe to\n            // assume that this is the end of the metadata\n            break;\n          }\n        } // Meta length must be longer than JPEG marker (2)\n        // plus APPn marker (2), followed by length bytes (2):\n\n\n        if (!options.disableImageHead && headLength > 6) {\n          data.imageHead = bufferSlice.call(buffer, 0, headLength);\n        }\n\n        resolve(data);\n      }, reject, 'readAsArrayBuffer')) {\n        // No support for the FileReader interface, nothing to parse\n        resolve(data);\n      }\n    }\n\n    options = options || {}; // eslint-disable-line no-param-reassign\n\n    if (global.Promise && typeof callback !== 'function') {\n      options = callback || {}; // eslint-disable-line no-param-reassign\n\n      data = options; // eslint-disable-line no-param-reassign\n\n      return new Promise(executor);\n    }\n\n    data = data || {}; // eslint-disable-line no-param-reassign\n\n    return executor(callback, callback);\n  }\n  /**\n   * Replaces the head of a JPEG Blob\n   *\n   * @param {Blob} blob Blob object\n   * @param {ArrayBuffer} oldHead Old JPEG head\n   * @param {ArrayBuffer} newHead New JPEG head\n   * @returns {Blob} Combined Blob\n   */\n\n\n  function replaceJPEGHead(blob, oldHead, newHead) {\n    if (!blob || !oldHead || !newHead) return null;\n    return new Blob([newHead, blobSlice.call(blob, oldHead.byteLength)], {\n      type: 'image/jpeg'\n    });\n  }\n  /**\n   * Replaces the image head of a JPEG blob with the given one.\n   * Returns a Promise or calls the callback with the new Blob.\n   *\n   * @param {Blob} blob Blob object\n   * @param {ArrayBuffer} head New JPEG head\n   * @param {Function} [callback] Callback function\n   * @returns {Promise<Blob|null>|undefined} Combined Blob\n   */\n\n\n  function replaceHead(blob, head, callback) {\n    var options = {\n      maxMetaDataSize: 256,\n      disableMetaDataParsers: true\n    };\n\n    if (!callback && global.Promise) {\n      return parseMetaData(blob, options).then(function (data) {\n        return replaceJPEGHead(blob, data.imageHead, head);\n      });\n    }\n\n    parseMetaData(blob, function (data) {\n      callback(replaceJPEGHead(blob, data.imageHead, head));\n    }, options);\n  }\n\n  loadImage.transform = function (img, options, callback, file, data) {\n    if (loadImage.requiresMetaData(options)) {\n      data = data || {}; // eslint-disable-line no-param-reassign\n\n      parseMetaData(file, function (result) {\n        if (result !== data) {\n          // eslint-disable-next-line no-console\n          if (global.console) console.log(result);\n          result = data; // eslint-disable-line no-param-reassign\n        }\n\n        originalTransform.call(loadImage, img, options, callback, file, result);\n      }, options, data);\n    } else {\n      originalTransform.apply(loadImage, arguments);\n    }\n  };\n\n  loadImage.blobSlice = blobSlice;\n  loadImage.bufferSlice = bufferSlice;\n  loadImage.replaceHead = replaceHead;\n  loadImage.parseMetaData = parseMetaData;\n  loadImage.metaDataParsers = metaDataParsers;\n});","map":{"version":3,"sources":["/Users/annaisthebest/Desktop/hci-ClassMates/node_modules/blueimp-load-image/js/load-image-meta.js"],"names":["factory","define","amd","module","exports","require","window","loadImage","global","originalTransform","transform","blobSlice","Blob","prototype","slice","webkitSlice","mozSlice","bufferSlice","ArrayBuffer","begin","end","byteLength","arr1","Uint8Array","arr2","set","buffer","metaDataParsers","jpeg","parseMetaData","file","callback","options","data","that","executor","resolve","reject","DataView","size","type","maxMetaDataSize","readFile","call","dataView","getUint16","Error","offset","maxOffset","headLength","markerBytes","markerLength","parsers","i","console","log","disableMetaDataParsers","length","disableImageHead","imageHead","Promise","replaceJPEGHead","blob","oldHead","newHead","replaceHead","head","then","img","requiresMetaData","result","apply","arguments"],"mappings":"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","sourcesContent":["/*\n * JavaScript Load Image Meta\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Image metadata handling implementation\n * based on the help and contribution of\n * Achim St√∂hr.\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require, Promise, DataView, Uint8Array, ArrayBuffer */\n\n;(function (factory) {\n  'use strict'\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image'], factory)\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'))\n  } else {\n    // Browser globals:\n    factory(window.loadImage)\n  }\n})(function (loadImage) {\n  'use strict'\n\n  var global = loadImage.global\n  var originalTransform = loadImage.transform\n\n  var blobSlice =\n    global.Blob &&\n    (Blob.prototype.slice ||\n      Blob.prototype.webkitSlice ||\n      Blob.prototype.mozSlice)\n\n  var bufferSlice =\n    (global.ArrayBuffer && ArrayBuffer.prototype.slice) ||\n    function (begin, end) {\n      // Polyfill for IE10, which does not support ArrayBuffer.slice\n      // eslint-disable-next-line no-param-reassign\n      end = end || this.byteLength - begin\n      var arr1 = new Uint8Array(this, begin, end)\n      var arr2 = new Uint8Array(end)\n      arr2.set(arr1)\n      return arr2.buffer\n    }\n\n  var metaDataParsers = {\n    jpeg: {\n      0xffe1: [], // APP1 marker\n      0xffed: [] // APP13 marker\n    }\n  }\n\n  /**\n   * Parses image metadata and calls the callback with an object argument\n   * with the following property:\n   * - imageHead: The complete image head as ArrayBuffer\n   * The options argument accepts an object and supports the following\n   * properties:\n   * - maxMetaDataSize: Defines the maximum number of bytes to parse.\n   * - disableImageHead: Disables creating the imageHead property.\n   *\n   * @param {Blob} file Blob object\n   * @param {Function} [callback] Callback function\n   * @param {object} [options] Parsing options\n   * @param {object} [data] Result data object\n   * @returns {Promise<object>|undefined} Returns Promise if no callback given.\n   */\n  function parseMetaData(file, callback, options, data) {\n    var that = this\n    /**\n     * Promise executor\n     *\n     * @param {Function} resolve Resolution function\n     * @param {Function} reject Rejection function\n     * @returns {undefined} Undefined\n     */\n    function executor(resolve, reject) {\n      if (\n        !(\n          global.DataView &&\n          blobSlice &&\n          file &&\n          file.size >= 12 &&\n          file.type === 'image/jpeg'\n        )\n      ) {\n        // Nothing to parse\n        return resolve(data)\n      }\n      // 256 KiB should contain all EXIF/ICC/IPTC segments:\n      var maxMetaDataSize = options.maxMetaDataSize || 262144\n      if (\n        !loadImage.readFile(\n          blobSlice.call(file, 0, maxMetaDataSize),\n          function (buffer) {\n            // Note on endianness:\n            // Since the marker and length bytes in JPEG files are always\n            // stored in big endian order, we can leave the endian parameter\n            // of the DataView methods undefined, defaulting to big endian.\n            var dataView = new DataView(buffer)\n            // Check for the JPEG marker (0xffd8):\n            if (dataView.getUint16(0) !== 0xffd8) {\n              return reject(\n                new Error('Invalid JPEG file: Missing JPEG marker.')\n              )\n            }\n            var offset = 2\n            var maxOffset = dataView.byteLength - 4\n            var headLength = offset\n            var markerBytes\n            var markerLength\n            var parsers\n            var i\n            while (offset < maxOffset) {\n              markerBytes = dataView.getUint16(offset)\n              // Search for APPn (0xffeN) and COM (0xfffe) markers,\n              // which contain application-specific metadata like\n              // Exif, ICC and IPTC data and text comments:\n              if (\n                (markerBytes >= 0xffe0 && markerBytes <= 0xffef) ||\n                markerBytes === 0xfffe\n              ) {\n                // The marker bytes (2) are always followed by\n                // the length bytes (2), indicating the length of the\n                // marker segment, which includes the length bytes,\n                // but not the marker bytes, so we add 2:\n                markerLength = dataView.getUint16(offset + 2) + 2\n                if (offset + markerLength > dataView.byteLength) {\n                  // eslint-disable-next-line no-console\n                  console.log('Invalid JPEG metadata: Invalid segment size.')\n                  break\n                }\n                parsers = metaDataParsers.jpeg[markerBytes]\n                if (parsers && !options.disableMetaDataParsers) {\n                  for (i = 0; i < parsers.length; i += 1) {\n                    parsers[i].call(\n                      that,\n                      dataView,\n                      offset,\n                      markerLength,\n                      data,\n                      options\n                    )\n                  }\n                }\n                offset += markerLength\n                headLength = offset\n              } else {\n                // Not an APPn or COM marker, probably safe to\n                // assume that this is the end of the metadata\n                break\n              }\n            }\n            // Meta length must be longer than JPEG marker (2)\n            // plus APPn marker (2), followed by length bytes (2):\n            if (!options.disableImageHead && headLength > 6) {\n              data.imageHead = bufferSlice.call(buffer, 0, headLength)\n            }\n            resolve(data)\n          },\n          reject,\n          'readAsArrayBuffer'\n        )\n      ) {\n        // No support for the FileReader interface, nothing to parse\n        resolve(data)\n      }\n    }\n    options = options || {} // eslint-disable-line no-param-reassign\n    if (global.Promise && typeof callback !== 'function') {\n      options = callback || {} // eslint-disable-line no-param-reassign\n      data = options // eslint-disable-line no-param-reassign\n      return new Promise(executor)\n    }\n    data = data || {} // eslint-disable-line no-param-reassign\n    return executor(callback, callback)\n  }\n\n  /**\n   * Replaces the head of a JPEG Blob\n   *\n   * @param {Blob} blob Blob object\n   * @param {ArrayBuffer} oldHead Old JPEG head\n   * @param {ArrayBuffer} newHead New JPEG head\n   * @returns {Blob} Combined Blob\n   */\n  function replaceJPEGHead(blob, oldHead, newHead) {\n    if (!blob || !oldHead || !newHead) return null\n    return new Blob([newHead, blobSlice.call(blob, oldHead.byteLength)], {\n      type: 'image/jpeg'\n    })\n  }\n\n  /**\n   * Replaces the image head of a JPEG blob with the given one.\n   * Returns a Promise or calls the callback with the new Blob.\n   *\n   * @param {Blob} blob Blob object\n   * @param {ArrayBuffer} head New JPEG head\n   * @param {Function} [callback] Callback function\n   * @returns {Promise<Blob|null>|undefined} Combined Blob\n   */\n  function replaceHead(blob, head, callback) {\n    var options = { maxMetaDataSize: 256, disableMetaDataParsers: true }\n    if (!callback && global.Promise) {\n      return parseMetaData(blob, options).then(function (data) {\n        return replaceJPEGHead(blob, data.imageHead, head)\n      })\n    }\n    parseMetaData(\n      blob,\n      function (data) {\n        callback(replaceJPEGHead(blob, data.imageHead, head))\n      },\n      options\n    )\n  }\n\n  loadImage.transform = function (img, options, callback, file, data) {\n    if (loadImage.requiresMetaData(options)) {\n      data = data || {} // eslint-disable-line no-param-reassign\n      parseMetaData(\n        file,\n        function (result) {\n          if (result !== data) {\n            // eslint-disable-next-line no-console\n            if (global.console) console.log(result)\n            result = data // eslint-disable-line no-param-reassign\n          }\n          originalTransform.call(\n            loadImage,\n            img,\n            options,\n            callback,\n            file,\n            result\n          )\n        },\n        options,\n        data\n      )\n    } else {\n      originalTransform.apply(loadImage, arguments)\n    }\n  }\n\n  loadImage.blobSlice = blobSlice\n  loadImage.bufferSlice = bufferSlice\n  loadImage.replaceHead = replaceHead\n  loadImage.parseMetaData = parseMetaData\n  loadImage.metaDataParsers = metaDataParsers\n})\n"]},"metadata":{},"sourceType":"script"}