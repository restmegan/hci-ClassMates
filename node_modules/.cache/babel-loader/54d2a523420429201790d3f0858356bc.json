{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$(),\n    _s6 = $RefreshSig$(),\n    _s7 = $RefreshSig$(),\n    _s8 = $RefreshSig$(),\n    _s9 = $RefreshSig$(),\n    _s10 = $RefreshSig$(),\n    _s11 = $RefreshSig$(),\n    _s12 = $RefreshSig$();\n\nimport { createContext, createElement, useState, useEffect, useRef, memo, useContext, Fragment, useCallback, forwardRef, useImperativeHandle, PureComponent } from 'react';\nimport ResizeObserver from 'resize-observer-polyfill';\nvar VirtuosoContext = /*#__PURE__*/createContext(undefined);\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  it = o[Symbol.iterator]();\n  return it.next.bind(it);\n}\n\nfunction combineOperators() {\n  for (var _len = arguments.length, operators = new Array(_len), _key = 0; _key < _len; _key++) {\n    operators[_key] = arguments[_key];\n  }\n\n  if (operators.length === 0) {\n    return function (value, subscriber) {\n      return subscriber(value);\n    };\n  }\n\n  if (operators.length === 1) {\n    return operators[0];\n  }\n\n  return function (value, subscriber) {\n    var acc = function acc(value) {\n      return subscriber(value);\n    };\n\n    operators.slice().reverse().forEach(function (operator) {\n      var prevCallback = acc;\n\n      acc = function acc(value) {\n        return operator(value, prevCallback);\n      };\n    });\n    acc(value);\n  };\n}\n\nfunction buildPipe(subscribe) {\n  function pipe() {\n    var operator = combineOperators.apply(void 0, arguments);\n    return observable(subscribe, operator);\n  }\n\n  return pipe;\n}\n\nfunction observable(source, operator) {\n  var subscribe = function subscribe(subscriber) {\n    return source(function (val) {\n      return operator(val, subscriber);\n    });\n  };\n\n  return {\n    subscribe: subscribe,\n    pipe: buildPipe(subscribe)\n  };\n}\n\nfunction subject(initial, distinct) {\n  if (distinct === void 0) {\n    distinct = true;\n  }\n\n  var subscribers = [];\n  var val = initial;\n\n  var next = function next(newVal) {\n    if (!distinct || newVal !== val) {\n      val = newVal;\n      subscribers.forEach(function (subscriber) {\n        return subscriber(newVal);\n      });\n    }\n  };\n\n  var subscribe = function subscribe(subscriber) {\n    subscribers.push(subscriber);\n\n    if (val !== undefined) {\n      subscriber(val);\n    }\n\n    return function () {\n      subscribers = subscribers.filter(function (sub) {\n        return sub !== subscriber;\n      });\n    };\n  };\n\n  return {\n    next: next,\n    subscribe: subscribe,\n    pipe: buildPipe(subscribe),\n    subscribers: subscribers\n  };\n}\n\nfunction coldSubject() {\n  var subscribers = [];\n\n  var next = function next(newVal) {\n    subscribers.forEach(function (subscriber) {\n      return subscriber(newVal);\n    });\n  };\n\n  var subscribe = function subscribe(subscriber) {\n    subscribers.push(subscriber);\n    return function () {\n      subscribers = subscribers.filter(function (sub) {\n        return sub !== subscriber;\n      });\n    };\n  };\n\n  return {\n    next: next,\n    subscribe: subscribe,\n    pipe: buildPipe(subscribe),\n    subscribers: subscribers\n  };\n}\n\nfunction combineLatest() {\n  for (var _len2 = arguments.length, sources = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    sources[_key2] = arguments[_key2];\n  }\n\n  var called = Array(sources.length).fill(false);\n  var values = Array(sources.length);\n  var subscribers = [];\n\n  var publish = function publish(subscribers) {\n    called.every(function (isCalled) {\n      return isCalled;\n    }) && subscribers.forEach(function (subscriber) {\n      return subscriber(values);\n    });\n  };\n\n  sources.forEach(function (source, index) {\n    source.subscribe(function (val) {\n      called[index] = true;\n      values[index] = val;\n      publish(subscribers);\n    });\n  });\n\n  var subscribe = function subscribe(subscriber) {\n    subscribers.push(subscriber);\n    publish([subscriber]);\n    return function () {\n      subscribers = subscribers.filter(function (sub) {\n        return sub !== subscriber;\n      });\n    };\n  };\n\n  return {\n    subscribe: subscribe,\n    pipe: buildPipe(subscribe)\n  };\n}\n\nfunction map(map) {\n  return function (val, subscriber) {\n    subscriber(map(val));\n  };\n}\n\nfunction mapTo(val) {\n  return function (_, done) {\n    return done(val);\n  };\n}\n\nfunction skip(times) {\n  return function (val, done) {\n    if (times > 0) {\n      times--;\n    } else {\n      done(val);\n    }\n  };\n}\n\nfunction filter(predicate) {\n  return function (val, done) {\n    predicate(val) && done(val);\n  };\n}\n\nfunction duc(comparator) {\n  if (comparator === void 0) {\n    comparator = function comparator(current, next) {\n      return current !== next;\n    };\n  }\n\n  var current;\n  return function (next, done) {\n    if (comparator(current, next)) {\n      current = next;\n      done(next);\n    }\n  };\n}\n\nfunction debounceTime(time) {\n  var val;\n  var timeout;\n  return function (newVal, done) {\n    val = newVal;\n\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n\n    timeout = setTimeout(function () {\n      done(val);\n    }, time);\n  };\n}\n\nfunction throttleTime(time) {\n  var val;\n  var timeout;\n  return function (newVal, done) {\n    val = newVal;\n\n    if (timeout) {\n      return;\n    }\n\n    timeout = setTimeout(function () {\n      timeout = undefined;\n      done(val);\n    }, time);\n  };\n}\n\nfunction scan(scanner, initialValue) {\n  var prevVal = initialValue;\n  return function (newVal, done) {\n    done(prevVal = scanner(prevVal, newVal));\n  };\n}\n\nfunction withLatestFrom() {\n  for (var _len3 = arguments.length, sources = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    sources[_key3] = arguments[_key3];\n  }\n\n  var called = Array(sources.length).fill(false);\n  var values = Array(sources.length);\n  sources.forEach(function (source, index) {\n    source.subscribe(function (val) {\n      values[index] = val;\n      called[index] = true;\n    });\n  });\n  return function (val, done) {\n    called.every(function (isCalled) {\n      return isCalled;\n    }) && done([val].concat(values));\n  };\n}\n\nvar buildIsScrolling = function buildIsScrolling(scrollTop$) {\n  var isScrolling$ = subject(false);\n  scrollTop$.pipe(skip(1), duc(), mapTo(true)).subscribe(isScrolling$.next);\n  scrollTop$.pipe(skip(1), mapTo(false), debounceTime(200)).subscribe(isScrolling$.next);\n  return isScrolling$;\n};\n\nfunction adjustForPrependedItemsEngine(_ref) {\n  var offsetList$ = _ref.offsetList$,\n      scrollTop$ = _ref.scrollTop$,\n      scrollTo$ = _ref.scrollTo$;\n  var adjustForPrependedItems$ = coldSubject();\n  var adjustmentInProgress$ = subject(false);\n  adjustForPrependedItems$.pipe(withLatestFrom(offsetList$, scrollTop$, adjustmentInProgress$)).subscribe(function (_ref2) {\n    var count = _ref2[0],\n        offsetList = _ref2[1],\n        scrollTop = _ref2[2],\n        inProgress = _ref2[3];\n\n    if (inProgress || offsetList.empty()) {\n      return;\n    }\n\n    adjustmentInProgress$.next(true);\n    offsetList$.next(offsetList.adjustForPrependedItems(count));\n    setTimeout(function () {\n      scrollTo$.next({\n        top: count * offsetList.getDefaultSize() + scrollTop\n      });\n      adjustmentInProgress$.next(false);\n    });\n  });\n  return {\n    adjustForPrependedItems$: adjustForPrependedItems$,\n    adjustmentInProgress$: adjustmentInProgress$\n  };\n}\n\nfunction followOutputEngine(_ref) {\n  var scrollToIndex$ = _ref.scrollToIndex$,\n      scrolledToBottom$ = _ref.scrolledToBottom$,\n      totalCount$ = _ref.totalCount$;\n  var followOutput$ = subject(false);\n  combineLatest(followOutput$, totalCount$).pipe(withLatestFrom(scrolledToBottom$)).subscribe(function (_ref2) {\n    var _ref2$ = _ref2[0],\n        followOutput = _ref2$[0],\n        totalCount = _ref2$[1],\n        scrolledToBottom = _ref2[1];\n\n    if (followOutput && scrolledToBottom) {\n      setTimeout(function () {\n        scrollToIndex$.next({\n          index: totalCount - 1,\n          align: 'end',\n          behavior: 'auto'\n        });\n      });\n    }\n  });\n  return {\n    followOutput$: followOutput$\n  };\n}\n\nvar NilNode = /*#__PURE__*/function () {\n  function NilNode() {\n    this.level = 0;\n  }\n\n  var _proto = NilNode.prototype;\n\n  _proto.rebalance = function rebalance() {\n    return this;\n  };\n\n  _proto.adjust = function adjust() {\n    return this;\n  };\n\n  _proto.shift = function shift() {\n    return this;\n  };\n\n  _proto.remove = function remove() {\n    return this;\n  };\n\n  _proto.find = function find() {\n    return;\n  };\n\n  _proto.findWith = function findWith() {\n    return;\n  };\n\n  _proto.findMax = function findMax() {\n    return -Infinity;\n  };\n\n  _proto.findMaxValue = function findMaxValue() {\n    return;\n  };\n\n  _proto.insert = function insert(key, value) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new NonNilNode({\n      key: key,\n      value: value,\n      level: 1\n    });\n  };\n\n  _proto.walkWithin = function walkWithin() {\n    return [];\n  };\n\n  _proto.walk = function walk() {\n    return [];\n  };\n\n  _proto.ranges = function ranges() {\n    return [];\n  };\n\n  _proto.rangesWithin = function rangesWithin() {\n    return [];\n  };\n\n  _proto.empty = function empty() {\n    return true;\n  };\n\n  _proto.isSingle = function isSingle() {\n    return true;\n  };\n\n  _proto.isInvariant = function isInvariant() {\n    return true;\n  };\n\n  _proto.keys = function keys() {\n    return [];\n  };\n\n  return NilNode;\n}();\n\nvar NIL_NODE = /*#__PURE__*/new NilNode();\nObject.freeze(NIL_NODE);\n\nvar UnreachableCaseError = /*#__PURE__*/function (_Error) {\n  _inheritsLoose(UnreachableCaseError, _Error);\n\n  function UnreachableCaseError(val) {\n    return _Error.call(this, \"Unreachable case: \" + val) || this;\n  }\n\n  return UnreachableCaseError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar NonNilNode = /*#__PURE__*/function () {\n  function NonNilNode(_ref) {\n    var key = _ref.key,\n        value = _ref.value,\n        level = _ref.level,\n        _ref$left = _ref.left,\n        left = _ref$left === void 0 ? NIL_NODE : _ref$left,\n        _ref$right = _ref.right,\n        right = _ref$right === void 0 ? NIL_NODE : _ref$right;\n    this.key = key;\n    this.value = value;\n    this.level = level;\n    this.left = left;\n    this.right = right;\n  }\n\n  var _proto2 = NonNilNode.prototype;\n\n  _proto2.shift = function shift(amount) {\n    return this.clone({\n      key: this.key + amount,\n      left: this.left.shift(amount),\n      right: this.right.shift(amount)\n    });\n  };\n\n  _proto2.remove = function remove(key) {\n    var left = this.left,\n        right = this.right;\n\n    if (key === this.key) {\n      if (left.empty()) {\n        return right;\n      } else if (right.empty()) {\n        return left;\n      } else {\n        var _left$last = left.last(),\n            lastKey = _left$last[0],\n            lastValue = _left$last[1];\n\n        return this.clone({\n          key: lastKey,\n          value: lastValue,\n          left: left.deleteLast()\n        }).adjust();\n      }\n    } else if (key < this.key) {\n      return this.clone({\n        left: left.remove(key)\n      }).adjust();\n    } else {\n      return this.clone({\n        right: right.remove(key)\n      }).adjust();\n    }\n  };\n\n  _proto2.empty = function empty() {\n    return false;\n  };\n\n  _proto2.find = function find(key) {\n    if (key === this.key) {\n      return this.value;\n    } else if (key < this.key) {\n      return this.left.find(key);\n    } else {\n      return this.right.find(key);\n    }\n  };\n\n  _proto2.findWith = function findWith(callback) {\n    var result = callback(this.value);\n\n    switch (result) {\n      case -1:\n        return this.left.findWith(callback);\n\n      case 0:\n        return [this.key, this.value];\n\n      case 1:\n        return this.right.findWith(callback);\n\n      default:\n        throw new UnreachableCaseError(result);\n    }\n  };\n\n  _proto2.findMax = function findMax(key) {\n    if (this.key === key) {\n      return key;\n    }\n\n    if (this.key < key) {\n      var rightKey = this.right.findMax(key);\n\n      if (rightKey === -Infinity) {\n        return this.key;\n      } else {\n        return rightKey;\n      }\n    }\n\n    return this.left.findMax(key);\n  };\n\n  _proto2.findMaxValue = function findMaxValue(key) {\n    if (this.key === key) {\n      return this.value;\n    }\n\n    if (this.key < key) {\n      var rightValue = this.right.findMaxValue(key);\n\n      if (rightValue === undefined) {\n        return this.value;\n      } else {\n        return rightValue;\n      }\n    }\n\n    return this.left.findMaxValue(key);\n  };\n\n  _proto2.insert = function insert(key, value) {\n    if (key === this.key) {\n      return this.clone({\n        key: key,\n        value: value\n      });\n    } else if (key < this.key) {\n      return this.clone({\n        left: this.left.insert(key, value)\n      }).rebalance();\n    } else {\n      return this.clone({\n        right: this.right.insert(key, value)\n      }).rebalance();\n    }\n  };\n\n  _proto2.walkWithin = function walkWithin(start, end) {\n    var key = this.key,\n        value = this.value;\n    var result = [];\n\n    if (key > start) {\n      result = result.concat(this.left.walkWithin(start, end));\n    }\n\n    if (key >= start && key <= end) {\n      result.push({\n        key: key,\n        value: value\n      });\n    }\n\n    if (key <= end) {\n      result = result.concat(this.right.walkWithin(start, end));\n    }\n\n    return result;\n  };\n\n  _proto2.walk = function walk() {\n    return [].concat(this.left.walk(), [{\n      key: this.key,\n      value: this.value\n    }], this.right.walk());\n  };\n\n  _proto2.last = function last() {\n    if (this.right.empty()) {\n      return [this.key, this.value];\n    } else {\n      return this.right.last();\n    }\n  };\n\n  _proto2.deleteLast = function deleteLast() {\n    if (this.right.empty()) {\n      return this.left;\n    } else {\n      return this.clone({\n        right: this.right.deleteLast()\n      }).adjust();\n    }\n  };\n\n  _proto2.clone = function clone(args) {\n    return new NonNilNode({\n      key: args.key !== undefined ? args.key : this.key,\n      value: args.value !== undefined ? args.value : this.value,\n      level: args.level !== undefined ? args.level : this.level,\n      left: args.left !== undefined ? args.left : this.left,\n      right: args.right !== undefined ? args.right : this.right\n    });\n  };\n\n  _proto2.isSingle = function isSingle() {\n    return this.level > this.right.level;\n  };\n\n  _proto2.rebalance = function rebalance() {\n    return this.skew().split();\n  };\n\n  _proto2.adjust = function adjust() {\n    var left = this.left,\n        right = this.right,\n        level = this.level;\n\n    if (right.level >= level - 1 && left.level >= level - 1) {\n      return this;\n    } else if (level > right.level + 1) {\n      if (left.isSingle()) {\n        return this.clone({\n          level: level - 1\n        }).skew();\n      } else {\n        if (!left.empty() && !left.right.empty()) {\n          return left.right.clone({\n            left: left.clone({\n              right: left.right.left\n            }),\n            right: this.clone({\n              left: left.right.right,\n              level: level - 1\n            }),\n            level: level\n          });\n        } else {\n          throw new Error('Unexpected empty nodes');\n        }\n      }\n    } else {\n      if (this.isSingle()) {\n        return this.clone({\n          level: level - 1\n        }).split();\n      } else {\n        if (!right.empty() && !right.left.empty()) {\n          var rl = right.left;\n          var rightLevel = rl.isSingle() ? right.level - 1 : right.level;\n          return rl.clone({\n            left: this.clone({\n              right: rl.left,\n              level: level - 1\n            }),\n            right: right.clone({\n              left: rl.right,\n              level: rightLevel\n            }).split(),\n            level: rl.level + 1\n          });\n        } else {\n          throw new Error('Unexpected empty nodes');\n        }\n      }\n    }\n  };\n\n  _proto2.isInvariant = function isInvariant() {\n    var left = this.left,\n        right = this.right,\n        level = this.level;\n\n    if (level !== left.level + 1) {\n      return false;\n    } else if (level !== right.level && level !== right.level + 1) {\n      return false;\n    } else if (!right.empty() && level <= right.right.level) {\n      return false;\n    } else {\n      return left.isInvariant() && right.isInvariant();\n    }\n  };\n\n  _proto2.keys = function keys() {\n    return [].concat(this.left.keys(), [this.key], this.right.keys());\n  };\n\n  _proto2.ranges = function ranges() {\n    return this.toRanges(this.walk());\n  };\n\n  _proto2.rangesWithin = function rangesWithin(startIndex, endIndex) {\n    return this.toRanges(this.walkWithin(startIndex, endIndex));\n  };\n\n  _proto2.toRanges = function toRanges(nodes) {\n    if (nodes.length === 0) {\n      return [];\n    }\n\n    var first = nodes[0];\n    var start = first.key,\n        value = first.value;\n    var result = [];\n\n    for (var i = 1; i <= nodes.length; i++) {\n      var nextNode = nodes[i];\n      var end = nextNode ? nextNode.key - 1 : Infinity;\n      result.push({\n        start: start,\n        end: end,\n        value: value\n      });\n\n      if (nextNode) {\n        start = nextNode.key;\n        value = nextNode.value;\n      }\n    }\n\n    return result;\n  };\n\n  _proto2.split = function split() {\n    var right = this.right,\n        level = this.level;\n\n    if (!right.empty() && !right.right.empty() && right.level === level && right.right.level === level) {\n      return right.clone({\n        left: this.clone({\n          right: right.left\n        }),\n        level: level + 1\n      });\n    } else {\n      return this;\n    }\n  };\n\n  _proto2.skew = function skew() {\n    var left = this.left;\n\n    if (!left.empty() && left.level === this.level) {\n      return left.clone({\n        right: this.clone({\n          left: left.right\n        })\n      });\n    } else {\n      return this;\n    }\n  };\n\n  return NonNilNode;\n}();\n\nvar AATree = /*#__PURE__*/function () {\n  function AATree(root) {\n    this.root = root;\n  }\n\n  AATree.empty = function empty() {\n    return new AATree(NIL_NODE);\n  };\n\n  var _proto3 = AATree.prototype;\n\n  _proto3.find = function find(key) {\n    return this.root.find(key);\n  };\n\n  _proto3.findMax = function findMax(key) {\n    return this.root.findMax(key);\n  };\n\n  _proto3.findMaxValue = function findMaxValue(key) {\n    if (this.empty()) {\n      throw new Error('Searching for max value in an empty tree');\n    }\n\n    return this.root.findMaxValue(key);\n  };\n\n  _proto3.findWith = function findWith(callback) {\n    return this.root.findWith(callback);\n  };\n\n  _proto3.insert = function insert(key, value) {\n    return new AATree(this.root.insert(key, value));\n  };\n\n  _proto3.remove = function remove(key) {\n    return new AATree(this.root.remove(key));\n  };\n\n  _proto3.shift = function shift(amount) {\n    if (this.empty()) {\n      return this;\n    }\n\n    var defaultValue = this.root.findMaxValue(Infinity);\n    return new AATree(this.root.shift(amount).insert(0, defaultValue));\n  };\n\n  _proto3.empty = function empty() {\n    return this.root.empty();\n  };\n\n  _proto3.keys = function keys() {\n    return this.root.keys();\n  };\n\n  _proto3.walk = function walk() {\n    return this.root.walk();\n  };\n\n  _proto3.walkWithin = function walkWithin(start, end) {\n    var adjustedStart = this.root.findMax(start);\n    return this.root.walkWithin(adjustedStart, end);\n  };\n\n  _proto3.ranges = function ranges() {\n    return this.root.ranges();\n  };\n\n  _proto3.rangesWithin = function rangesWithin(start, end) {\n    var adjustedStart = this.root.findMax(start);\n    return this.root.rangesWithin(adjustedStart, end);\n  };\n\n  _proto3.isInvariant = function isInvariant() {\n    return this.root.isInvariant();\n  };\n\n  return AATree;\n}();\n\nvar StubIndexTransposer = /*#__PURE__*/function () {\n  function StubIndexTransposer() {}\n\n  var _proto = StubIndexTransposer.prototype;\n\n  _proto.transpose = function transpose(items) {\n    return items.map(function (item) {\n      return {\n        groupIndex: 0,\n        index: item.index,\n        offset: item.offset,\n        size: item.size,\n        transposedIndex: item.index,\n        type: 'item'\n      };\n    });\n  };\n\n  return StubIndexTransposer;\n}();\n\nvar GroupIndexTransposer = /*#__PURE__*/function () {\n  function GroupIndexTransposer(counts) {\n    this.count = counts.reduce(function (acc, groupCount) {\n      return acc + groupCount + 1;\n    }, 0);\n    var tree = AATree.empty();\n    var groupIndex = 0;\n    var total = 0;\n\n    for (var _iterator = _createForOfIteratorHelperLoose(counts), _step; !(_step = _iterator()).done;) {\n      var groupCount = _step.value;\n      tree = tree.insert(total, [groupIndex, total]);\n      groupIndex++;\n      total += groupCount + 1;\n    }\n\n    this.tree = tree;\n  }\n\n  var _proto2 = GroupIndexTransposer.prototype;\n\n  _proto2.totalCount = function totalCount() {\n    return this.count;\n  };\n\n  _proto2.transpose = function transpose(items) {\n    var _this = this;\n\n    return items.map(function (item) {\n      var groupMatch = _this.tree.find(item.index);\n\n      if (groupMatch) {\n        return {\n          groupIndex: groupMatch[0],\n          index: item.index,\n          offset: item.offset,\n          size: item.size,\n          type: 'group'\n        };\n      }\n\n      var _this$tree$findMaxVal = _this.tree.findMaxValue(item.index),\n          groupIndex = _this$tree$findMaxVal[0];\n\n      return {\n        groupIndex: groupIndex,\n        index: item.index,\n        offset: item.offset,\n        size: item.size,\n        transposedIndex: item.index - groupIndex - 1,\n        type: 'item'\n      };\n    });\n  };\n\n  _proto2.groupIndices = function groupIndices() {\n    return this.tree.keys();\n  };\n\n  return GroupIndexTransposer;\n}();\n\nfunction groupCountEngine(_ref) {\n  var transposer$ = _ref.transposer$,\n      stickyItems$ = _ref.stickyItems$,\n      totalCount$ = _ref.totalCount$;\n  var groupCounts$ = subject();\n  var groupIndices$ = stickyItems$.pipe();\n  groupCounts$.subscribe(function (counts) {\n    var transposer = new GroupIndexTransposer(counts);\n    transposer$.next(transposer);\n    totalCount$.next(transposer.totalCount());\n    stickyItems$.next(transposer.groupIndices());\n  });\n  return {\n    groupCounts$: groupCounts$,\n    groupIndices$: groupIndices$\n  };\n}\n\nvar getListTop = function getListTop(items) {\n  return items.length > 0 ? items[0].offset : 0;\n};\n\nfunction listEngine(_ref) {\n  var overscan = _ref.overscan,\n      defaultItemHeight = _ref.defaultItemHeight,\n      viewportHeight$ = _ref.viewportHeight$,\n      scrollTop$ = _ref.scrollTop$,\n      topListHeight$ = _ref.topListHeight$,\n      headerHeight$ = _ref.headerHeight$,\n      footerHeight$ = _ref.footerHeight$,\n      minListIndex$ = _ref.minListIndex$,\n      totalCount$ = _ref.totalCount$,\n      offsetList$ = _ref.offsetList$,\n      scrolledToTopMostItem$ = _ref.scrolledToTopMostItem$,\n      transposer$ = _ref.transposer$,\n      totalHeight$ = _ref.totalHeight$;\n  var listHeight$ = subject(0);\n  var startReached$ = coldSubject();\n  var endReached$ = coldSubject();\n  var list$ = subject([]);\n  var constrainedScrollTop$ = subject(0);\n  combineLatest(scrollTop$, totalHeight$, viewportHeight$).pipe(map(function (_ref2) {\n    var scrollTop = _ref2[0],\n        totalHeight = _ref2[1],\n        viewportHeight = _ref2[2];\n    return Math.max(0, Math.min(scrollTop, totalHeight - viewportHeight));\n  })).subscribe(constrainedScrollTop$.next);\n  combineLatest(viewportHeight$, constrainedScrollTop$, topListHeight$, listHeight$, headerHeight$, footerHeight$, minListIndex$, totalCount$, offsetList$, scrolledToTopMostItem$, transposer$).pipe(scan(function (items, _ref3) {\n    var viewportHeight = _ref3[0],\n        scrollTop = _ref3[1],\n        topListHeight = _ref3[2],\n        listHeight = _ref3[3],\n        headerHeight = _ref3[4],\n        footerHeight = _ref3[5],\n        minIndex = _ref3[6],\n        totalCount = _ref3[7],\n        offsetList = _ref3[8],\n        scrolledToTopMostItem = _ref3[9],\n        transposer = _ref3[10];\n    var itemLength = items.length;\n\n    if (totalCount === 0) {\n      return [];\n    }\n\n    var listTop = getListTop(items);\n    var listBottom = listTop - scrollTop + listHeight - headerHeight - footerHeight - topListHeight;\n    var maxIndex = Math.max(totalCount - 1, 0);\n    var indexOutOfAllowedRange = itemLength > 0 && (items[0].index < minIndex || items[itemLength - 1].index > maxIndex);\n\n    if (listBottom < viewportHeight || indexOutOfAllowedRange) {\n      var endOffset = scrollTop + viewportHeight + overscan * 2 - 1;\n      items = transposer.transpose(offsetList.range(scrollTop, endOffset, minIndex, maxIndex));\n    }\n\n    if (listTop > scrollTop) {\n      var startOffset = Math.max(scrollTop - overscan * 2, 0);\n\n      var _endOffset = scrollTop + viewportHeight - 1;\n\n      items = transposer.transpose(offsetList.range(startOffset, _endOffset, minIndex, maxIndex));\n    } // this is a hack - we should let the probe item render,\n    // but skip the real list until the viewport has scrolled\n    // to the expected location\n    // However, if we have default item height set then we can skip this.\n\n\n    if (items.length > 1 && !scrolledToTopMostItem && !defaultItemHeight) {\n      return [];\n    }\n\n    return items;\n  }, []), duc()).subscribe(list$.next);\n  var listOffset$ = combineLatest(list$, scrollTop$, topListHeight$).pipe(map(function (_ref4) {\n    var items = _ref4[0];\n    return getListTop(items);\n  }));\n  constrainedScrollTop$.subscribe(function (scrollTop) {\n    if (scrollTop === 0) {\n      startReached$.next(scrollTop);\n    }\n  });\n  var currentEndIndex = 0;\n  list$.pipe(map(function (items) {\n    return items.length ? items[items.length - 1].index : 0;\n  })).pipe(withLatestFrom(totalCount$)).subscribe(function (_ref5) {\n    var endIndex = _ref5[0],\n        totalCount = _ref5[1];\n\n    if (totalCount === 0) {\n      return;\n    }\n\n    if (endIndex === totalCount - 1) {\n      if (currentEndIndex !== endIndex) {\n        currentEndIndex = endIndex;\n        endReached$.next(endIndex);\n      }\n    }\n  });\n  return {\n    list$: list$,\n    listOffset$: listOffset$,\n    listHeight$: listHeight$,\n    startReached$: startReached$,\n    endReached$: endReached$\n  };\n}\n\nfunction maxRangeSizeEngine(_ref) {\n  var list$ = _ref.list$,\n      offsetList$ = _ref.offsetList$,\n      scrollTop$ = _ref.scrollTop$,\n      scrollTo$ = _ref.scrollTo$;\n  var scheduledReadjust$ = subject(null);\n  var maxRangeSize$ = subject(Infinity); //////////////\n  // Max range size implementation\n  // the scheduledReadjust$ can be removed through the trapNext pattern\n  //////////////\n  // 1. List warns us that it will reset itself.\n\n  offsetList$.pipe(withLatestFrom(maxRangeSize$, scrollTop$, list$)).subscribe(function (_ref2) {\n    var offsetList = _ref2[0],\n        maxRangeSize = _ref2[1],\n        scrollTop = _ref2[2],\n        list = _ref2[3];\n    return offsetList.configureMaxRangeSize(maxRangeSize, function () {\n      // 2. we pick the adjustment signal and capture the list state *before* it gets reset\n      scheduledReadjust$.next({\n        index: list[0].index,\n        offset: scrollTop - list[0].offset\n      });\n    });\n  }); // 3. once the offset list is reset, we compensate the scroll.\n\n  offsetList$.pipe(withLatestFrom(scheduledReadjust$)).subscribe(function (_ref3) {\n    var offsetList = _ref3[0],\n        adjust = _ref3[1];\n\n    if (adjust !== null) {\n      var scrollTo = offsetList.offsetOf(adjust.index) + adjust.offset;\n      scrollTo$.next({\n        top: scrollTo\n      });\n      scheduledReadjust$.next(null);\n    }\n  });\n  return {\n    maxRangeSize$: maxRangeSize$\n  };\n}\n\nvar OffsetList = /*#__PURE__*/function () {\n  function OffsetList(rangeTree, offsetTree, nanIndices, initialTopMostItemIndex) {\n    if (offsetTree === void 0) {\n      offsetTree = AATree.empty();\n    }\n\n    if (nanIndices === void 0) {\n      nanIndices = [];\n    }\n\n    if (initialTopMostItemIndex === void 0) {\n      initialTopMostItemIndex = 0;\n    }\n\n    this.initialTopMostItemIndex = 0;\n    this.rangeSize = 0;\n    this.maxRangeSize = Infinity;\n\n    this.rangeSizeExceededCallback = function () {};\n\n    this.rangeTree = rangeTree;\n    this.nanIndices = nanIndices;\n    this.initialTopMostItemIndex = initialTopMostItemIndex;\n\n    if (offsetTree.empty()) {\n      var offset = 0;\n      var ranges = rangeTree.ranges();\n      var nanFound = false;\n\n      for (var _iterator = _createForOfIteratorHelperLoose(ranges), _step; !(_step = _iterator()).done;) {\n        var _step$value = _step.value,\n            startIndex = _step$value.start,\n            endIndex = _step$value.end,\n            size = _step$value.value;\n        this.rangeSize++;\n\n        if (isNaN(size)) {\n          this.nanIndices.push(startIndex);\n\n          if (!nanFound) {\n            offsetTree = offsetTree.insert(offset, {\n              startIndex: startIndex,\n              endIndex: Infinity,\n              size: size\n            });\n          }\n\n          nanFound = true;\n        } else if (!nanFound) {\n          offsetTree = offsetTree.insert(offset, {\n            startIndex: startIndex,\n            endIndex: endIndex,\n            size: size\n          });\n          offset += (endIndex - startIndex + 1) * size;\n        }\n      }\n    }\n\n    this.offsetTree = offsetTree;\n  }\n\n  OffsetList.create = function create() {\n    return new OffsetList(AATree.empty());\n  };\n\n  var _proto = OffsetList.prototype;\n\n  _proto.empty = function empty() {\n    return this.rangeTree.empty();\n  };\n\n  _proto.fromTree = function fromTree(tree) {\n    return new OffsetList(tree, undefined, undefined, this.initialTopMostItemIndex);\n  };\n\n  _proto.insert = function insert(start, end, size) {\n    var tree = this.rangeTree;\n\n    if (tree.empty()) {\n      return this.fromTree(tree.insert(0, size));\n    }\n\n    if (this.rangeSize > this.maxRangeSize) {\n      this.rangeSizeExceededCallback();\n      return this.fromTree(AATree.empty().insert(0, this.getDefaultSize()));\n    } // tree is in non-complete state - we know the group sizes, but not the item sizes\n\n\n    if (this.nanIndices.length && this.nanIndices.indexOf(end) > -1) {\n      var groupSize = tree.find(this.nanIndices[0] - 1);\n\n      if (groupSize === size) {\n        return this.fromTree(AATree.empty().insert(0, size));\n      }\n\n      for (var _iterator2 = _createForOfIteratorHelperLoose(this.nanIndices), _step2; !(_step2 = _iterator2()).done;) {\n        var nanIndex = _step2.value;\n        tree = tree.insert(nanIndex, size);\n      }\n\n      return this.fromTree(tree);\n    } // extend the range in both directions, so that we can get adjacent neighbours.\n    // if the previous / next ones have the same value as the one we are about to insert,\n    // we 'merge' them.\n\n\n    var overlapingRanges = tree.rangesWithin(start - 1, end + 1);\n\n    if (overlapingRanges.some(function (range) {\n      return range.start === start && (range.end === end || range.end === Infinity) && range.value === size;\n    })) {\n      return this;\n    }\n\n    var firstPassDone = false;\n    var shouldInsert = false;\n\n    for (var _iterator3 = _createForOfIteratorHelperLoose(overlapingRanges), _step3; !(_step3 = _iterator3()).done;) {\n      var _step3$value = _step3.value,\n          rangeStart = _step3$value.start,\n          rangeEnd = _step3$value.end,\n          rangeValue = _step3$value.value; // previous range\n\n      if (!firstPassDone) {\n        shouldInsert = rangeValue !== size;\n        firstPassDone = true;\n      } else {\n        // remove the range if it starts within the new range OR if\n        // it has the same value as it, in order to perfrom a merge\n        if (end >= rangeStart || size === rangeValue) {\n          tree = tree.remove(rangeStart);\n        }\n      } // next range\n\n\n      if (rangeEnd > end && end >= rangeStart) {\n        if (rangeValue !== size && !isNaN(rangeValue)) {\n          tree = tree.insert(end + 1, rangeValue);\n        }\n      }\n    }\n\n    if (shouldInsert) {\n      tree = tree.insert(start, size);\n    }\n\n    return tree === this.rangeTree ? this : this.fromTree(tree);\n  };\n\n  _proto.insertSpots = function insertSpots(spotIndexes, value) {\n    if (this.empty()) {\n      var tree = this.rangeTree;\n\n      for (var _iterator4 = _createForOfIteratorHelperLoose(spotIndexes), _step4; !(_step4 = _iterator4()).done;) {\n        var spot = _step4.value;\n        tree = tree.insert(spot, value).insert(spot + 1, NaN);\n      }\n\n      return new OffsetList(tree);\n    } else {\n      throw new Error('attempting to overwrite non-empty tree');\n    }\n  };\n\n  _proto.offsetOf = function offsetOf(index) {\n    if (this.offsetTree.empty()) {\n      return 0;\n    }\n\n    var find = function find(value) {\n      if (value.startIndex > index) return -1;\n      if (value.endIndex < index) return 1;\n      return 0;\n    };\n\n    var offsetRange = this.offsetTree.findWith(find);\n\n    if (offsetRange) {\n      var offset = offsetRange[0],\n          _offsetRange$ = offsetRange[1],\n          startIndex = _offsetRange$.startIndex,\n          size = _offsetRange$.size;\n      return offset + (index - startIndex) * size;\n    } else {\n      throw new Error(\"Requested offset outside of the known ones, index: \" + index);\n    }\n  };\n\n  _proto.itemAt = function itemAt(index) {\n    var size = this.rangeTree.findMaxValue(index);\n    return {\n      index: index,\n      size: size,\n      offset: NaN\n    };\n  };\n\n  _proto.indexRange = function indexRange(startIndex, endIndex) {\n    if (this.rangeTree.empty()) {\n      return [{\n        index: this.initialTopMostItemIndex,\n        size: 0,\n        offset: NaN\n      }];\n    }\n\n    var ranges = this.rangeTree.rangesWithin(startIndex, endIndex);\n    var result = [];\n\n    for (var _iterator5 = _createForOfIteratorHelperLoose(ranges), _step5; !(_step5 = _iterator5()).done;) {\n      var range = _step5.value;\n      var start = Math.max(startIndex, range.start);\n      var rangeEnd = typeof range.end === 'undefined' ? Infinity : range.end;\n      var end = Math.min(endIndex, rangeEnd);\n\n      for (var i = start; i <= end; i++) {\n        result.push({\n          index: i,\n          size: range.value,\n          offset: NaN\n        });\n      }\n    }\n\n    return result;\n  };\n\n  _proto.range = function range(startOffset, endOffset, minIndex, maxIndex) {\n    if (minIndex === void 0) {\n      minIndex = 0;\n    }\n\n    if (maxIndex === void 0) {\n      maxIndex = Infinity;\n    }\n\n    if (this.offsetTree.empty()) {\n      return [{\n        index: this.initialTopMostItemIndex,\n        size: 0,\n        offset: 0\n      }];\n    }\n\n    var ranges = this.offsetTree.rangesWithin(startOffset, endOffset);\n    var result = [];\n\n    for (var _iterator6 = _createForOfIteratorHelperLoose(ranges), _step6; !(_step6 = _iterator6()).done;) {\n      var _step6$value = _step6.value,\n          rangeOffset = _step6$value.start,\n          _step6$value$value = _step6$value.value,\n          rangeIndex = _step6$value$value.startIndex,\n          endIndex = _step6$value$value.endIndex,\n          size = _step6$value$value.size;\n      var offset = rangeOffset;\n      var startIndex = rangeIndex;\n\n      if (rangeOffset < startOffset) {\n        startIndex += Math.floor((startOffset - rangeOffset) / size);\n        offset += (startIndex - rangeIndex) * size;\n      }\n\n      if (startIndex < minIndex) {\n        offset += (minIndex - startIndex) * size;\n        startIndex = minIndex;\n      } // we don't know the size of this range - terminate with a probe item\n\n\n      if (isNaN(size)) {\n        result.push({\n          index: startIndex,\n          size: 0,\n          offset: offset\n        });\n        return result;\n      }\n\n      endIndex = Math.min(endIndex, maxIndex);\n\n      for (var i = startIndex; i <= endIndex; i++) {\n        if (offset > endOffset) {\n          break;\n        }\n\n        result.push({\n          index: i,\n          size: size,\n          offset: offset\n        });\n        offset += size;\n      }\n    }\n\n    return result;\n  };\n\n  _proto.total = function total(endIndex) {\n    var ranges = this.rangeTree.rangesWithin(0, endIndex);\n    var total = 0;\n\n    for (var _iterator7 = _createForOfIteratorHelperLoose(ranges), _step7; !(_step7 = _iterator7()).done;) {\n      var _step7$value = _step7.value,\n          start = _step7$value.start,\n          end = _step7$value.end,\n          size = _step7$value.value;\n      end = Math.min(end, endIndex);\n      total += (end - start + 1) * (isNaN(size) ? 0 : size);\n    }\n\n    return total;\n  };\n\n  _proto.getOffsets = function getOffsets(indices) {\n    var _this = this;\n\n    var tree = AATree.empty();\n    indices.forEach(function (index) {\n      var offset = _this.offsetOf(index);\n\n      tree = tree.insert(offset, index);\n    });\n    return new IndexList(tree);\n  };\n\n  _proto.setInitialIndex = function setInitialIndex(topMostItemIndex) {\n    return new OffsetList(this.rangeTree, this.offsetTree, this.nanIndices, topMostItemIndex);\n  };\n\n  _proto.getDefaultSize = function getDefaultSize() {\n    return this.rangeTree.findMaxValue(Infinity);\n  };\n\n  _proto.adjustForPrependedItems = function adjustForPrependedItems(count) {\n    return this.fromTree(this.rangeTree.shift(count));\n  };\n\n  _proto.configureMaxRangeSize = function configureMaxRangeSize(maxRangeSize, maxRangeSizeExceededCallback) {\n    this.maxRangeSize = maxRangeSize;\n    this.rangeSizeExceededCallback = maxRangeSizeExceededCallback;\n  };\n\n  return OffsetList;\n}();\n\nvar IndexList = /*#__PURE__*/function () {\n  function IndexList(tree) {\n    this.tree = tree;\n  }\n\n  var _proto2 = IndexList.prototype;\n\n  _proto2.findMaxValue = function findMaxValue(offset) {\n    return this.tree.findMaxValue(offset);\n  };\n\n  _proto2.empty = function empty() {\n    return this.tree.empty();\n  };\n\n  return IndexList;\n}();\n\nfunction initialItemCountEngine(_ref) {\n  var itemHeights$ = _ref.itemHeights$,\n      viewportHeight$ = _ref.viewportHeight$;\n  var initialItemCount$ = subject();\n  var pendingRenderAfterInitial$ = subject(false);\n  var unsubscribeInitial = initialItemCount$.subscribe(function (count) {\n    var dummyItemHeight = 30;\n    itemHeights$.next([{\n      start: 0,\n      end: 0,\n      size: dummyItemHeight\n    }]);\n    viewportHeight$.next(dummyItemHeight * count);\n    pendingRenderAfterInitial$.next(true);\n    unsubscribeInitial();\n  });\n  return {\n    initialItemCount$: initialItemCount$,\n    pendingRenderAfterInitial$: pendingRenderAfterInitial$\n  };\n}\n\nfunction stickyItemsEngine(_ref) {\n  var offsetList$ = _ref.offsetList$,\n      scrollTop$ = _ref.scrollTop$,\n      topList$ = _ref.topList$,\n      transposer$ = _ref.transposer$;\n  var stickyItems$ = subject([]);\n  var stickyItemsIndexList$ = combineLatest(offsetList$, stickyItems$).pipe(map(function (_ref2) {\n    var offsetList = _ref2[0],\n        stickyItems = _ref2[1];\n    return offsetList.getOffsets(stickyItems);\n  }));\n  combineLatest(offsetList$, stickyItemsIndexList$, scrollTop$).pipe(filter(function (params) {\n    return !params[1].empty() && !params[0].empty();\n  }), withLatestFrom(topList$, transposer$), map(function (_ref3) {\n    var _ref3$ = _ref3[0],\n        offsetList = _ref3$[0],\n        stickyItemsIndexList = _ref3$[1],\n        scrollTop = _ref3$[2],\n        topList = _ref3[1],\n        transposer = _ref3[2];\n    var currentStickyItem = stickyItemsIndexList.findMaxValue(Math.max(scrollTop, 0));\n\n    if (topList.length === 1 && topList[0].index === currentStickyItem) {\n      return topList;\n    }\n\n    var item = offsetList.itemAt(currentStickyItem);\n    return transposer.transpose([item]);\n  })).subscribe(topList$.next);\n  return {\n    stickyItems$: stickyItems$\n  };\n}\n\nfunction offsetListEngine(_ref) {\n  var totalCount = _ref.totalCount,\n      itemHeight = _ref.itemHeight,\n      defaultItemHeight = _ref.defaultItemHeight,\n      initialTopMostItemIndex = _ref.initialTopMostItemIndex,\n      viewportHeight$ = _ref.viewportHeight$,\n      scrollTop$ = _ref.scrollTop$,\n      topList$ = _ref.topList$,\n      transposer$ = _ref.transposer$;\n  var headerHeight$ = subject(0);\n  var footerHeight$ = subject(0);\n  var totalCount$ = subject(totalCount);\n  var itemHeights$ = subject();\n\n  var _initialItemCountEngi = initialItemCountEngine({\n    itemHeights$: itemHeights$,\n    viewportHeight$: viewportHeight$\n  }),\n      pendingRenderAfterInitial$ = _initialItemCountEngi.pendingRenderAfterInitial$,\n      initialItemCount$ = _initialItemCountEngi.initialItemCount$;\n\n  var heightsChanged$ = coldSubject();\n  var initialOffsetList = OffsetList.create();\n\n  if (itemHeight) {\n    initialOffsetList = initialOffsetList.insert(0, 0, itemHeight);\n  }\n\n  if (defaultItemHeight) {\n    initialOffsetList = initialOffsetList.insert(0, 0, defaultItemHeight);\n  }\n\n  if (initialTopMostItemIndex) {\n    initialOffsetList = initialOffsetList.setInitialIndex(initialTopMostItemIndex);\n  }\n\n  var offsetList$ = subject(initialOffsetList);\n\n  var _stickyItemsEngine = stickyItemsEngine({\n    offsetList$: offsetList$,\n    scrollTop$: scrollTop$,\n    topList$: topList$,\n    transposer$: transposer$\n  }),\n      stickyItems$ = _stickyItemsEngine.stickyItems$;\n\n  var totalHeight$ = combineLatest(offsetList$, totalCount$, headerHeight$, footerHeight$).pipe(map(function (_ref2) {\n    var offsetList = _ref2[0],\n        totalCount = _ref2[1],\n        headerHeight = _ref2[2],\n        footerHeight = _ref2[3];\n    return offsetList.total(totalCount - 1) + headerHeight + footerHeight;\n  }));\n\n  if (!itemHeight) {\n    itemHeights$.pipe(withLatestFrom(offsetList$, stickyItems$, pendingRenderAfterInitial$)).subscribe(function (_ref3) {\n      var heights = _ref3[0],\n          offsetList = _ref3[1],\n          stickyItems = _ref3[2],\n          pendingRenderAfterInitial = _ref3[3];\n      var newList = offsetList;\n\n      if (pendingRenderAfterInitial) {\n        newList = OffsetList.create();\n        pendingRenderAfterInitial = false;\n      }\n\n      for (var _iterator = _createForOfIteratorHelperLoose(heights), _step; !(_step = _iterator()).done;) {\n        var _step$value = _step.value,\n            start = _step$value.start,\n            end = _step$value.end,\n            size = _step$value.size;\n\n        if (newList.empty() && start === end && stickyItems.indexOf(start) > -1) {\n          newList = newList.insertSpots(stickyItems, size);\n        } else {\n          newList = newList.insert(start, end, size);\n        }\n      }\n\n      if (newList !== offsetList) {\n        offsetList$.next(newList);\n        heightsChanged$.next([true, newList]);\n      } else {\n        heightsChanged$.next([false, newList]);\n      }\n    });\n  }\n\n  return {\n    totalCount$: totalCount$,\n    offsetList$: offsetList$,\n    totalHeight$: totalHeight$,\n    headerHeight$: headerHeight$,\n    footerHeight$: footerHeight$,\n    initialItemCount$: initialItemCount$,\n    itemHeights$: itemHeights$,\n    stickyItems$: stickyItems$,\n    heightsChanged$: heightsChanged$\n  };\n}\n\nfunction scrolledToBottomEngine(_ref) {\n  var totalHeight$ = _ref.totalHeight$,\n      viewportHeight$ = _ref.viewportHeight$,\n      scrollTop$ = _ref.scrollTop$;\n  var scrolledToBottom$ = subject(false);\n  var notAtBottom;\n  combineLatest(scrollTop$, viewportHeight$, totalHeight$).pipe(map(function (_ref2) {\n    var scrollTop = _ref2[0],\n        viewportHeight = _ref2[1],\n        totalHeight = _ref2[2];\n    if (viewportHeight === 0) return false;\n    return totalHeight - viewportHeight - scrollTop <= 1 || totalHeight <= viewportHeight;\n  })).subscribe(function (value) {\n    clearTimeout(notAtBottom);\n\n    if (!value) {\n      notAtBottom = setTimeout(function () {\n        return scrolledToBottom$.next(false);\n      });\n    } else {\n      scrolledToBottom$.next(true);\n    }\n  });\n  return {\n    scrolledToBottom$: scrolledToBottom$\n  };\n}\n\nfunction scrollSeekEngine(_ref) {\n  var isScrolling$ = _ref.isScrolling$,\n      scrollTop$ = _ref.scrollTop$,\n      range$ = _ref.rangeChanged$;\n  var scrollVelocity$ = subject(0);\n  var isSeeking$ = subject(false);\n  var scrollSeekConfiguration$ = subject(false);\n  isScrolling$.pipe(filter(function (val) {\n    return !val;\n  }), mapTo(0)).subscribe(scrollVelocity$.next);\n  scrollTop$.pipe(throttleTime(100), scan(function (_ref2, next) {\n    var prev = _ref2[1];\n    return [prev, next];\n  }, [0, 0]), map(function (_ref3) {\n    var prev = _ref3[0],\n        next = _ref3[1];\n    return next - prev;\n  })).subscribe(scrollVelocity$.next);\n  scrollVelocity$.pipe(withLatestFrom(scrollSeekConfiguration$, isSeeking$, range$), filter(function (_ref4) {\n    var config = _ref4[1];\n    return !!config;\n  }), map(function (_ref5) {\n    var speed = _ref5[0],\n        config = _ref5[1],\n        isSeeking = _ref5[2],\n        range = _ref5[3];\n    var exit = config.exit,\n        enter = config.enter;\n\n    if (isSeeking) {\n      if (exit(speed, range)) {\n        return false;\n      }\n    } else {\n      if (enter(speed, range)) {\n        return true;\n      }\n    }\n\n    return isSeeking;\n  }), duc()).subscribe(isSeeking$.next);\n  combineLatest(isSeeking$, scrollVelocity$, range$).pipe(withLatestFrom(scrollSeekConfiguration$)).subscribe(function (_ref6) {\n    var _ref6$ = _ref6[0],\n        isSeeking = _ref6$[0],\n        velocity = _ref6$[1],\n        range = _ref6$[2],\n        config = _ref6[1];\n    return isSeeking && config && config.change(velocity, range);\n  });\n  return {\n    isSeeking$: isSeeking$,\n    scrollSeekConfiguration$: scrollSeekConfiguration$,\n    scrollVelocity$: scrollVelocity$\n  };\n}\n\nfunction initialTopMostItemIndexEngine(_ref) {\n  var initialTopMostItemIndex = _ref.initialTopMostItemIndex,\n      scrollToIndex$ = _ref.scrollToIndex$,\n      scrollTop$ = _ref.scrollTop$,\n      scrollTo$ = _ref.scrollTo$,\n      offsetList$ = _ref.offsetList$;\n  var scrolledToTopMostItem$ = subject(!initialTopMostItemIndex);\n  scrollTop$.pipe(withLatestFrom(scrollTo$, scrolledToTopMostItem$)).subscribe(function (_ref2) {\n    var scrollTop = _ref2[0],\n        scrollTo = _ref2[1],\n        scrolledToTopMostItem = _ref2[2];\n\n    if (scrollTop === scrollTo.top && !scrolledToTopMostItem) {\n      // skip a tick, so that the list$ can grab the scrollTop$ update\n      setTimeout(function () {\n        scrolledToTopMostItem$.next(true);\n      });\n    }\n  });\n  offsetList$.pipe(withLatestFrom(scrolledToTopMostItem$)).subscribe(function (_ref3) {\n    var scrolledToTopMostItem = _ref3[1];\n\n    if (!scrolledToTopMostItem) {\n      // hack: wait for the viewport to get populated :(\n      setTimeout(function () {\n        scrollToIndex$.next(initialTopMostItemIndex);\n      });\n    }\n  });\n  return {\n    scrolledToTopMostItem$: scrolledToTopMostItem$\n  };\n}\n\nfunction scrollToIndexEngine(_ref) {\n  var offsetList$ = _ref.offsetList$,\n      topListHeight$ = _ref.topListHeight$,\n      stickyItems$ = _ref.stickyItems$,\n      viewportHeight$ = _ref.viewportHeight$,\n      totalCount$ = _ref.totalCount$,\n      totalHeight$ = _ref.totalHeight$,\n      initialTopMostItemIndex = _ref.initialTopMostItemIndex,\n      heightsChanged$ = _ref.heightsChanged$,\n      scrollTop$ = _ref.scrollTop$;\n  var scrollToIndex$ = coldSubject();\n  var scrollToIndexRequestPending$ = subject(false);\n  var scrollTopReportedAfterScrollToIndex$ = subject(true);\n  var scrollTo$ = coldSubject();\n\n  var _initialTopMostItemIn = initialTopMostItemIndexEngine({\n    scrollTo$: scrollTo$,\n    offsetList$: offsetList$,\n    scrollToIndex$: scrollToIndex$,\n    scrollTop$: scrollTop$,\n    initialTopMostItemIndex: initialTopMostItemIndex\n  }),\n      scrolledToTopMostItem$ = _initialTopMostItemIn.scrolledToTopMostItem$;\n\n  heightsChanged$.pipe(withLatestFrom(scrolledToTopMostItem$)).subscribe(function (_ref2) {\n    var _ref2$ = _ref2[0],\n        changed = _ref2$[0],\n        scrolledToTopMostItem = _ref2[1];\n\n    if (!changed && scrolledToTopMostItem) {\n      scrollToIndexRequestPending$.next(false);\n      scrollTopReportedAfterScrollToIndex$.next(true);\n    }\n  });\n  scrollToIndex$.pipe(withLatestFrom(offsetList$, topListHeight$, stickyItems$, viewportHeight$, totalCount$, totalHeight$), map(function (_ref3) {\n    var _location$behavior;\n\n    var location = _ref3[0],\n        offsetList = _ref3[1],\n        topListHeight = _ref3[2],\n        stickyItems = _ref3[3],\n        viewportHeight = _ref3[4],\n        totalCount = _ref3[5],\n        totalHeight = _ref3[6];\n\n    if (offsetList.empty()) {\n      setTimeout(function () {\n        return scrollToIndex$.next(location);\n      });\n      return;\n    }\n\n    if (typeof location === 'number') {\n      location = {\n        index: location,\n        align: 'start',\n        behavior: 'auto'\n      };\n    }\n\n    var _location = location,\n        index = _location.index,\n        _location$align = _location.align,\n        align = _location$align === void 0 ? 'start' : _location$align;\n    index = Math.max(0, index, Math.min(totalCount - 1, index));\n    var offset = offsetList.offsetOf(index);\n\n    if (align === 'end') {\n      offset = offset - viewportHeight + offsetList.itemAt(index).size;\n    } else if (align === 'center') {\n      offset = Math.round(offset - viewportHeight / 2 + offsetList.itemAt(index).size / 2);\n    } else {\n      if (stickyItems.indexOf(index) === -1) {\n        offset -= topListHeight;\n      }\n    }\n\n    scrollTopReportedAfterScrollToIndex$.next(false);\n    return {\n      top: Math.max(0, Math.min(offset, Math.floor(totalHeight - viewportHeight))),\n      behavior: (_location$behavior = location.behavior) !== null && _location$behavior !== void 0 ? _location$behavior : 'auto'\n    };\n  }), filter(function (value) {\n    return value !== undefined;\n  })).subscribe(scrollTo$.next);\n  scrollTop$.pipe(withLatestFrom(scrollTopReportedAfterScrollToIndex$)).subscribe(function (_ref4) {\n    var scrollTopReported = _ref4[1];\n\n    if (!scrollTopReported) {\n      scrollTopReportedAfterScrollToIndex$.next(true);\n      scrollToIndexRequestPending$.next(true);\n    }\n  }); // if the list has received new heights, the scrollTo call calculations were wrong;\n  // we will retry by re-requesting the same index\n\n  offsetList$.pipe(withLatestFrom(scrollToIndexRequestPending$, scrollToIndex$)).subscribe(function (_ref5) {\n    var scrollToIndexRequestPending = _ref5[1],\n        scrollToIndex = _ref5[2];\n\n    if (scrollToIndexRequestPending) {\n      scrollToIndex$.next(scrollToIndex);\n    }\n  });\n  return {\n    scrollToIndex$: scrollToIndex$,\n    scrollTo$: scrollTo$,\n    scrolledToTopMostItem$: scrolledToTopMostItem$\n  };\n}\n\nfunction topItemCountEngine(_ref) {\n  var topList$ = _ref.topList$,\n      transposer$ = _ref.transposer$,\n      viewportHeight$ = _ref.viewportHeight$,\n      totalCount$ = _ref.totalCount$,\n      offsetList$ = _ref.offsetList$;\n  var topItemCount$ = subject();\n  combineLatest(offsetList$, topItemCount$, totalCount$, viewportHeight$).pipe(filter(function (params) {\n    return params[1] > 0 && params[3] > 0;\n  }), withLatestFrom(transposer$), map(function (_ref2) {\n    var _ref2$ = _ref2[0],\n        offsetList = _ref2$[0],\n        topItemCount = _ref2$[1],\n        totalCount = _ref2$[2],\n        transposer = _ref2[1];\n    var endIndex = Math.max(0, Math.min(topItemCount - 1, totalCount));\n    return transposer.transpose(offsetList.indexRange(0, endIndex));\n  })).subscribe(topList$.next);\n  return {\n    topItemCount$: topItemCount$\n  };\n}\n\nfunction topListEngine() {\n  var topList$ = subject([]);\n  var topListHeight$ = topList$.pipe(map(function (items) {\n    return items.reduce(function (total, item) {\n      return total + item.size;\n    }, 0);\n  }));\n  var minListIndex$ = topList$.pipe(map(function (topList) {\n    return topList.length && topList[topList.length - 1].index + 1;\n  }));\n  return {\n    topList$: topList$,\n    topListHeight$: topListHeight$,\n    minListIndex$: minListIndex$\n  };\n}\n\nfunction makeOutput(observable) {\n  var unsubscribe;\n  return function (callback) {\n    if (unsubscribe) {\n      unsubscribe();\n    }\n\n    if (callback) {\n      unsubscribe = observable.subscribe(callback);\n    }\n  };\n}\n\nfunction makeInput(subject) {\n  return subject.next;\n}\n\nvar VirtuosoStore = function VirtuosoStore(_ref) {\n  var _ref$overscan = _ref.overscan,\n      overscan = _ref$overscan === void 0 ? 0 : _ref$overscan,\n      _ref$totalCount = _ref.totalCount,\n      totalCount = _ref$totalCount === void 0 ? 0 : _ref$totalCount,\n      itemHeight = _ref.itemHeight,\n      initialTopMostItemIndex = _ref.initialTopMostItemIndex,\n      defaultItemHeight = _ref.defaultItemHeight;\n  var transposer$ = subject(new StubIndexTransposer());\n  var viewportHeight$ = subject(0);\n  var scrollTop$ = subject(0, false);\n  var isScrolling$ = buildIsScrolling(scrollTop$);\n\n  var _topListEngine = topListEngine(),\n      topList$ = _topListEngine.topList$,\n      minListIndex$ = _topListEngine.minListIndex$,\n      topListHeight$ = _topListEngine.topListHeight$;\n\n  var _offsetListEngine = offsetListEngine({\n    totalCount: totalCount,\n    itemHeight: itemHeight,\n    defaultItemHeight: defaultItemHeight,\n    initialTopMostItemIndex: initialTopMostItemIndex,\n    viewportHeight$: viewportHeight$,\n    scrollTop$: scrollTop$,\n    transposer$: transposer$,\n    topList$: topList$\n  }),\n      stickyItems$ = _offsetListEngine.stickyItems$,\n      initialItemCount$ = _offsetListEngine.initialItemCount$,\n      itemHeights$ = _offsetListEngine.itemHeights$,\n      offsetList$ = _offsetListEngine.offsetList$,\n      totalCount$ = _offsetListEngine.totalCount$,\n      headerHeight$ = _offsetListEngine.headerHeight$,\n      footerHeight$ = _offsetListEngine.footerHeight$,\n      totalHeight$ = _offsetListEngine.totalHeight$,\n      heightsChanged$ = _offsetListEngine.heightsChanged$;\n\n  var _groupCountEngine = groupCountEngine({\n    totalCount$: totalCount$,\n    transposer$: transposer$,\n    stickyItems$: stickyItems$\n  }),\n      groupCounts$ = _groupCountEngine.groupCounts$,\n      groupIndices$ = _groupCountEngine.groupIndices$;\n\n  var _scrolledToBottomEngi = scrolledToBottomEngine({\n    totalHeight$: totalHeight$,\n    viewportHeight$: viewportHeight$,\n    scrollTop$: scrollTop$\n  }),\n      scrolledToBottom$ = _scrolledToBottomEngi.scrolledToBottom$;\n\n  var _scrollToIndexEngine = scrollToIndexEngine({\n    initialTopMostItemIndex: initialTopMostItemIndex,\n    scrollTop$: scrollTop$,\n    offsetList$: offsetList$,\n    viewportHeight$: viewportHeight$,\n    totalHeight$: totalHeight$,\n    stickyItems$: stickyItems$,\n    totalCount$: totalCount$,\n    topListHeight$: topListHeight$,\n    heightsChanged$: heightsChanged$\n  }),\n      scrolledToTopMostItem$ = _scrollToIndexEngine.scrolledToTopMostItem$,\n      scrollToIndex$ = _scrollToIndexEngine.scrollToIndex$,\n      scrollTo$ = _scrollToIndexEngine.scrollTo$;\n\n  var _listEngine = listEngine({\n    overscan: overscan,\n    defaultItemHeight: defaultItemHeight,\n    viewportHeight$: viewportHeight$,\n    scrollTop$: scrollTop$,\n    totalHeight$: totalHeight$,\n    topListHeight$: topListHeight$,\n    headerHeight$: headerHeight$,\n    footerHeight$: footerHeight$,\n    minListIndex$: minListIndex$,\n    totalCount$: totalCount$,\n    offsetList$: offsetList$,\n    scrolledToTopMostItem$: scrolledToTopMostItem$,\n    transposer$: transposer$\n  }),\n      listHeight$ = _listEngine.listHeight$,\n      list$ = _listEngine.list$,\n      listOffset$ = _listEngine.listOffset$,\n      startReached$ = _listEngine.startReached$,\n      endReached$ = _listEngine.endReached$;\n\n  var _adjustForPrependedIt = adjustForPrependedItemsEngine({\n    offsetList$: offsetList$,\n    scrollTop$: scrollTop$,\n    scrollTo$: scrollTo$\n  }),\n      adjustForPrependedItems$ = _adjustForPrependedIt.adjustForPrependedItems$,\n      adjustmentInProgress$ = _adjustForPrependedIt.adjustmentInProgress$;\n\n  var _maxRangeSizeEngine = maxRangeSizeEngine({\n    scrollTo$: scrollTo$,\n    offsetList$: offsetList$,\n    scrollTop$: scrollTop$,\n    list$: list$\n  }),\n      maxRangeSize$ = _maxRangeSizeEngine.maxRangeSize$;\n\n  var _topItemCountEngine = topItemCountEngine({\n    offsetList$: offsetList$,\n    totalCount$: totalCount$,\n    transposer$: transposer$,\n    viewportHeight$: viewportHeight$,\n    topList$: topList$\n  }),\n      topItemCount$ = _topItemCountEngine.topItemCount$;\n\n  var _followOutputEngine = followOutputEngine({\n    totalCount$: totalCount$,\n    scrollToIndex$: scrollToIndex$,\n    scrolledToBottom$: scrolledToBottom$\n  }),\n      followOutput$ = _followOutputEngine.followOutput$;\n\n  var stickyItemsOffset$ = listOffset$.pipe(map(function (offset) {\n    return -offset;\n  }));\n  var rangeChanged$ = coldSubject();\n  list$.pipe(withLatestFrom(adjustmentInProgress$), filter(function (_ref2) {\n    var list = _ref2[0],\n        inProgress = _ref2[1];\n    return list.length !== 0 && !inProgress;\n  }), map(function (_ref3) {\n    var list = _ref3[0];\n    var startIndex = list[0].index;\n    var endIndex = list[list.length - 1].index;\n    return {\n      startIndex: startIndex,\n      endIndex: endIndex\n    };\n  }), duc(function (current, next) {\n    return !current || current.startIndex !== next.startIndex || current.endIndex !== next.endIndex;\n  })).subscribe(rangeChanged$.next);\n\n  var _scrollSeekEngine = scrollSeekEngine({\n    scrollTop$: scrollTop$,\n    isScrolling$: isScrolling$,\n    rangeChanged$: rangeChanged$\n  }),\n      isSeeking$ = _scrollSeekEngine.isSeeking$,\n      scrollVelocity$ = _scrollSeekEngine.scrollVelocity$,\n      scrollSeekConfiguration$ = _scrollSeekEngine.scrollSeekConfiguration$;\n\n  var MAX_OFFSET_HEIGHT = 15000000;\n  var domTotalHeight$ = totalHeight$.pipe(map(function (value) {\n    return Math.min(value, MAX_OFFSET_HEIGHT);\n  }));\n  var scrollTopMultiplier$ = combineLatest(totalHeight$, domTotalHeight$, viewportHeight$).pipe(map(function (_ref4) {\n    var totalHeight = _ref4[0],\n        domTotalHeight = _ref4[1],\n        viewportHeight = _ref4[2];\n\n    if (totalHeight === domTotalHeight || domTotalHeight === viewportHeight) {\n      return 1;\n    }\n\n    return (totalHeight - viewportHeight) / (domTotalHeight - viewportHeight);\n  }));\n  var domScrollTop$ = subject(0, false);\n  var domListOffset$ = combineLatest(listOffset$, scrollTopMultiplier$).pipe(map(function (_ref5) {\n    var offset = _ref5[0],\n        multiplier = _ref5[1];\n    return offset / multiplier;\n  }));\n  combineLatest(domScrollTop$, scrollTopMultiplier$).pipe(map(function (_ref6) {\n    var domScrollTop = _ref6[0],\n        multiplier = _ref6[1];\n    return domScrollTop * multiplier;\n  })).subscribe(scrollTop$.next);\n  var computeItemKey$ = subject(function (itemIndex) {\n    return itemIndex;\n  });\n  var renderProp$ = subject(function (index, _groupIndex) {\n    return index;\n  });\n  var groupRenderProp$ = subject(function (index) {\n    return index;\n  });\n  var itemContainer$ = subject('div');\n  var groupContainer$ = subject('div');\n  var itemRender$ = subject(false);\n  var dataKey$ = subject(Symbol('data-key'));\n  combineLatest(renderProp$, groupRenderProp$, scrollSeekConfiguration$, computeItemKey$, itemContainer$, groupContainer$, dataKey$).pipe(map(function (_ref7) {\n    var _render = _ref7[0],\n        groupRender = _ref7[1],\n        scrollSeek = _ref7[2],\n        computeItemKey = _ref7[3],\n        ItemContainer = _ref7[4],\n        GroupContainer = _ref7[5];\n    return {\n      render: function render(item, _ref8) {\n        var key = _ref8.key,\n            renderPlaceholder = _ref8.renderPlaceholder,\n            itemProps = _objectWithoutPropertiesLoose(_ref8, [\"key\", \"renderPlaceholder\"]);\n\n        if (computeItemKey) {\n          key = computeItemKey(item.index);\n        }\n\n        if (item.type === 'group') {\n          return /*#__PURE__*/createElement(GroupContainer, _extends({\n            key: key\n          }, itemProps), groupRender(item.groupIndex));\n        } else {\n          var children;\n\n          if (scrollSeek && renderPlaceholder) {\n            children = /*#__PURE__*/createElement(scrollSeek.placeholder, {\n              height: itemProps['data-known-size'],\n              index: item.index\n            });\n          } else {\n            children = _render(item.transposedIndex, item.groupIndex);\n          }\n\n          return /*#__PURE__*/createElement(ItemContainer, _extends({}, itemProps, {\n            key: key\n          }), children);\n        }\n      }\n    };\n  })).subscribe(itemRender$.next);\n  return {\n    groupCounts: makeInput(groupCounts$),\n    itemHeights: makeInput(itemHeights$),\n    headerHeight: makeInput(headerHeight$),\n    footerHeight: makeInput(footerHeight$),\n    listHeight: makeInput(listHeight$),\n    viewportHeight: makeInput(viewportHeight$),\n    scrollTop: makeInput(domScrollTop$),\n    topItemCount: makeInput(topItemCount$),\n    totalCount: makeInput(totalCount$),\n    scrollToIndex: makeInput(scrollToIndex$),\n    initialItemCount: makeInput(initialItemCount$),\n    followOutput: makeInput(followOutput$),\n    adjustForPrependedItems: makeInput(adjustForPrependedItems$),\n    maxRangeSize: makeInput(maxRangeSize$),\n    scrollSeekConfiguration: makeInput(scrollSeekConfiguration$),\n    renderProp: makeInput(renderProp$),\n    groupRenderProp: makeInput(groupRenderProp$),\n    computeItemKey: makeInput(computeItemKey$),\n    itemContainer: makeInput(itemContainer$),\n    groupContainer: makeInput(groupContainer$),\n    dataKey: makeInput(dataKey$),\n    itemRender: makeOutput(itemRender$),\n    list: makeOutput(list$),\n    isSeeking: makeOutput(isSeeking$),\n    scrollVelocity: makeOutput(scrollVelocity$),\n    itemsRendered: makeOutput(list$),\n    topList: makeOutput(topList$),\n    listOffset: makeOutput(domListOffset$),\n    totalHeight: makeOutput(domTotalHeight$),\n    startReached: makeOutput(startReached$),\n    endReached: makeOutput(endReached$),\n    atBottomStateChange: makeOutput(scrolledToBottom$),\n    totalListHeightChanged: makeOutput(totalHeight$),\n    rangeChanged: makeOutput(rangeChanged$),\n    isScrolling: makeOutput(isScrolling$),\n    stickyItems: makeOutput(stickyItems$),\n    groupIndices: makeOutput(groupIndices$),\n    stickyItemsOffset: makeOutput(stickyItemsOffset$),\n    scrollTo: makeOutput(scrollTo$)\n  };\n};\n\n_c = VirtuosoStore;\nvar viewportStyle = {\n  top: 0,\n  position: 'absolute',\n  height: '100%',\n  width: '100%'\n};\n\nvar useHeight = function useHeight(input, onMount, onResize) {\n  _s();\n\n  var ref = useRef(null);\n  var animationFrameID = useRef(0);\n  var observer = new ResizeObserver(function (entries) {\n    var newHeight = Math.round(entries[0].contentRect.height);\n\n    if (onResize) {\n      animationFrameID.current = window.requestAnimationFrame(function () {\n        var element = entries[0].target;\n\n        if (document.body.contains(element)) {\n          onResize(element);\n        }\n      });\n    }\n\n    input(newHeight);\n  });\n\n  var callbackRef = function callbackRef(elRef) {\n    if (elRef) {\n      observer.observe(elRef);\n\n      if (onMount) {\n        onMount(elRef);\n      }\n\n      ref.current = elRef;\n    } else {\n      observer.unobserve(ref.current);\n      ref.current = null;\n    }\n  };\n\n  useEffect(function () {\n    return function () {\n      return window.cancelAnimationFrame(animationFrameID.current);\n    };\n  }, []);\n  return callbackRef;\n};\n\n_s(useHeight, \"puoG9tv4Z9hmvPZ8G7o8rFy8Qwg=\");\n\nfunction callbackToValue(output, defaultValue) {\n  return function () {\n    var result = defaultValue;\n    output(function (val) {\n      result = val;\n    });\n    return result;\n  };\n}\n\nfunction useOutput(output, initialValue) {\n  _s2();\n\n  var _useState = useState(callbackToValue(output, initialValue)),\n      value = _useState[0],\n      setValue = _useState[1];\n\n  useEffect(function () {\n    output(setValue);\n    return function () {\n      return output(undefined);\n    };\n  }, [output]);\n  return value;\n}\n\n_s2(useOutput, \"sRbj9bVXlAsV1qNHe72YrLCP8Tg=\");\n\nvar useSize = function useSize(callback) {\n  _s3();\n\n  var ref = useRef(null);\n  var currentSize = useRef([0, 0]);\n  var observer = new ResizeObserver(function (entries) {\n    var _entries$0$contentRec = entries[0].contentRect,\n        width = _entries$0$contentRec.width,\n        height = _entries$0$contentRec.height;\n\n    if (currentSize.current[0] !== width || currentSize.current[1] !== height) {\n      currentSize.current = [width, height];\n      callback({\n        element: entries[0].target,\n        width: Math.round(width),\n        height: Math.round(height)\n      });\n    }\n  });\n\n  var callbackRef = function callbackRef(elRef) {\n    if (elRef) {\n      observer.observe(elRef);\n      ref.current = elRef;\n    } else {\n      observer.unobserve(ref.current);\n      ref.current = null;\n    }\n  };\n\n  return callbackRef;\n};\n\n_s3(useSize, \"F41mqVwDea8NLQ3DX5Z1f1uUVJ0=\");\n\nfunction simpleMemoize(func) {\n  var called = false;\n  var result;\n  return function () {\n    if (!called) {\n      called = true;\n      result = func();\n    }\n\n    return result;\n  };\n}\n\nvar WEBKIT_STICKY = '-webkit-sticky';\nvar STICKY = 'sticky';\nvar positionStickyCssValue = /*#__PURE__*/simpleMemoize(function () {\n  var node = document.createElement('div');\n  node.style.position = WEBKIT_STICKY;\n  return node.style.position === WEBKIT_STICKY ? WEBKIT_STICKY : STICKY;\n});\n\nvar VirtuosoFiller = function VirtuosoFiller(_ref) {\n  var height = _ref.height;\n  return /*#__PURE__*/createElement(\"div\", {\n    style: {\n      height: height + \"px\",\n      position: 'absolute',\n      top: 0\n    }\n  }, \"\\xA0\");\n};\n\n_c2 = VirtuosoFiller;\nvar VirtuosoList = /*#__PURE__*/memo(_c3 = _s4(function (_ref) {\n  _s4();\n\n  var emptyComponent = _ref.emptyComponent;\n\n  var _useContext = useContext(VirtuosoContext),\n      isSeeking = _useContext.isSeeking,\n      topList = _useContext.topList,\n      list = _useContext.list,\n      itemRender = _useContext.itemRender;\n\n  var items = useOutput(list, []);\n  var topItems = useOutput(topList, []);\n  var render = useOutput(itemRender, false);\n  var renderPlaceholder = useOutput(isSeeking, false);\n  var renderedItems = [];\n  var topOffset = 0;\n  var renderedTopItemIndices = [];\n  var marginTop = topItems.reduce(function (acc, item) {\n    return acc + item.size;\n  }, 0);\n  topItems.forEach(function (item, index) {\n    var itemIndex = item.index;\n    renderedTopItemIndices.push(itemIndex);\n    var style = {\n      top: topOffset + \"px\",\n      marginTop: index === 0 ? -marginTop + \"px\" : undefined,\n      zIndex: 2,\n      position: positionStickyCssValue()\n    };\n    var props = {\n      key: itemIndex,\n      'data-index': itemIndex,\n      'data-known-size': item.size,\n      renderPlaceholder: renderPlaceholder,\n      style: style\n    };\n    render && renderedItems.push(render.render(item, props));\n    topOffset += item.size;\n  });\n  items.forEach(function (item) {\n    if (renderedTopItemIndices.indexOf(item.index) > -1) {\n      return;\n    }\n\n    render && renderedItems.push(render.render(item, {\n      key: item.index,\n      'data-index': item.index,\n      'data-known-size': item.size,\n      renderPlaceholder: renderPlaceholder\n    }));\n  });\n  if (renderedItems.length === 0 && emptyComponent) return /*#__PURE__*/createElement(emptyComponent);\n  return /*#__PURE__*/createElement(Fragment, null, renderedItems);\n}, \"9hIKT+OIczdyqeG1KlHoAZSac0Y=\", false, function () {\n  return [useOutput, useOutput, useOutput, useOutput];\n}));\n_c4 = VirtuosoList;\nvar scrollerStyle = {\n  height: '100%',\n  overflowY: 'auto',\n  WebkitOverflowScrolling: 'touch',\n  position: 'relative',\n  outline: 'none'\n};\n\nvar DefaultScrollContainer = function DefaultScrollContainer(_ref) {\n  _s5();\n\n  var className = _ref.className,\n      style = _ref.style,\n      reportScrollTop = _ref.reportScrollTop,\n      scrollTo = _ref.scrollTo,\n      children = _ref.children;\n  var elRef = useRef(null);\n  var smoothScrollTarget = useRef(null);\n  var currentScrollTop = useRef();\n  var onScroll = useCallback(function (e) {\n    var scrollTop = e.target.scrollTop;\n    currentScrollTop.current = scrollTop;\n\n    if (smoothScrollTarget.current !== null) {\n      if (smoothScrollTarget.current === scrollTop) {\n        // console.log('reporting smooth scrolling')\n        smoothScrollTarget.current = null;\n        reportScrollTop(scrollTop);\n      }\n    } else {\n      reportScrollTop(scrollTop);\n    }\n  }, [reportScrollTop]);\n  var ref = useCallback(function (theRef) {\n    if (theRef) {\n      theRef.addEventListener('scroll', onScroll, {\n        passive: true\n      });\n      elRef.current = theRef;\n    } else {\n      if (elRef.current) {\n        elRef.current.removeEventListener('scroll', onScroll);\n      }\n    }\n  }, [onScroll]);\n  scrollTo(function (location) {\n    if (currentScrollTop.current !== location.top) {\n      if (location.behavior === 'smooth') {\n        smoothScrollTarget.current = location.top;\n      }\n\n      elRef.current && elRef.current.scrollTo(location);\n    }\n  });\n  return /*#__PURE__*/createElement(\"div\", {\n    ref: ref,\n    style: style,\n    tabIndex: 0,\n    className: className\n  }, children);\n};\n\n_s5(DefaultScrollContainer, \"HhjYX61oocuevEXX5jfRn9Q+TkE=\");\n\n_c5 = DefaultScrollContainer;\n\nvar VirtuosoScroller = function VirtuosoScroller(_ref2) {\n  var children = _ref2.children,\n      style = _ref2.style,\n      className = _ref2.className,\n      _ref2$ScrollContainer = _ref2.ScrollContainer,\n      ScrollContainer = _ref2$ScrollContainer === void 0 ? DefaultScrollContainer : _ref2$ScrollContainer,\n      scrollTop = _ref2.scrollTop,\n      scrollTo = _ref2.scrollTo;\n  return /*#__PURE__*/createElement(ScrollContainer, {\n    style: _extends({}, scrollerStyle, style),\n    reportScrollTop: scrollTop,\n    scrollTo: scrollTo,\n    className: className\n  }, children);\n};\n\n_c6 = VirtuosoScroller;\n\nvar DefaultHeaderContainer = function DefaultHeaderContainer(_ref) {\n  var children = _ref.children,\n      headerRef = _ref.headerRef;\n  return /*#__PURE__*/createElement(\"header\", {\n    ref: headerRef\n  }, children);\n};\n\n_c7 = DefaultHeaderContainer;\n\nvar DefaultFooterContainer = function DefaultFooterContainer(_ref2) {\n  var children = _ref2.children,\n      footerRef = _ref2.footerRef;\n  return /*#__PURE__*/createElement(\"footer\", {\n    ref: footerRef\n  }, children);\n};\n\n_c8 = DefaultFooterContainer;\n\nvar DefaultListContainer = function DefaultListContainer(_ref3) {\n  var children = _ref3.children,\n      listRef = _ref3.listRef,\n      style = _ref3.style;\n  return /*#__PURE__*/createElement(\"div\", {\n    ref: listRef,\n    style: style\n  }, children);\n};\n\n_c9 = DefaultListContainer;\n\nvar VirtuosoHeader = function VirtuosoHeader(_ref4) {\n  _s6();\n\n  var header = _ref4.header,\n      _ref4$HeaderContainer = _ref4.HeaderContainer,\n      HeaderContainer = _ref4$HeaderContainer === void 0 ? DefaultHeaderContainer : _ref4$HeaderContainer;\n  var headerCallbackRef = useHeight(useContext(VirtuosoContext).headerHeight);\n  return /*#__PURE__*/createElement(HeaderContainer, {\n    headerRef: headerCallbackRef\n  }, header());\n};\n\n_s6(VirtuosoHeader, \"zDEFHknSIdzEGR3RBEkUNR6Fbx8=\", false, function () {\n  return [useHeight];\n});\n\n_c10 = VirtuosoHeader;\n\nvar VirtuosoFooter = function VirtuosoFooter(_ref5) {\n  _s7();\n\n  var footer = _ref5.footer,\n      _ref5$FooterContainer = _ref5.FooterContainer,\n      FooterContainer = _ref5$FooterContainer === void 0 ? DefaultFooterContainer : _ref5$FooterContainer;\n  var footerCallbackRef = useHeight(useContext(VirtuosoContext).footerHeight);\n  return /*#__PURE__*/createElement(FooterContainer, {\n    footerRef: footerCallbackRef\n  }, footer());\n};\n\n_s7(VirtuosoFooter, \"GrbuR8xNXvfb8mEfmNp6XIkSqg0=\", false, function () {\n  return [useHeight];\n});\n\n_c11 = VirtuosoFooter;\n\nvar getHeights = function getHeights(children) {\n  var results = [];\n\n  for (var i = 0, len = children.length; i < len; i++) {\n    var child = children.item(i);\n\n    if (!child || child.dataset.index === undefined) {\n      continue;\n    }\n\n    var index = parseInt(child.dataset.index);\n    var knownSize = parseInt(child.dataset.knownSize);\n    var size = child.offsetHeight;\n\n    if (size === knownSize || size === 0) {\n      continue;\n    }\n\n    var lastResult = results[results.length - 1];\n\n    if (results.length === 0 || lastResult.size !== size || lastResult.end !== index - 1) {\n      results.push({\n        start: index,\n        end: index,\n        size: size\n      });\n    } else {\n      results[results.length - 1].end++;\n    }\n  }\n\n  return results;\n};\n\nvar ListWrapper = function ListWrapper(_ref6) {\n  _s8();\n\n  var fixedItemHeight = _ref6.fixedItemHeight,\n      children = _ref6.children,\n      ListContainer = _ref6.ListContainer;\n\n  var _useContext = useContext(VirtuosoContext),\n      listHeight = _useContext.listHeight,\n      itemHeights = _useContext.itemHeights,\n      listOffset = _useContext.listOffset;\n\n  var translate = useOutput(listOffset, 0);\n  var style = {\n    marginTop: translate + \"px\"\n  };\n  var listCallbackRef = useHeight(listHeight, function () {}, function (ref) {\n    if (!fixedItemHeight) {\n      var measuredItemHeights = getHeights(ref.children);\n      itemHeights(measuredItemHeights);\n    }\n  });\n  return /*#__PURE__*/createElement(ListContainer, {\n    listRef: listCallbackRef,\n    style: style\n  }, children);\n};\n\n_s8(ListWrapper, \"hthYmu39ha5nEhF8WaKrxHFqPlM=\", false, function () {\n  return [useOutput, useHeight];\n});\n\n_c12 = ListWrapper;\n\nvar VirtuosoView = function VirtuosoView(_ref7) {\n  _s9();\n\n  var style = _ref7.style,\n      header = _ref7.header,\n      footer = _ref7.footer,\n      fixedItemHeight = _ref7.fixedItemHeight,\n      ScrollContainer = _ref7.ScrollContainer,\n      ListContainer = _ref7.ListContainer,\n      HeaderContainer = _ref7.HeaderContainer,\n      FooterContainer = _ref7.FooterContainer,\n      className = _ref7.className,\n      emptyComponent = _ref7.emptyComponent;\n\n  var _useContext2 = useContext(VirtuosoContext),\n      scrollTo = _useContext2.scrollTo,\n      scrollTop = _useContext2.scrollTop,\n      totalHeight = _useContext2.totalHeight,\n      viewportHeight = _useContext2.viewportHeight;\n\n  var fillerHeight = useOutput(totalHeight, 0);\n\n  var reportScrollTop = function reportScrollTop(st) {\n    scrollTop(Math.max(st, 0));\n  };\n\n  var viewportCallbackRef = useHeight(viewportHeight);\n  return /*#__PURE__*/createElement(VirtuosoScroller, {\n    style: style,\n    ScrollContainer: ScrollContainer,\n    className: className,\n    scrollTo: scrollTo,\n    scrollTop: reportScrollTop\n  }, /*#__PURE__*/createElement(\"div\", {\n    ref: viewportCallbackRef,\n    style: viewportStyle\n  }, /*#__PURE__*/createElement(ListWrapper, {\n    fixedItemHeight: fixedItemHeight,\n    ListContainer: ListContainer\n  }, header && /*#__PURE__*/createElement(VirtuosoHeader, {\n    header: header,\n    HeaderContainer: HeaderContainer\n  }), /*#__PURE__*/createElement(VirtuosoList, {\n    emptyComponent: emptyComponent\n  }), footer && /*#__PURE__*/createElement(VirtuosoFooter, {\n    footer: footer,\n    FooterContainer: FooterContainer\n  }))), /*#__PURE__*/createElement(VirtuosoFiller, {\n    height: fillerHeight\n  }));\n};\n\n_s9(VirtuosoView, \"4JTUKaHLLi3wjXWY9fupzKSbAOw=\", false, function () {\n  return [useOutput, useHeight];\n});\n\n_c13 = VirtuosoView;\nvar DEFAULT_STYLE = {};\nvar VirtuosoPresentation = /*#__PURE__*/memo(_c14 = function _c14(_ref) {\n  var contextValue = _ref.contextValue,\n      style = _ref.style,\n      className = _ref.className,\n      header = _ref.header,\n      footer = _ref.footer,\n      itemHeight = _ref.itemHeight,\n      ScrollContainer = _ref.ScrollContainer,\n      ListContainer = _ref.ListContainer,\n      HeaderContainer = _ref.HeaderContainer,\n      FooterContainer = _ref.FooterContainer,\n      emptyComponent = _ref.emptyComponent;\n  return /*#__PURE__*/createElement(VirtuosoContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/createElement(VirtuosoView, {\n    style: style || DEFAULT_STYLE,\n    className: className,\n    header: header,\n    footer: footer,\n    fixedItemHeight: itemHeight !== undefined,\n    ScrollContainer: ScrollContainer,\n    HeaderContainer: HeaderContainer,\n    FooterContainer: FooterContainer,\n    ListContainer: ListContainer || DefaultListContainer,\n    emptyComponent: emptyComponent\n  }));\n});\n_c15 = VirtuosoPresentation;\nvar Virtuoso = /*#__PURE__*/forwardRef(_c16 = _s10(function (props, ref) {\n  _s10();\n\n  var _useState = useState(function () {\n    return VirtuosoStore(props);\n  }),\n      state = _useState[0];\n\n  useImperativeHandle(ref, function () {\n    return {\n      scrollToIndex: function scrollToIndex(location) {\n        state.scrollToIndex(location);\n      },\n      adjustForPrependedItems: function adjustForPrependedItems(count) {\n        state.adjustForPrependedItems(count);\n      }\n    };\n  }, [state]);\n  useEffect(function () {\n    state.isScrolling(props.scrollingStateChange);\n    state.atBottomStateChange(props.atBottomStateChange);\n    state.startReached(props.startReached);\n    state.endReached(props.endReached);\n    state.topItemCount(props.topItems || 0);\n    state.totalCount(props.totalCount);\n    props.initialItemCount && state.initialItemCount(props.initialItemCount);\n    state.itemsRendered(props.itemsRendered);\n    state.totalListHeightChanged(props.totalListHeightChanged);\n    state.followOutput(!!props.followOutput);\n    state.maxRangeSize(props.maxHeightCacheSize || Infinity);\n    state.rangeChanged(props.rangeChanged);\n    state.scrollSeekConfiguration(props.scrollSeek);\n    state.computeItemKey(props.computeItemKey || function (key) {\n      return key;\n    });\n    state.itemContainer(props.ItemContainer || 'div');\n    state.renderProp(props.item);\n    state.dataKey(props.dataKey);\n    return function () {\n      state.itemsRendered(undefined);\n      state.totalListHeightChanged(undefined);\n    };\n  }, [state, props.scrollingStateChange, props.atBottomStateChange, props.startReached, props.endReached, props.topItems, props.totalCount, props.initialItemCount, props.itemsRendered, props.totalListHeightChanged, props.followOutput, props.maxHeightCacheSize, props.rangeChanged, props.scrollSeek, props.item, props.ItemContainer, props.computeItemKey, props.dataKey]);\n  return /*#__PURE__*/createElement(VirtuosoPresentation, {\n    contextValue: state,\n    style: props.style,\n    className: props.className,\n    header: props.header,\n    footer: props.footer,\n    itemHeight: props.itemHeight,\n    ScrollContainer: props.ScrollContainer,\n    HeaderContainer: props.HeaderContainer,\n    FooterContainer: props.FooterContainer,\n    ListContainer: props.ListContainer,\n    emptyComponent: props.emptyComponent\n  });\n}, \"2KiFOQz+VRjMWRDd49htDHvSU34=\", false, function () {\n  return [useImperativeHandle];\n}));\n_c17 = Virtuoso;\nVirtuoso.displayName = 'Virtuoso';\nvar GroupedVirtuoso = /*#__PURE__*/forwardRef(_c18 = _s11(function (props, ref) {\n  _s11();\n\n  var _useState = useState(VirtuosoStore(props)),\n      state = _useState[0];\n\n  useImperativeHandle(ref, function () {\n    return {\n      scrollToIndex: function scrollToIndex(location) {\n        state.scrollToIndex(location);\n      }\n    };\n  }, [state]);\n  useEffect(function () {\n    state.startReached(props.startReached);\n    state.endReached(props.endReached);\n    state.rangeChanged(props.rangeChanged);\n    state.atBottomStateChange(props.atBottomStateChange);\n    state.isScrolling(props.scrollingStateChange);\n    state.groupCounts(props.groupCounts);\n    state.groupIndices(props.groupIndices);\n    state.itemsRendered(props.itemsRendered);\n    state.totalListHeightChanged(props.totalListHeightChanged);\n    state.renderProp(props.item);\n    state.groupRenderProp(props.group);\n    state.itemContainer(props.ItemContainer || 'div');\n    state.groupContainer(props.GroupContainer || 'div');\n    state.scrollSeekConfiguration(props.scrollSeek);\n    return function () {\n      state.itemsRendered(undefined);\n      state.totalListHeightChanged(undefined);\n    };\n  }, [state, props.startReached, props.endReached, props.rangeChanged, props.atBottomStateChange, props.scrollingStateChange, props.groupCounts, props.groupIndices, props.itemsRendered, props.totalListHeightChanged, props.item, props.group, props.GroupContainer, props.ItemContainer, props.scrollSeek]);\n  return /*#__PURE__*/createElement(VirtuosoPresentation, {\n    contextValue: state,\n    style: props.style,\n    className: props.className,\n    header: props.header,\n    footer: props.footer,\n    itemHeight: props.itemHeight,\n    ScrollContainer: props.ScrollContainer,\n    HeaderContainer: props.HeaderContainer,\n    FooterContainer: props.FooterContainer,\n    ListContainer: props.ListContainer\n  });\n}, \"1MB4OQrxXzbaIp4f9lKPJnf6mXc=\", false, function () {\n  return [useImperativeHandle];\n}));\n_c19 = GroupedVirtuoso;\nGroupedVirtuoso.displayName = 'GroupedVirtuoso';\nvar ceil = Math.ceil,\n    floor = Math.floor,\n    min = Math.min,\n    max = Math.max;\n\nvar hackFloor = function hackFloor(val) {\n  return ceil(val) - val < 0.03 ? ceil(val) : floor(val);\n};\n\nvar VirtuosoGridEngine = function VirtuosoGridEngine(initialItemCount) {\n  if (initialItemCount === void 0) {\n    initialItemCount = 0;\n  }\n\n  var itemsRender = subject(false);\n  var gridDimensions$ = subject([0, 0, undefined, undefined, undefined, undefined]);\n  var totalCount$ = subject(0);\n  var scrollTop$ = subject(0);\n  var overscan$ = subject(0);\n  var itemRange$ = subject([0, max(initialItemCount - 1, 0)]);\n  var remainingHeight$ = subject(0);\n  var listOffset$ = subject(0);\n  var scrollToIndex$ = coldSubject();\n  var rangeChanged$ = coldSubject();\n  combineLatest(gridDimensions$, scrollTop$, overscan$, totalCount$).pipe(withLatestFrom(itemRange$)).subscribe(function (_ref) {\n    var _ref$ = _ref[0],\n        _ref$$ = _ref$[0],\n        viewportWidth = _ref$$[0],\n        viewportHeight = _ref$$[1],\n        itemWidth = _ref$$[2],\n        itemHeight = _ref$$[3],\n        scrollTop = _ref$[1],\n        overscan = _ref$[2],\n        totalCount = _ref$[3],\n        itemRange = _ref[1];\n\n    if (itemWidth === undefined || itemHeight === undefined) {\n      return;\n    }\n\n    if (totalCount === 0) {\n      itemRange$.next([0, -1]);\n      listOffset$.next(0);\n      rangeChanged$.next({\n        startIndex: 0,\n        endIndex: -1\n      });\n      return;\n    }\n\n    var startIndex = itemRange[0],\n        endIndex = itemRange[1];\n    var itemsPerRow = hackFloor(viewportWidth / itemWidth);\n\n    var toRowIndex = function toRowIndex(index, roundFunc) {\n      if (roundFunc === void 0) {\n        roundFunc = floor;\n      }\n\n      return roundFunc(index / itemsPerRow);\n    };\n\n    var updateRange = function updateRange(down) {\n      var _ref2 = down ? [0, overscan] : [overscan, 0],\n          topOverscan = _ref2[0],\n          bottomOverscan = _ref2[1];\n\n      var startIndex = itemsPerRow * floor((scrollTop - topOverscan) / itemHeight);\n      var endIndex = itemsPerRow * ceil((scrollTop + viewportHeight + bottomOverscan) / itemHeight) - 1;\n      endIndex = min(totalCount - 1, endIndex);\n      startIndex = min(endIndex, max(0, startIndex));\n      itemRange$.next([startIndex, endIndex]);\n      listOffset$.next(toRowIndex(startIndex) * itemHeight);\n      rangeChanged$.next({\n        startIndex: startIndex,\n        endIndex: endIndex\n      });\n    };\n\n    var listTop = itemHeight * toRowIndex(startIndex);\n    var listBottom = itemHeight * toRowIndex(endIndex) + itemHeight; // totalCount has decreased, we have to re-render\n\n    if (totalCount < endIndex - 1) {\n      updateRange(true); // user is scrolling up - list top is below the top edge of the viewport\n    } else if (listTop > scrollTop) {\n      updateRange(false); // user is scrolling down - list bottom is above the bottom edge of the viewport\n    } else if (listBottom < scrollTop + viewportHeight) {\n      updateRange(true);\n    }\n\n    remainingHeight$.next(itemHeight * toRowIndex(totalCount - endIndex - 1, ceil));\n  });\n  var scrollTo$ = scrollToIndex$.pipe(withLatestFrom(gridDimensions$, totalCount$), map(function (_ref3) {\n    var location = _ref3[0],\n        _ref3$ = _ref3[1],\n        viewportWidth = _ref3$[0],\n        viewportHeight = _ref3$[1],\n        itemWidth = _ref3$[2],\n        itemHeight = _ref3$[3],\n        totalCount = _ref3[2];\n\n    if (itemWidth === undefined || itemHeight === undefined) {\n      return {\n        top: 0,\n        behavior: 'auto'\n      };\n    }\n\n    if (typeof location === 'number') {\n      location = {\n        index: location,\n        align: 'start'\n      };\n    }\n\n    var _location = location,\n        index = _location.index,\n        _location$align = _location.align,\n        align = _location$align === void 0 ? 'start' : _location$align,\n        _location$behavior = _location.behavior,\n        behavior = _location$behavior === void 0 ? 'auto' : _location$behavior;\n    index = Math.max(0, index, Math.min(totalCount - 1, index));\n    var itemsPerRow = hackFloor(viewportWidth / itemWidth);\n    var offset = floor(index / itemsPerRow) * itemHeight;\n\n    if (align === 'end') {\n      offset = offset - viewportHeight + itemHeight;\n    } else if (align === 'center') {\n      offset = Math.round(offset - viewportHeight / 2 + itemHeight / 2);\n    }\n\n    return {\n      top: offset,\n      behavior: behavior\n    };\n  }));\n  var isScrolling$ = buildIsScrolling(scrollTop$);\n  var endReached$ = coldSubject();\n  var currentEndIndex = 0;\n  itemRange$.pipe(withLatestFrom(totalCount$)).subscribe(function (_ref4) {\n    var _ref4$ = _ref4[0],\n        endIndex = _ref4$[1],\n        totalCount = _ref4[1];\n\n    if (totalCount === 0) {\n      return;\n    }\n\n    if (endIndex === totalCount - 1) {\n      if (currentEndIndex !== endIndex) {\n        currentEndIndex = endIndex;\n        endReached$.next(endIndex);\n      }\n    }\n  });\n\n  var _scrollSeekEngine = scrollSeekEngine({\n    scrollTop$: scrollTop$,\n    isScrolling$: isScrolling$,\n    rangeChanged$: rangeChanged$\n  }),\n      isSeeking$ = _scrollSeekEngine.isSeeking$,\n      scrollSeekConfiguration$ = _scrollSeekEngine.scrollSeekConfiguration$;\n\n  combineLatest(itemRange$, isSeeking$, scrollSeekConfiguration$, gridDimensions$).pipe(map(function (_ref5) {\n    var _ref5$ = _ref5[0],\n        startIndex = _ref5$[0],\n        endIndex = _ref5$[1],\n        renderPlaceholder = _ref5[1],\n        scrollSeek = _ref5[2],\n        _ref5$2 = _ref5[3],\n        itemHeight = _ref5$2[5];\n\n    var render = function render(item, itemClassName, ItemContainer, computeItemKey) {\n      var items = [];\n\n      for (var index = startIndex; index <= endIndex; index++) {\n        var key = computeItemKey(index);\n        var children = void 0;\n\n        if (scrollSeek && renderPlaceholder && itemHeight) {\n          children = /*#__PURE__*/createElement(scrollSeek.placeholder, {\n            height: itemHeight,\n            index: index\n          });\n        } else {\n          children = item(index);\n        }\n\n        items.push( /*#__PURE__*/createElement(ItemContainer, {\n          key: key,\n          className: itemClassName\n        }, children));\n      }\n\n      return items;\n    };\n\n    return {\n      render: render\n    };\n  })).subscribe(itemsRender.next);\n  return {\n    gridDimensions: makeInput(gridDimensions$),\n    totalCount: makeInput(totalCount$),\n    scrollTop: makeInput(scrollTop$),\n    overscan: makeInput(overscan$),\n    scrollToIndex: makeInput(scrollToIndex$),\n    scrollSeekConfiguration: makeInput(scrollSeekConfiguration$),\n    itemsRender: makeOutput(itemsRender),\n    itemRange: makeOutput(itemRange$),\n    remainingHeight: makeOutput(remainingHeight$),\n    listOffset: makeOutput(listOffset$),\n    scrollTo: makeOutput(scrollTo$),\n    isScrolling: makeOutput(isScrolling$),\n    endReached: makeOutput(endReached$),\n    rangeChanged: makeOutput(rangeChanged$)\n  };\n};\n\n_c20 = VirtuosoGridEngine;\n\nvar VirtuosoGrid = /*#__PURE__*/function (_React$PureComponent) {\n  _inheritsLoose(VirtuosoGrid, _React$PureComponent);\n\n  function VirtuosoGrid() {\n    var _this;\n\n    _this = _React$PureComponent.apply(this, arguments) || this;\n    _this.state = VirtuosoGridEngine(_this.props.initialItemCount);\n    return _this;\n  }\n\n  VirtuosoGrid.getDerivedStateFromProps = function getDerivedStateFromProps(props, engine) {\n    engine.overscan(props.overscan || 0);\n    engine.totalCount(props.totalCount);\n    engine.isScrolling(props.scrollingStateChange);\n    engine.endReached(props.endReached);\n    engine.rangeChanged(props.rangeChanged);\n    engine.scrollSeekConfiguration(props.scrollSeek);\n    return null;\n  };\n\n  var _proto = VirtuosoGrid.prototype;\n\n  _proto.scrollToIndex = function scrollToIndex(location) {\n    this.state.scrollToIndex(location);\n  };\n\n  _proto.render = function render() {\n    return /*#__PURE__*/createElement(VirtuosoGridFC, Object.assign({}, this.props, {\n      engine: this.state\n    }));\n  };\n\n  return VirtuosoGrid;\n}(PureComponent);\n\nvar VirtuosoGridFC = function VirtuosoGridFC(_ref) {\n  _s12();\n\n  var ScrollContainer = _ref.ScrollContainer,\n      _ref$ItemContainer = _ref.ItemContainer,\n      ItemContainer = _ref$ItemContainer === void 0 ? 'div' : _ref$ItemContainer,\n      _ref$ListContainer = _ref.ListContainer,\n      ListContainer = _ref$ListContainer === void 0 ? 'div' : _ref$ListContainer,\n      className = _ref.className,\n      item = _ref.item,\n      _ref$itemClassName = _ref.itemClassName,\n      itemClassName = _ref$itemClassName === void 0 ? 'virtuoso-grid-item' : _ref$itemClassName,\n      _ref$listClassName = _ref.listClassName,\n      listClassName = _ref$listClassName === void 0 ? 'virtuoso-grid-list' : _ref$listClassName,\n      engine = _ref.engine,\n      _ref$style = _ref.style,\n      style = _ref$style === void 0 ? {\n    height: '100%'\n  } : _ref$style,\n      _ref$computeItemKey = _ref.computeItemKey,\n      computeItemKey = _ref$computeItemKey === void 0 ? function (key) {\n    return key;\n  } : _ref$computeItemKey;\n  var listOffset = engine.listOffset,\n      remainingHeight = engine.remainingHeight,\n      gridDimensions = engine.gridDimensions,\n      scrollTo = engine.scrollTo,\n      scrollTop = engine.scrollTop,\n      itemsRender = engine.itemsRender;\n  var fillerHeight = useOutput(remainingHeight, 0);\n  var translate = useOutput(listOffset, 0);\n  var listStyle = {\n    paddingTop: translate + \"px\",\n    paddingBottom: fillerHeight + \"px\"\n  };\n  var render = useOutput(itemsRender, false);\n  var viewportCallbackRef = useSize(function (_ref2) {\n    var element = _ref2.element,\n        width = _ref2.width,\n        height = _ref2.height;\n    var firstItem = element.firstChild.firstChild;\n    var firstItemContent = firstItem.firstChild;\n    gridDimensions([width, height, firstItem.offsetWidth, firstItem.offsetHeight, firstItemContent.offsetWidth, firstItemContent.offsetHeight]);\n  });\n  return /*#__PURE__*/createElement(VirtuosoScroller, {\n    style: style,\n    ScrollContainer: ScrollContainer,\n    className: className,\n    scrollTo: scrollTo,\n    scrollTop: scrollTop\n  }, /*#__PURE__*/createElement(\"div\", {\n    ref: viewportCallbackRef,\n    style: viewportStyle\n  }, /*#__PURE__*/createElement(ListContainer, {\n    style: listStyle,\n    className: listClassName\n  }, render.render(item, itemClassName, ItemContainer, computeItemKey))));\n};\n\n_s12(VirtuosoGridFC, \"EZWbRkl4IciFf/CHQpv8P2X/Vjo=\", false, function () {\n  return [useOutput, useOutput, useOutput, useSize];\n});\n\n_c21 = VirtuosoGridFC;\nexport { GroupedVirtuoso, Virtuoso, VirtuosoGrid, VirtuosoPresentation };\n\nvar _c, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10, _c11, _c12, _c13, _c14, _c15, _c16, _c17, _c18, _c19, _c20, _c21;\n\n$RefreshReg$(_c, \"VirtuosoStore\");\n$RefreshReg$(_c2, \"VirtuosoFiller\");\n$RefreshReg$(_c3, \"VirtuosoList$memo\");\n$RefreshReg$(_c4, \"VirtuosoList\");\n$RefreshReg$(_c5, \"DefaultScrollContainer\");\n$RefreshReg$(_c6, \"VirtuosoScroller\");\n$RefreshReg$(_c7, \"DefaultHeaderContainer\");\n$RefreshReg$(_c8, \"DefaultFooterContainer\");\n$RefreshReg$(_c9, \"DefaultListContainer\");\n$RefreshReg$(_c10, \"VirtuosoHeader\");\n$RefreshReg$(_c11, \"VirtuosoFooter\");\n$RefreshReg$(_c12, \"ListWrapper\");\n$RefreshReg$(_c13, \"VirtuosoView\");\n$RefreshReg$(_c14, \"VirtuosoPresentation$memo\");\n$RefreshReg$(_c15, \"VirtuosoPresentation\");\n$RefreshReg$(_c16, \"Virtuoso$forwardRef\");\n$RefreshReg$(_c17, \"Virtuoso\");\n$RefreshReg$(_c18, \"GroupedVirtuoso$forwardRef\");\n$RefreshReg$(_c19, \"GroupedVirtuoso\");\n$RefreshReg$(_c20, \"VirtuosoGridEngine\");\n$RefreshReg$(_c21, \"VirtuosoGridFC\");","map":{"version":3,"sources":["../src/VirtuosoContext.tsx","../src/tinyrx.ts","../src/EngineCommons.ts","../src/engines/adjustForPrependedItemsEngine.ts","../src/engines/followOutputEngine.ts","../src/AATree.ts","../src/GroupIndexTransposer.ts","../src/engines/groupCountEgine.ts","../src/engines/listEngine.ts","../src/engines/maxRangeSizeEngine.ts","../src/OffsetList.ts","../src/engines/initialItemCountEngine.ts","../src/engines/stickyItemsEngine.ts","../src/engines/offsetListEngine.ts","../src/engines/scrolledToBottomEngine.ts","../src/engines/scrollSeekEngine.ts","../src/engines/initialTopMostItemEngine.ts","../src/engines/scrollToIndexEngine.ts","../src/engines/topItemCountEngine.ts","../src/engines/topListEngine.ts","../src/rxio.ts","../src/VirtuosoStore.tsx","../src/Style.tsx","../src/Utils.tsx","../src/VirtuosoFiller.tsx","../src/VirtuosoList.tsx","../src/VirtuosoScroller.tsx","../src/VirtuosoView.tsx","../src/Virtuoso.tsx","../src/GroupedVirtuoso.tsx","../src/VirtuosoGridEngine.ts","../src/VirtuosoGrid.tsx"],"names":["VirtuosoContext","createContext","operators","subscriber","acc","prevCallback","operator","combineOperators","observable","source","subscribe","pipe","buildPipe","subject","initial","distinct","subscribers","val","next","newVal","sub","coldSubject","combineLatest","sources","called","Array","values","publish","map","mapTo","done","skip","times","filter","predicate","duc","comparator","current","debounceTime","time","clearTimeout","timeout","setTimeout","throttleTime","scan","scanner","initialValue","prevVal","withLatestFrom","buildIsScrolling","isScrolling$","scrollTop$","adjustForPrependedItemsEngine","offsetList$","scrollTo$","adjustForPrependedItems$","adjustmentInProgress$","count","offsetList","scrollTop","inProgress","top","followOutputEngine","scrollToIndex$","scrolledToBottom$","totalCount$","followOutput$","followOutput","totalCount","scrolledToBottom","index","align","behavior","NilNode","rebalance","adjust","shift","remove","find","findWith","findMax","findMaxValue","insert","key","value","level","walkWithin","walk","ranges","rangesWithin","empty","isSingle","isInvariant","keys","NIL_NODE","Object","UnreachableCaseError","Error","NonNilNode","left","right","lastKey","lastValue","result","callback","rightKey","rightValue","last","deleteLast","clone","args","rl","rightLevel","toRanges","nodes","first","start","i","nextNode","end","split","skew","AATree","defaultValue","adjustedStart","StubIndexTransposer","transpose","groupIndex","item","offset","size","transposedIndex","type","GroupIndexTransposer","tree","total","groupCount","groupMatch","groupIndices","groupCountEngine","transposer$","stickyItems$","groupCounts$","groupIndices$","transposer","getListTop","items","listEngine","overscan","defaultItemHeight","viewportHeight$","topListHeight$","headerHeight$","footerHeight$","minListIndex$","scrolledToTopMostItem$","totalHeight$","listHeight$","startReached$","endReached$","list$","constrainedScrollTop$","totalHeight","viewportHeight","Math","topListHeight","listHeight","headerHeight","footerHeight","minIndex","scrolledToTopMostItem","itemLength","listTop","listBottom","maxIndex","indexOutOfAllowedRange","endOffset","startOffset","listOffset$","currentEndIndex","endIndex","maxRangeSizeEngine","scheduledReadjust$","maxRangeSize$","maxRangeSize","list","scrollTo","OffsetList","offsetTree","nanIndices","initialTopMostItemIndex","rangeTree","nanFound","startIndex","isNaN","fromTree","groupSize","nanIndex","overlapingRanges","range","firstPassDone","shouldInsert","rangeStart","rangeEnd","rangeValue","insertSpots","spot","offsetOf","offsetRange","itemAt","NaN","indexRange","Infinity","rangeOffset","rangeIndex","getOffsets","indices","setInitialIndex","getDefaultSize","adjustForPrependedItems","configureMaxRangeSize","IndexList","initialItemCountEngine","itemHeights$","initialItemCount$","pendingRenderAfterInitial$","unsubscribeInitial","dummyItemHeight","stickyItemsEngine","topList$","stickyItemsIndexList$","stickyItems","params","stickyItemsIndexList","topList","currentStickyItem","offsetListEngine","itemHeight","heightsChanged$","initialOffsetList","heights","pendingRenderAfterInitial","newList","scrolledToBottomEngine","notAtBottom","scrollSeekEngine","rangeChanged$","range$","scrollVelocity$","isSeeking$","scrollSeekConfiguration$","prev","config","speed","isSeeking","exit","enter","velocity","initialTopMostItemIndexEngine","scrollToIndexEngine","scrollToIndexRequestPending$","scrollTopReportedAfterScrollToIndex$","changed","location","scrollTopReported","scrollToIndexRequestPending","scrollToIndex","topItemCountEngine","topItemCount$","topItemCount","topListEngine","makeOutput","unsubscribe","makeInput","VirtuosoStore","stickyItemsOffset$","MAX_OFFSET_HEIGHT","domTotalHeight$","scrollTopMultiplier$","domTotalHeight","domScrollTop$","domListOffset$","multiplier","domScrollTop","computeItemKey$","renderProp$","groupRenderProp$","itemContainer$","groupContainer$","itemRender$","dataKey$","Symbol","render","groupRender","scrollSeek","computeItemKey","ItemContainer","GroupContainer","renderPlaceholder","itemProps","children","height","groupCounts","itemHeights","initialItemCount","scrollSeekConfiguration","renderProp","groupRenderProp","itemContainer","groupContainer","dataKey","itemRender","scrollVelocity","itemsRendered","listOffset","startReached","endReached","atBottomStateChange","totalListHeightChanged","rangeChanged","isScrolling","stickyItemsOffset","viewportStyle","position","width","useHeight","ref","useRef","animationFrameID","observer","newHeight","entries","element","document","onResize","input","callbackRef","onMount","useEffect","window","output","useOutput","setValue","useState","callbackToValue","useSize","currentSize","contentRect","simpleMemoize","func","WEBKIT_STICKY","STICKY","positionStickyCssValue","node","VirtuosoFiller","style","VirtuosoList","emptyComponent","useContext","topItems","renderedItems","topOffset","renderedTopItemIndices","marginTop","itemIndex","zIndex","props","createElement","React","scrollerStyle","overflowY","WebkitOverflowScrolling","outline","DefaultScrollContainer","className","reportScrollTop","elRef","smoothScrollTarget","currentScrollTop","onScroll","useCallback","e","theRef","passive","tabIndex","VirtuosoScroller","ScrollContainer","DefaultHeaderContainer","headerRef","DefaultFooterContainer","footerRef","DefaultListContainer","listRef","VirtuosoHeader","header","HeaderContainer","headerCallbackRef","VirtuosoFooter","footer","FooterContainer","footerCallbackRef","getHeights","results","len","child","parseInt","knownSize","lastResult","ListWrapper","fixedItemHeight","ListContainer","translate","listCallbackRef","measuredItemHeights","VirtuosoView","fillerHeight","viewportCallbackRef","DEFAULT_STYLE","VirtuosoPresentation","contextValue","undefined","Virtuoso","forwardRef","state","useImperativeHandle","GroupedVirtuoso","ceil","floor","min","max","hackFloor","VirtuosoGridEngine","itemsRender","gridDimensions$","overscan$","itemRange$","remainingHeight$","viewportWidth","itemWidth","itemRange","itemsPerRow","toRowIndex","roundFunc","updateRange","topOverscan","bottomOverscan","down","itemClassName","gridDimensions","remainingHeight","VirtuosoGrid","engine","VirtuosoGridFC","listClassName","listStyle","paddingTop","paddingBottom","firstItem","firstItemContent"],"mappings":"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","sourcesContent":["import { createContext } from 'react'\nimport { VirtuosoStore } from './VirtuosoStore'\n\nexport const VirtuosoContext = createContext<ReturnType<typeof VirtuosoStore> | undefined>(undefined)\n","export type TSubscriber<T> = (val: T) => void\nexport type TSubscription = () => void\nexport type TSubscribe<T> = (subscriber: TSubscriber<T>) => TSubscription\nexport type TOperator<T, K> = (val: T, done: (result: K) => void) => void\n\nexport interface TObservable<T> {\n  subscribe: TSubscribe<T>\n  pipe(...operators: []): TObservable<T>\n  pipe<R1>(...operators: [TOperator<T, R1>]): TObservable<R1>\n  pipe<R1, R2>(...operators: [TOperator<T, R1>, TOperator<R1, R2>]): TObservable<R2>\n  pipe<R1, R2, R3>(...operators: [TOperator<T, R1>, TOperator<R1, R2>, TOperator<R2, R3>]): TObservable<R3>\n  pipe<R1, R2, R3, R4>(\n    ...operators: [TOperator<T, R1>, TOperator<R1, R2>, TOperator<R2, R3>, TOperator<R3, R4>]\n  ): TObservable<R4>\n}\n\nexport interface TSubject<T> extends TObservable<T> {\n  next(val: T): void\n  subscribers: TSubscriber<T>[]\n}\n\nfunction combineOperators<A1>(): TOperator<A1, A1>\nfunction combineOperators<A1, R1>(o1: TOperator<A1, R1>): TOperator<A1, R1>\nfunction combineOperators<A1, R1, R2>(o1: TOperator<A1, R1>, o2: TOperator<R1, R2>): TOperator<A1, R2>\nfunction combineOperators<A1, R1, R2>(o1: TOperator<A1, R1>, o2: TOperator<R1, R2>): TOperator<A1, R2>\nfunction combineOperators<A1, R1, R2, R3>(\n  o1: TOperator<A1, R1>,\n  o2: TOperator<R1, R2>,\n  o3: TOperator<R2, R3>\n): TOperator<A1, R3>\nfunction combineOperators<A1, R1, R2, R3, R4>(\n  o1: TOperator<A1, R1>,\n  o2: TOperator<R1, R2>,\n  o3: TOperator<R2, R3>,\n  o4: TOperator<R3, R4>\n): TOperator<A1, R4>\nfunction combineOperators<T>(...operators: TOperator<any, any>[]): TOperator<T, any>\nfunction combineOperators<T, K>(...operators: TOperator<any, any>[]) {\n  if (operators.length === 0) {\n    return (value: T, subscriber: (value: T) => void) => subscriber(value)\n  }\n  if (operators.length === 1) {\n    return operators[0]\n  }\n\n  return (value: T, subscriber: (value: K) => void): void => {\n    let acc = (value: any) => subscriber(value)\n    operators\n      .slice()\n      .reverse()\n      .forEach(operator => {\n        const prevCallback = acc\n        acc = value => operator(value, prevCallback)\n      })\n    acc(value)\n  }\n}\n\nfunction buildPipe<T>(subscribe: TSubscribe<T>) {\n  function pipe(...operators: []): TObservable<T>\n  function pipe<R1>(...operators: [TOperator<T, R1>]): TObservable<R1>\n  function pipe<R1, R2>(...operators: [TOperator<T, R1>, TOperator<R1, R2>]): TObservable<R2>\n  function pipe<R1, R2, R3>(...operators: [TOperator<T, R1>, TOperator<R1, R2>, TOperator<R2, R3>]): TObservable<R3>\n  function pipe<R1, R2, R3, R4>(\n    ...operators: [TOperator<T, R1>, TOperator<R1, R2>, TOperator<R2, R3>, TOperator<R3, R4>]\n  ): TObservable<R4>\n  function pipe<K extends TOperator<any, any>[]>(...operators: K) {\n    const operator = combineOperators(...operators)\n    return observable(subscribe, operator)\n  }\n  return pipe\n}\n\nexport function observable<T, K>(source: TSubscribe<T>, operator: TOperator<T, K>) {\n  const subscribe = (subscriber: TSubscriber<K>) => {\n    return source(val => operator(val, subscriber))\n  }\n\n  return {\n    subscribe,\n    pipe: buildPipe(subscribe),\n  }\n}\n\nexport function subject<T>(initial?: T, distinct = true): TSubject<T> {\n  let subscribers: TSubscriber<T>[] = []\n  let val: T | undefined = initial\n\n  const next = (newVal: T) => {\n    if (!distinct || newVal !== val) {\n      val = newVal\n      subscribers.forEach(subscriber => subscriber(newVal))\n    }\n  }\n\n  const subscribe = (subscriber: TSubscriber<T>) => {\n    subscribers.push(subscriber)\n    if (val !== undefined) {\n      subscriber(val)\n    }\n    return () => {\n      subscribers = subscribers.filter(sub => sub !== subscriber)\n    }\n  }\n\n  return {\n    next,\n    subscribe,\n    pipe: buildPipe(subscribe),\n    subscribers,\n  }\n}\n\nexport function coldSubject<T>(): TSubject<T> {\n  let subscribers: TSubscriber<T>[] = []\n\n  const next = (newVal: T) => {\n    subscribers.forEach(subscriber => subscriber(newVal))\n  }\n\n  const subscribe = (subscriber: TSubscriber<T>) => {\n    subscribers.push(subscriber)\n    return () => {\n      subscribers = subscribers.filter(sub => sub !== subscriber)\n    }\n  }\n\n  return {\n    next,\n    subscribe,\n    pipe: buildPipe(subscribe),\n    subscribers,\n  }\n}\n\nexport function combineLatest<S1, S2>(s1: TObservable<S1>, s2: TObservable<S2>): TObservable<[S1, S2]>\nexport function combineLatest<S1, S2, S3>(\n  s1: TObservable<S1>,\n  s2: TObservable<S2>,\n  s3: TObservable<S3>\n): TObservable<[S1, S2, S3]>\nexport function combineLatest<S1, S2, S3, S4>(\n  s1: TObservable<S1>,\n  s2: TObservable<S2>,\n  s3: TObservable<S3>,\n  s4: TObservable<S4>\n): TObservable<[S1, S2, S3, S4]>\nexport function combineLatest<S1, S2, S3, S4, S5>(\n  s1: TObservable<S1>,\n  s2: TObservable<S2>,\n  s3: TObservable<S3>,\n  s4: TObservable<S4>,\n  s5: TObservable<S5>\n): TObservable<[S1, S2, S3, S4, S5]>\nexport function combineLatest<S1, S2, S3, S4, S5, S6>(\n  ...s: [TObservable<S1>, TObservable<S2>, TObservable<S3>, TObservable<S4>, TObservable<S5>, TObservable<S6>]\n): TObservable<[S1, S2, S3, S4, S5, S6]>\nexport function combineLatest<S1, S2, S3, S4, S5, S6, S7>(\n  s1: TObservable<S1>,\n  s2: TObservable<S2>,\n  s3: TObservable<S3>,\n  s4: TObservable<S4>,\n  s5: TObservable<S5>,\n  s6: TObservable<S6>,\n  s7: TObservable<S7>\n): TObservable<[S1, S2, S3, S4, S5, S6, S7]>\nexport function combineLatest<S1, S2, S3, S4, S5, S6, S7, S8>(\n  s1: TObservable<S1>,\n  s2: TObservable<S2>,\n  s3: TObservable<S3>,\n  s4: TObservable<S4>,\n  s5: TObservable<S5>,\n  s6: TObservable<S6>,\n  s7: TObservable<S7>,\n  s8: TObservable<S8>\n): TObservable<[S1, S2, S3, S4, S5, S6, S7, S8]>\nexport function combineLatest<S1, S2, S3, S4, S5, S6, S7, S8, S9>(\n  s1: TObservable<S1>,\n  s2: TObservable<S2>,\n  s3: TObservable<S3>,\n  s4: TObservable<S4>,\n  s5: TObservable<S5>,\n  s6: TObservable<S6>,\n  s7: TObservable<S7>,\n  s8: TObservable<S8>,\n  s9: TObservable<S9>\n): TObservable<[S1, S2, S3, S4, S5, S6, S7, S8, S9]>\nexport function combineLatest<S1, S2, S3, S4, S5, S6, S7, S8, S9, S10>(\n  s1: TObservable<S1>,\n  s2: TObservable<S2>,\n  s3: TObservable<S3>,\n  s4: TObservable<S4>,\n  s5: TObservable<S5>,\n  s6: TObservable<S6>,\n  s7: TObservable<S7>,\n  s8: TObservable<S8>,\n  s9: TObservable<S9>,\n  s10: TObservable<S10>\n): TObservable<[S1, S2, S3, S4, S5, S6, S7, S8, S9, S10]>\nexport function combineLatest<S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, S11>(\n  s1: TObservable<S1>,\n  s2: TObservable<S2>,\n  s3: TObservable<S3>,\n  s4: TObservable<S4>,\n  s5: TObservable<S5>,\n  s6: TObservable<S6>,\n  s7: TObservable<S7>,\n  s8: TObservable<S8>,\n  s9: TObservable<S9>,\n  s10: TObservable<S10>,\n  s11: TObservable<S11>\n): TObservable<[S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, S11]>\nexport function combineLatest(...sources: TObservable<any>[]): TObservable<any[]> {\n  const called = Array<boolean>(sources.length).fill(false)\n  const values = Array<any>(sources.length)\n  let subscribers: TSubscriber<any>[] = []\n\n  const publish = (subscribers: TSubscriber<any>[]) => {\n    called.every(isCalled => isCalled) && subscribers.forEach(subscriber => subscriber(values))\n  }\n\n  sources.forEach((source, index) => {\n    source.subscribe(val => {\n      called[index] = true\n      values[index] = val\n      publish(subscribers)\n    })\n  })\n\n  const subscribe = (subscriber: TSubscriber<any[]>) => {\n    subscribers.push(subscriber)\n    publish([subscriber])\n    return () => {\n      subscribers = subscribers.filter(sub => sub !== subscriber)\n    }\n  }\n\n  return { subscribe, pipe: buildPipe(subscribe) }\n}\n\nexport function map<T, K>(map: (val: T) => K): (val: T, subscriber: TSubscriber<K>) => void {\n  return (val: T, subscriber: TSubscriber<K>) => {\n    subscriber(map(val))\n  }\n}\n\nexport function mapTo<T>(val: T) {\n  return (_: any, done: TSubscriber<T>) => done(val)\n}\n\nexport function skip<T>(times: number) {\n  return (val: T, done: TSubscriber<T>) => {\n    if (times > 0) {\n      times--\n    } else {\n      done(val)\n    }\n  }\n}\n\nexport function filter<T>(predicate: (val: T) => boolean) {\n  return (val: T, done: TSubscriber<T>) => {\n    predicate(val) && done(val)\n  }\n}\n\nexport function duc<T>(comparator = (current: T, next: T) => current !== next) {\n  let current: T\n  return (next: T, done: TSubscriber<T>) => {\n    if (comparator(current, next)) {\n      current = next\n      done(next)\n    }\n  }\n}\n\nexport function debounceTime<T>(time: number) {\n  let val: T | undefined\n  let timeout: any\n\n  return (newVal: T, done: TSubscriber<T>) => {\n    val = newVal\n    if (timeout) {\n      clearTimeout(timeout)\n    }\n\n    timeout = setTimeout(() => {\n      done(val!)\n    }, time)\n  }\n}\n\nexport function throttleTime<T>(time: number) {\n  let val: T | undefined\n  let timeout: any\n\n  return (newVal: T, done: TSubscriber<T>) => {\n    val = newVal\n\n    if (timeout) {\n      return\n    }\n\n    timeout = setTimeout(() => {\n      timeout = undefined\n      done(val!)\n    }, time)\n  }\n}\n\nexport function scan<T, K>(scanner: (prevVal: T, current: K) => T, initialValue: T) {\n  let prevVal: T = initialValue\n  return (newVal: K, done: TSubscriber<T>) => {\n    done((prevVal = scanner(prevVal, newVal)))\n  }\n}\n\nexport function withLatestFrom<T, R1>(s1: TObservable<R1>): (val: T, done: TSubscriber<[T, R1]>) => void\nexport function withLatestFrom<T, R1, R2>(\n  s1: TObservable<R1>,\n  s2: TObservable<R2>\n): (val: T, done: TSubscriber<[T, R1, R2]>) => void\nexport function withLatestFrom<T, R1, R2, R3>(\n  s1: TObservable<R1>,\n  s2: TObservable<R2>,\n  s3: TObservable<R3>\n): (val: T, done: TSubscriber<[T, R1, R2, R3]>) => void\nexport function withLatestFrom<T, R1, R2, R3, R4>(\n  s1: TObservable<R1>,\n  s2: TObservable<R2>,\n  s3: TObservable<R3>,\n  s4: TObservable<R4>\n): (val: T, done: TSubscriber<[T, R1, R2, R3, R4]>) => void\nexport function withLatestFrom<T, R1, R2, R3, R4, R5>(\n  s1: TObservable<R1>,\n  s2: TObservable<R2>,\n  s3: TObservable<R3>,\n  s4: TObservable<R4>,\n  s5: TObservable<R5>\n): (val: T, done: TSubscriber<[T, R1, R2, R3, R4, R5]>) => void\nexport function withLatestFrom<T, R1, R2, R3, R4, R5, R6>(\n  s1: TObservable<R1>,\n  s2: TObservable<R2>,\n  s3: TObservable<R3>,\n  s4: TObservable<R4>,\n  s5: TObservable<R5>,\n  s6: TObservable<R6>\n): (val: T, done: TSubscriber<[T, R1, R2, R3, R4, R5, R6]>) => void\nexport function withLatestFrom<T, R1, R2, R3, R4, R5, R6, R7>(\n  s1: TObservable<R1>,\n  s2: TObservable<R2>,\n  s3: TObservable<R3>,\n  s4: TObservable<R4>,\n  s5: TObservable<R5>,\n  s6: TObservable<R6>,\n  s7: TObservable<R7>\n): (val: T, done: TSubscriber<[T, R1, R2, R3, R4, R5, R6, R7]>) => void\n\nexport function withLatestFrom<T>(...sources: TObservable<any>[]) {\n  const called = Array<boolean>(sources.length).fill(false)\n  const values = Array<any>(sources.length)\n  sources.forEach((source, index) => {\n    source.subscribe(val => {\n      values[index] = val\n      called[index] = true\n    })\n  })\n\n  return (val: T, done: TSubscriber<any>) => {\n    called.every(isCalled => isCalled) && done([val, ...values])\n  }\n}\n","import * as React from 'react'\nimport { debounceTime, mapTo, skip, subject, TObservable, duc } from './tinyrx'\n\ninterface TScrollLocationWithAlign {\n  index: number\n  align: 'start' | 'center' | 'end'\n  behavior?: 'smooth' | 'auto'\n}\n\nexport type TScrollLocation = number | TScrollLocationWithAlign\n\nexport type TContainer =\n  | React.ComponentType<{ className: string; style?: React.CSSProperties; key?: number }>\n  | keyof JSX.IntrinsicElements\n\nexport const buildIsScrolling = (scrollTop$: TObservable<number>): TObservable<boolean> => {\n  const isScrolling$ = subject(false)\n\n  scrollTop$.pipe(skip(1), duc(), mapTo(true)).subscribe(isScrolling$.next)\n\n  scrollTop$.pipe(skip(1), mapTo(false), debounceTime(200)).subscribe(isScrolling$.next)\n\n  return isScrolling$\n}\n","import { TObservable, withLatestFrom, coldSubject, TSubject, subject } from '../tinyrx'\nimport { OffsetList } from '../OffsetList'\n\ninterface AdjustForPrependedItemsParams {\n  offsetList$: TSubject<OffsetList>\n  scrollTop$: TObservable<number>\n  scrollTo$: TSubject<ScrollToOptions>\n}\n\nexport function adjustForPrependedItemsEngine({ offsetList$, scrollTop$, scrollTo$ }: AdjustForPrependedItemsParams) {\n  const adjustForPrependedItems$ = coldSubject<number>()\n\n  const adjustmentInProgress$ = subject(false)\n  adjustForPrependedItems$\n    .pipe(withLatestFrom(offsetList$, scrollTop$, adjustmentInProgress$))\n    .subscribe(([count, offsetList, scrollTop, inProgress]) => {\n      if (inProgress || offsetList.empty()) {\n        return\n      }\n\n      adjustmentInProgress$.next(true)\n      offsetList$.next(offsetList.adjustForPrependedItems(count))\n\n      setTimeout(() => {\n        scrollTo$.next({ top: count * offsetList.getDefaultSize() + scrollTop })\n        adjustmentInProgress$.next(false)\n      })\n    })\n\n  return { adjustForPrependedItems$, adjustmentInProgress$ }\n}\n","import { TScrollLocation } from '../EngineCommons'\nimport { TObservable, TSubject, subject, combineLatest, withLatestFrom } from '../tinyrx'\n\ninterface FollowOutputParams {\n  totalCount$: TObservable<number>\n  scrolledToBottom$: TSubject<boolean>\n  scrollToIndex$: TSubject<TScrollLocation>\n}\nexport function followOutputEngine({ scrollToIndex$, scrolledToBottom$, totalCount$ }: FollowOutputParams) {\n  const followOutput$ = subject(false)\n\n  combineLatest(followOutput$, totalCount$)\n    .pipe(withLatestFrom(scrolledToBottom$))\n    .subscribe(([[followOutput, totalCount], scrolledToBottom]) => {\n      if (followOutput && scrolledToBottom) {\n        setTimeout(() => {\n          scrollToIndex$.next({ index: totalCount - 1, align: 'end', behavior: 'auto' })\n        })\n      }\n    })\n  return {\n    followOutput$,\n  }\n}\n","interface NodeData<T> {\n  key: number\n  value: T\n}\n\ninterface Range<T> {\n  start: number\n  end: number\n  value: T\n}\n\ntype FindCallback<T> = (value: T) => 1 | 0 | -1\n\nexport type NodeIterator<T> = IterableIterator<NodeData<T>>\nexport type RangeIterator<T> = IterableIterator<Range<T>>\n\nclass NilNode<T> {\n  public level = 0\n\n  public rebalance(): this {\n    return this\n  }\n\n  public adjust(): this {\n    return this\n  }\n\n  public shift(): this {\n    return this\n  }\n\n  public remove(): this {\n    return this\n  }\n\n  public find(): undefined {\n    return\n  }\n\n  public findWith(): undefined {\n    return\n  }\n\n  public findMax(): number {\n    return -Infinity\n  }\n\n  public findMaxValue(): undefined {\n    return\n  }\n\n  public insert(key: number, value: T): NonNilNode<T> {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new NonNilNode<T>({ key, value, level: 1 })\n  }\n\n  public walkWithin(): NodeData<T>[] {\n    return []\n  }\n\n  public walk(): NodeData<T>[] {\n    return []\n  }\n\n  public ranges<T>(): Range<T>[] {\n    return []\n  }\n\n  public rangesWithin<T>(): Range<T>[] {\n    return []\n  }\n\n  public empty(): this is NilNode<T> {\n    return true\n  }\n\n  public isSingle(): true {\n    return true\n  }\n\n  public isInvariant(): true {\n    return true\n  }\n\n  public keys(): number[] {\n    return []\n  }\n}\n\nconst NIL_NODE = new NilNode()\n\nObject.freeze(NIL_NODE)\n\ntype Node<T> = NonNilNode<T> | NilNode<T>\n\ninterface NodeConstructorArgs<T> {\n  key: number\n  value: T\n  level: number\n  left?: Node<T>\n  right?: Node<T>\n}\n\nclass UnreachableCaseError extends Error {\n  constructor(val: never) {\n    super(`Unreachable case: ${val}`)\n  }\n}\n\nclass NonNilNode<T> {\n  public key: number\n  public value: T\n  public level: number\n  public left: Node<T>\n  public right: Node<T>\n\n  public constructor({\n    key,\n    value,\n    level,\n    left = NIL_NODE as NilNode<T>,\n    right = NIL_NODE as NilNode<T>,\n  }: NodeConstructorArgs<T>) {\n    this.key = key\n    this.value = value\n    this.level = level\n    this.left = left\n    this.right = right\n  }\n\n  public shift(amount: number): Node<T> {\n    return this.clone({\n      key: this.key + amount,\n      left: this.left.shift(amount),\n      right: this.right.shift(amount),\n    })\n  }\n\n  public remove(key: number): Node<T> {\n    const { left, right } = this\n\n    if (key === this.key) {\n      if (left.empty()) {\n        return right\n      } else if (right.empty()) {\n        return left\n      } else {\n        const [lastKey, lastValue] = left.last()\n        return this.clone({\n          key: lastKey,\n          value: lastValue,\n          left: left.deleteLast(),\n        }).adjust()\n      }\n    } else if (key < this.key) {\n      return this.clone({\n        left: left.remove(key),\n      }).adjust()\n    } else {\n      return this.clone({\n        right: right.remove(key),\n      }).adjust()\n    }\n  }\n\n  public empty(): this is NilNode<T> {\n    return false\n  }\n\n  public find(key: number): T | undefined {\n    if (key === this.key) {\n      return this.value\n    } else if (key < this.key) {\n      return this.left.find(key)\n    } else {\n      return this.right.find(key)\n    }\n  }\n\n  public findWith(callback: FindCallback<T>): [number, T] | undefined {\n    const result = callback(this.value)\n\n    switch (result) {\n      case -1:\n        return this.left.findWith(callback)\n      case 0:\n        return [this.key, this.value]\n      case 1:\n        return this.right.findWith(callback)\n      default:\n        throw new UnreachableCaseError(result)\n    }\n  }\n\n  public findMax(key: number): number {\n    if (this.key === key) {\n      return key\n    }\n\n    if (this.key < key) {\n      const rightKey = this.right.findMax(key)\n      if (rightKey === -Infinity) {\n        return this.key\n      } else {\n        return rightKey\n      }\n    }\n\n    return this.left.findMax(key)\n  }\n\n  public findMaxValue(key: number): T {\n    if (this.key === key) {\n      return this.value\n    }\n\n    if (this.key < key) {\n      const rightValue = this.right.findMaxValue(key)\n      if (rightValue === undefined) {\n        return this.value\n      } else {\n        return rightValue\n      }\n    }\n\n    return this.left.findMaxValue(key)!\n  }\n\n  public insert(key: number, value: T): NonNilNode<T> {\n    if (key === this.key) {\n      return this.clone({ key, value })\n    } else if (key < this.key) {\n      return this.clone({\n        left: this.left.insert(key, value),\n      }).rebalance()\n    } else {\n      return this.clone({\n        right: this.right.insert(key, value),\n      }).rebalance()\n    }\n  }\n\n  public walkWithin(start: number, end: number): NodeData<T>[] {\n    const { key, value } = this\n    let result: NodeData<T>[] = []\n    if (key > start) {\n      result = result.concat(this.left.walkWithin(start, end))\n    }\n\n    if (key >= start && key <= end) {\n      result.push({ key, value })\n    }\n\n    if (key <= end) {\n      result = result.concat(this.right.walkWithin(start, end))\n    }\n\n    return result\n  }\n\n  public walk(): NodeData<T>[] {\n    return [...this.left.walk(), { key: this.key, value: this.value }, ...this.right.walk()]\n  }\n\n  public last(): [number, T] {\n    if (this.right.empty()) {\n      return [this.key, this.value]\n    } else {\n      return this.right.last()\n    }\n  }\n\n  public deleteLast(): Node<T> {\n    if (this.right.empty()) {\n      return this.left\n    } else {\n      return this.clone({\n        right: this.right.deleteLast(),\n      }).adjust()\n    }\n  }\n\n  public clone(args: Partial<NodeConstructorArgs<T>>): NonNilNode<T> {\n    return new NonNilNode<T>({\n      key: args.key !== undefined ? args.key : this.key,\n      value: args.value !== undefined ? args.value : this.value,\n      level: args.level !== undefined ? args.level : this.level,\n      left: args.left !== undefined ? args.left : this.left,\n      right: args.right !== undefined ? args.right : this.right,\n    })\n  }\n\n  public isSingle(): boolean {\n    return this.level > this.right.level\n  }\n\n  public rebalance(): NonNilNode<T> {\n    return this.skew().split()\n  }\n\n  public adjust(): NonNilNode<T> {\n    const { left, right, level } = this\n    if (right.level >= level - 1 && left.level >= level - 1) {\n      return this\n    } else if (level > right.level + 1) {\n      if (left.isSingle()) {\n        return this.clone({ level: level - 1 }).skew()\n      } else {\n        if (!left.empty() && !left.right.empty()) {\n          return left.right.clone({\n            left: left.clone({ right: left.right.left }),\n            right: this.clone({\n              left: left.right.right,\n              level: level - 1,\n            }),\n            level: level,\n          })\n        } else {\n          throw new Error('Unexpected empty nodes')\n        }\n      }\n    } else {\n      if (this.isSingle()) {\n        return this.clone({ level: level - 1 }).split()\n      } else {\n        if (!right.empty() && !right.left.empty()) {\n          const rl = right.left\n          const rightLevel = rl.isSingle() ? right.level - 1 : right.level\n\n          return rl.clone({\n            left: this.clone({\n              right: rl.left,\n              level: level - 1,\n            }),\n            right: right.clone({ left: rl.right, level: rightLevel }).split(),\n            level: rl.level + 1,\n          })\n        } else {\n          throw new Error('Unexpected empty nodes')\n        }\n      }\n    }\n  }\n\n  public isInvariant(): boolean {\n    const { left, right, level } = this\n\n    if (level !== left.level + 1) {\n      return false\n    } else if (level !== right.level && level !== right.level + 1) {\n      return false\n    } else if (!right.empty() && level <= right.right.level) {\n      return false\n    } else {\n      return left.isInvariant() && right.isInvariant()\n    }\n  }\n\n  public keys(): number[] {\n    return [...this.left.keys(), this.key, ...this.right.keys()]\n  }\n\n  public ranges(): Range<T>[] {\n    return this.toRanges(this.walk())\n  }\n\n  public rangesWithin(startIndex: number, endIndex: number): Range<T>[] {\n    return this.toRanges(this.walkWithin(startIndex, endIndex))\n  }\n\n  private toRanges(nodes: NodeData<T>[]): Range<T>[] {\n    if (nodes.length === 0) {\n      return []\n    }\n\n    const first = nodes[0]\n\n    let { key: start, value } = first\n\n    const result = []\n\n    for (let i = 1; i <= nodes.length; i++) {\n      const nextNode = nodes[i]\n      const end = nextNode ? nextNode.key - 1 : Infinity\n      result.push({ start, end, value })\n\n      if (nextNode) {\n        start = nextNode.key\n        value = nextNode.value\n      }\n    }\n    return result\n  }\n\n  private split(): NonNilNode<T> {\n    const { right, level } = this\n    if (!right.empty() && !right.right.empty() && right.level === level && right.right.level === level) {\n      return right.clone({\n        left: this.clone({ right: right.left }),\n        level: level + 1,\n      })\n    } else {\n      return this\n    }\n  }\n\n  private skew(): NonNilNode<T> {\n    const { left } = this\n\n    if (!left.empty() && left.level === this.level) {\n      return left.clone({\n        right: this.clone({ left: left.right }),\n      })\n    } else {\n      return this\n    }\n  }\n}\n\nexport class AATree<T> {\n  private root: Node<T>\n\n  public static empty<T>(): AATree<T> {\n    return new AATree<T>(NIL_NODE as NilNode<T>)\n  }\n\n  private constructor(root: Node<T>) {\n    this.root = root\n  }\n\n  public find(key: number): T | undefined {\n    return this.root.find(key)\n  }\n\n  public findMax(key: number): number {\n    return this.root.findMax(key)\n  }\n\n  public findMaxValue(key: number): T {\n    if (this.empty()) {\n      throw new Error('Searching for max value in an empty tree')\n    }\n    return this.root.findMaxValue(key)!\n  }\n\n  public findWith(callback: FindCallback<T>): [number, T] | void {\n    return this.root.findWith(callback)\n  }\n\n  public insert(key: number, value: T): AATree<T> {\n    return new AATree(this.root.insert(key, value))\n  }\n\n  public remove(key: number): AATree<T> {\n    return new AATree(this.root.remove(key))\n  }\n\n  public shift(amount: number) {\n    if (this.empty()) {\n      return this\n    }\n    const defaultValue = this.root.findMaxValue(Infinity)\n    return new AATree(this.root.shift(amount).insert(0, defaultValue!))\n  }\n\n  public empty() {\n    return this.root.empty()\n  }\n\n  public keys(): number[] {\n    return this.root.keys()\n  }\n\n  public walk(): NodeData<T>[] {\n    return this.root.walk()\n  }\n\n  public walkWithin(start: number, end: number): NodeData<T>[] {\n    const adjustedStart = this.root.findMax(start)\n    return this.root.walkWithin(adjustedStart, end)\n  }\n\n  public ranges(): Range<T>[] {\n    return this.root.ranges()\n  }\n\n  public rangesWithin(start: number, end: number): Range<T>[] {\n    const adjustedStart = this.root.findMax(start)\n    return this.root.rangesWithin(adjustedStart, end)\n  }\n\n  public isInvariant(): boolean {\n    return this.root.isInvariant()\n  }\n}\n","import { AATree } from './AATree'\nimport { Item } from './OffsetList'\n\nexport interface RecordItem extends Item {\n  type: 'item'\n  transposedIndex: number\n  groupIndex: number\n}\n\nexport interface GroupItem extends Item {\n  type: 'group'\n  groupIndex: number\n}\n\nexport type ListItem = RecordItem | GroupItem\n\nexport class StubIndexTransposer {\n  public transpose(items: Item[]): RecordItem[] {\n    return items.map(item => {\n      return {\n        groupIndex: 0,\n        index: item.index,\n        offset: item.offset,\n        size: item.size,\n        transposedIndex: item.index,\n        type: 'item',\n      }\n    })\n  }\n}\n\nexport class GroupIndexTransposer {\n  public tree: AATree<[number, number]>\n  private count: number\n\n  public constructor(counts: number[]) {\n    this.count = counts.reduce((acc, groupCount) => acc + groupCount + 1, 0)\n    let tree = AATree.empty<[number, number]>()\n    let groupIndex = 0\n    let total = 0\n    for (const groupCount of counts) {\n      tree = tree.insert(total, [groupIndex, total])\n      groupIndex++\n      total += groupCount + 1\n    }\n    this.tree = tree\n  }\n\n  public totalCount(): number {\n    return this.count\n  }\n\n  public transpose(items: Item[]): ListItem[] {\n    return items.map(item => {\n      const groupMatch = this.tree.find(item.index)\n      if (groupMatch) {\n        return {\n          groupIndex: groupMatch[0],\n          index: item.index,\n          offset: item.offset,\n          size: item.size,\n          type: 'group',\n        }\n      }\n\n      const [groupIndex] = this.tree.findMaxValue(item.index)!\n      return {\n        groupIndex: groupIndex,\n        index: item.index,\n        offset: item.offset,\n        size: item.size,\n        transposedIndex: item.index - groupIndex - 1,\n        type: 'item',\n      }\n    })\n  }\n\n  public groupIndices() {\n    return this.tree.keys()\n  }\n}\n\nexport type Transposer = StubIndexTransposer | GroupIndexTransposer\n","import { GroupIndexTransposer, Transposer } from '../GroupIndexTransposer'\nimport { TSubject, subject } from '../tinyrx'\n\ninterface GroupCountParams {\n  totalCount$: TSubject<number>\n  stickyItems$: TSubject<number[]>\n  transposer$: TSubject<Transposer>\n}\nexport function groupCountEngine({ transposer$, stickyItems$, totalCount$ }: GroupCountParams) {\n  const groupCounts$ = subject<number[]>()\n  const groupIndices$ = stickyItems$.pipe()\n\n  groupCounts$.subscribe(counts => {\n    const transposer = new GroupIndexTransposer(counts)\n    transposer$.next(transposer)\n    totalCount$.next(transposer.totalCount())\n    stickyItems$.next(transposer.groupIndices())\n  })\n\n  return {\n    groupCounts$,\n    groupIndices$,\n  }\n}\n","import { scan, combineLatest, TObservable, map, subject, withLatestFrom, coldSubject, duc } from '../tinyrx'\nimport { OffsetList } from '../OffsetList'\nimport { ListItem, Transposer } from '../GroupIndexTransposer'\n\nexport const getListTop = (items: ListItem[]) => (items.length > 0 ? items[0].offset : 0)\n\ninterface ListEngineParams {\n  overscan: number\n  defaultItemHeight?: number\n  viewportHeight$: TObservable<number>\n  scrollTop$: TObservable<number>\n  topListHeight$: TObservable<number>\n  headerHeight$: TObservable<number>\n  footerHeight$: TObservable<number>\n  minListIndex$: TObservable<number>\n  totalCount$: TObservable<number>\n  offsetList$: TObservable<OffsetList>\n  scrolledToTopMostItem$: TObservable<boolean>\n  transposer$: TObservable<Transposer>\n  totalHeight$: TObservable<number>\n}\n\nexport function listEngine({\n  overscan,\n  defaultItemHeight,\n  viewportHeight$,\n  scrollTop$,\n  topListHeight$,\n  headerHeight$,\n  footerHeight$,\n  minListIndex$,\n  totalCount$,\n  offsetList$,\n  scrolledToTopMostItem$,\n  transposer$,\n  totalHeight$,\n}: ListEngineParams) {\n  const listHeight$ = subject(0)\n  const startReached$ = coldSubject<number>()\n  const endReached$ = coldSubject<number>()\n  const list$ = subject<ListItem[]>([])\n\n  const constrainedScrollTop$ = subject(0)\n\n  combineLatest(scrollTop$, totalHeight$, viewportHeight$)\n    .pipe(\n      map(([scrollTop, totalHeight, viewportHeight]) => Math.max(0, Math.min(scrollTop, totalHeight - viewportHeight)))\n    )\n    .subscribe(constrainedScrollTop$.next)\n\n  combineLatest(\n    viewportHeight$,\n    constrainedScrollTop$,\n    topListHeight$,\n    listHeight$,\n    headerHeight$,\n    footerHeight$,\n    minListIndex$,\n    totalCount$,\n    offsetList$,\n    scrolledToTopMostItem$,\n    transposer$\n  )\n    .pipe(\n      scan(\n        (\n          items,\n          [\n            viewportHeight,\n            scrollTop,\n            topListHeight,\n            listHeight,\n            headerHeight,\n            footerHeight,\n            minIndex,\n            totalCount,\n            offsetList,\n            scrolledToTopMostItem,\n            transposer,\n          ]\n        ) => {\n          const itemLength = items.length\n\n          if (totalCount === 0) {\n            return []\n          }\n\n          const listTop = getListTop(items)\n\n          const listBottom = listTop - scrollTop + listHeight - headerHeight - footerHeight - topListHeight\n          const maxIndex = Math.max(totalCount - 1, 0)\n          const indexOutOfAllowedRange =\n            itemLength > 0 && (items[0].index < minIndex || items[itemLength - 1].index > maxIndex)\n\n          if (listBottom < viewportHeight || indexOutOfAllowedRange) {\n            const endOffset = scrollTop + viewportHeight + overscan * 2 - 1\n            items = transposer.transpose(offsetList.range(scrollTop, endOffset, minIndex, maxIndex))\n          }\n\n          if (listTop > scrollTop) {\n            const startOffset = Math.max(scrollTop - overscan * 2, 0)\n            const endOffset = scrollTop + viewportHeight - 1\n            items = transposer.transpose(offsetList.range(startOffset, endOffset, minIndex, maxIndex))\n          }\n\n          // this is a hack - we should let the probe item render,\n          // but skip the real list until the viewport has scrolled\n          // to the expected location\n          // However, if we have default item height set then we can skip this.\n          if (items.length > 1 && !scrolledToTopMostItem && !defaultItemHeight) {\n            return []\n          }\n\n          return items\n        },\n        [] as ListItem[]\n      ),\n      duc()\n    )\n    .subscribe(list$.next)\n\n  const listOffset$ = combineLatest(list$, scrollTop$, topListHeight$).pipe(map(([items]) => getListTop(items)))\n\n  constrainedScrollTop$.subscribe(scrollTop => {\n    if (scrollTop === 0) {\n      startReached$.next(scrollTop)\n    }\n  })\n\n  let currentEndIndex = 0\n\n  list$\n    .pipe(map(items => (items.length ? items[items.length - 1].index : 0)))\n    .pipe(withLatestFrom(totalCount$))\n    .subscribe(([endIndex, totalCount]) => {\n      if (totalCount === 0) {\n        return\n      }\n\n      if (endIndex === totalCount - 1) {\n        if (currentEndIndex !== endIndex) {\n          currentEndIndex = endIndex\n          endReached$.next(endIndex)\n        }\n      }\n    })\n\n  return { list$, listOffset$, listHeight$, startReached$, endReached$ }\n}\n","import { TObservable, TSubject, subject, withLatestFrom } from '../tinyrx'\nimport { OffsetList } from '../OffsetList'\nimport { ListItem } from '../GroupIndexTransposer'\n\nexport interface MaxRangeSizeParams {\n  offsetList$: TSubject<OffsetList>\n  scrollTo$: TSubject<ScrollToOptions>\n  scrollTop$: TObservable<number>\n  list$: TObservable<ListItem[]>\n}\n\nexport function maxRangeSizeEngine({ list$, offsetList$, scrollTop$, scrollTo$ }: MaxRangeSizeParams) {\n  const scheduledReadjust$ = subject<{ index: number; offset: number } | null>(null)\n  const maxRangeSize$ = subject(Infinity)\n\n  //////////////\n  // Max range size implementation\n  // the scheduledReadjust$ can be removed through the trapNext pattern\n  //////////////\n\n  // 1. List warns us that it will reset itself.\n  offsetList$\n    .pipe(withLatestFrom(maxRangeSize$, scrollTop$, list$))\n    .subscribe(([offsetList, maxRangeSize, scrollTop, list]) =>\n      offsetList.configureMaxRangeSize(maxRangeSize, () => {\n        // 2. we pick the adjustment signal and capture the list state *before* it gets reset\n        scheduledReadjust$.next({ index: list[0].index, offset: scrollTop - list[0].offset })\n      })\n    )\n\n  // 3. once the offset list is reset, we compensate the scroll.\n  offsetList$.pipe(withLatestFrom(scheduledReadjust$)).subscribe(([offsetList, adjust]) => {\n    if (adjust !== null) {\n      const scrollTo = offsetList.offsetOf(adjust!.index) + adjust!.offset\n      scrollTo$.next({ top: scrollTo })\n      scheduledReadjust$.next(null)\n    }\n  })\n  return {\n    maxRangeSize$,\n  }\n}\n","import { AATree } from './AATree'\n\ninterface OffsetValue {\n  startIndex: number\n  endIndex: number\n  size: number\n}\n\nexport interface Item {\n  index: number\n  offset: number\n  size: number\n}\n\nexport class OffsetList {\n  public rangeTree: AATree<number>\n  public offsetTree: AATree<OffsetValue>\n  private nanIndices: number[]\n  private initialTopMostItemIndex = 0\n  private rangeSize = 0\n  private maxRangeSize = Infinity\n  private rangeSizeExceededCallback: () => void = () => {}\n\n  public static create(): OffsetList {\n    return new OffsetList(AATree.empty<number>())\n  }\n\n  private constructor(\n    rangeTree: AATree<number>,\n    offsetTree = AATree.empty<OffsetValue>(),\n    nanIndices: number[] = [],\n    initialTopMostItemIndex = 0\n  ) {\n    this.rangeTree = rangeTree\n    this.nanIndices = nanIndices\n    this.initialTopMostItemIndex = initialTopMostItemIndex\n\n    if (offsetTree.empty()) {\n      let offset = 0\n      const ranges = rangeTree.ranges()\n\n      let nanFound = false\n\n      for (const { start: startIndex, end: endIndex, value: size } of ranges) {\n        this.rangeSize++\n        if (isNaN(size)) {\n          this.nanIndices.push(startIndex)\n\n          if (!nanFound) {\n            offsetTree = offsetTree.insert(offset, {\n              startIndex,\n              endIndex: Infinity,\n              size,\n            })\n          }\n\n          nanFound = true\n        } else if (!nanFound) {\n          offsetTree = offsetTree.insert(offset, {\n            startIndex,\n            endIndex: endIndex,\n            size,\n          })\n\n          offset += (endIndex - startIndex + 1) * size\n        }\n      }\n    }\n\n    this.offsetTree = offsetTree\n  }\n\n  public empty() {\n    return this.rangeTree.empty()\n  }\n\n  private fromTree(tree: AATree<number>) {\n    return new OffsetList(tree, undefined, undefined, this.initialTopMostItemIndex)\n  }\n\n  public insert(start: number, end: number, size: number): OffsetList {\n    let tree = this.rangeTree\n    if (tree.empty()) {\n      return this.fromTree(tree.insert(0, size))\n    }\n\n    if (this.rangeSize > this.maxRangeSize) {\n      this.rangeSizeExceededCallback()\n      return this.fromTree(AATree.empty<number>().insert(0, this.getDefaultSize()))\n    }\n\n    // tree is in non-complete state - we know the group sizes, but not the item sizes\n    if (this.nanIndices.length && this.nanIndices.indexOf(end) > -1) {\n      const groupSize = tree.find(this.nanIndices[0] - 1)\n\n      if (groupSize === size) {\n        return this.fromTree(AATree.empty<number>().insert(0, size))\n      }\n      for (const nanIndex of this.nanIndices) {\n        tree = tree.insert(nanIndex, size)\n      }\n\n      return this.fromTree(tree)\n    }\n\n    // extend the range in both directions, so that we can get adjacent neighbours.\n    // if the previous / next ones have the same value as the one we are about to insert,\n    // we 'merge' them.\n    const overlapingRanges = tree.rangesWithin(start - 1, end + 1)\n\n    if (\n      overlapingRanges.some(range => {\n        return range.start === start && (range.end === end || range.end === Infinity) && range.value === size\n      })\n    ) {\n      return this\n    }\n\n    let firstPassDone = false\n    let shouldInsert = false\n    for (const { start: rangeStart, end: rangeEnd, value: rangeValue } of overlapingRanges) {\n      // previous range\n      if (!firstPassDone) {\n        shouldInsert = rangeValue !== size\n        firstPassDone = true\n      } else {\n        // remove the range if it starts within the new range OR if\n        // it has the same value as it, in order to perfrom a merge\n        if (end >= rangeStart || size === rangeValue) {\n          tree = tree.remove(rangeStart)\n        }\n      }\n\n      // next range\n      if (rangeEnd > end && end >= rangeStart) {\n        if (rangeValue !== size && !isNaN(rangeValue)) {\n          tree = tree.insert(end + 1, rangeValue)\n        }\n      }\n    }\n\n    if (shouldInsert) {\n      tree = tree.insert(start, size)\n    }\n\n    return tree === this.rangeTree ? this : this.fromTree(tree)\n  }\n\n  public insertSpots(spotIndexes: number[], value: number): OffsetList {\n    if (this.empty()) {\n      let tree = this.rangeTree\n      for (const spot of spotIndexes) {\n        tree = tree.insert(spot, value).insert(spot + 1, NaN)\n      }\n\n      return new OffsetList(tree)\n    } else {\n      throw new Error('attempting to overwrite non-empty tree')\n    }\n  }\n\n  public offsetOf(index: number): number {\n    if (this.offsetTree.empty()) {\n      return 0\n    }\n\n    const find = (value: OffsetValue) => {\n      if (value.startIndex > index) return -1\n      if (value.endIndex < index) return 1\n      return 0\n    }\n\n    const offsetRange = this.offsetTree.findWith(find)\n    if (offsetRange) {\n      const [offset, { startIndex, size }] = offsetRange\n      return offset + (index - startIndex) * size\n    } else {\n      throw new Error(`Requested offset outside of the known ones, index: ${index}`)\n    }\n  }\n\n  public itemAt(index: number): Item {\n    const size = this.rangeTree.findMaxValue(index)\n    return { index, size, offset: NaN }\n  }\n\n  public indexRange(startIndex: number, endIndex: number): Item[] {\n    if (this.rangeTree.empty()) {\n      return [{ index: this.initialTopMostItemIndex, size: 0, offset: NaN }]\n    }\n\n    const ranges = this.rangeTree.rangesWithin(startIndex, endIndex)\n    const result: Item[] = []\n\n    for (const range of ranges) {\n      const start = Math.max(startIndex, range.start)\n      const rangeEnd = typeof range.end === 'undefined' ? Infinity : range.end\n      const end = Math.min(endIndex, rangeEnd)\n\n      for (let i = start; i <= end; i++) {\n        result.push({ index: i, size: range.value, offset: NaN })\n      }\n    }\n    return result\n  }\n\n  public range(startOffset: number, endOffset: number, minIndex = 0, maxIndex = Infinity): Item[] {\n    if (this.offsetTree.empty()) {\n      return [{ index: this.initialTopMostItemIndex, size: 0, offset: 0 }]\n    }\n\n    const ranges = this.offsetTree.rangesWithin(startOffset, endOffset)\n\n    const result: Item[] = []\n\n    for (let {\n      start: rangeOffset,\n      value: { startIndex: rangeIndex, endIndex, size },\n    } of ranges) {\n      let offset = rangeOffset\n      let startIndex = rangeIndex\n\n      if (rangeOffset < startOffset) {\n        startIndex += Math.floor((startOffset - rangeOffset) / size)\n        offset += (startIndex - rangeIndex) * size\n      }\n\n      if (startIndex < minIndex) {\n        offset += (minIndex - startIndex) * size\n        startIndex = minIndex\n      }\n\n      // we don't know the size of this range - terminate with a probe item\n      if (isNaN(size)) {\n        result.push({ index: startIndex, size: 0, offset })\n        return result\n      }\n\n      endIndex = Math.min(endIndex, maxIndex)\n\n      for (let i = startIndex; i <= endIndex; i++) {\n        if (offset > endOffset) {\n          break\n        }\n\n        result.push({ index: i, size, offset })\n        offset += size\n      }\n    }\n    return result\n  }\n\n  public total(endIndex: number) {\n    const ranges = this.rangeTree.rangesWithin(0, endIndex)\n\n    let total = 0\n\n    for (let { start, end, value: size } of ranges) {\n      end = Math.min(end, endIndex)\n      total += (end - start + 1) * (isNaN(size) ? 0 : size)\n    }\n\n    return total\n  }\n\n  public getOffsets(indices: number[]): IndexList {\n    let tree = AATree.empty<number>()\n    indices.forEach(index => {\n      const offset = this.offsetOf(index)\n      tree = tree.insert(offset, index)\n    })\n    return new IndexList(tree)\n  }\n\n  public setInitialIndex(topMostItemIndex: number): OffsetList {\n    return new OffsetList(this.rangeTree, this.offsetTree, this.nanIndices, topMostItemIndex)\n  }\n\n  public getDefaultSize(): number {\n    return this.rangeTree.findMaxValue(Infinity)\n  }\n\n  public adjustForPrependedItems(count: number) {\n    return this.fromTree(this.rangeTree.shift(count))\n  }\n\n  public configureMaxRangeSize(maxRangeSize: number, maxRangeSizeExceededCallback: () => void) {\n    this.maxRangeSize = maxRangeSize\n    this.rangeSizeExceededCallback = maxRangeSizeExceededCallback\n  }\n}\n\nexport class IndexList {\n  public tree: AATree<number>\n  public constructor(tree: AATree<number>) {\n    this.tree = tree\n  }\n\n  public findMaxValue(offset: number): number {\n    return this.tree.findMaxValue(offset)\n  }\n\n  public empty(): boolean {\n    return this.tree.empty()\n  }\n}\n","import { subject, TSubject } from '../tinyrx'\nimport { ItemHeight } from '../VirtuosoStore'\n\ninterface InitialItemCountEngineParams {\n  itemHeights$: TSubject<ItemHeight[]>\n  viewportHeight$: TSubject<number>\n}\nexport function initialItemCountEngine({ itemHeights$, viewportHeight$ }: InitialItemCountEngineParams) {\n  const initialItemCount$ = subject<number>()\n  const pendingRenderAfterInitial$ = subject(false)\n\n  const unsubscribeInitial = initialItemCount$.subscribe(count => {\n    const dummyItemHeight = 30\n    itemHeights$.next([{ start: 0, end: 0, size: dummyItemHeight }])\n    viewportHeight$.next(dummyItemHeight * count)\n    pendingRenderAfterInitial$.next(true)\n    unsubscribeInitial()\n  })\n\n  return { initialItemCount$, pendingRenderAfterInitial$ }\n}\n","import { subject, map, TObservable, combineLatest, filter, withLatestFrom, TSubject } from '../tinyrx'\nimport { OffsetList } from '../OffsetList'\nimport { Transposer, ListItem } from '../GroupIndexTransposer'\n\ninterface StickyItemsEngineParams {\n  offsetList$: TObservable<OffsetList>\n  scrollTop$: TObservable<number>\n  topList$: TSubject<ListItem[]>\n  transposer$: TObservable<Transposer>\n}\nexport function stickyItemsEngine({ offsetList$, scrollTop$, topList$, transposer$ }: StickyItemsEngineParams) {\n  const stickyItems$ = subject<number[]>([])\n\n  const stickyItemsIndexList$ = combineLatest(offsetList$, stickyItems$).pipe(\n    map(([offsetList, stickyItems]) => {\n      return offsetList.getOffsets(stickyItems)\n    })\n  )\n\n  combineLatest(offsetList$, stickyItemsIndexList$, scrollTop$)\n    .pipe(\n      filter(params => !params[1].empty() && !params[0].empty()),\n      withLatestFrom(topList$, transposer$),\n      map(([[offsetList, stickyItemsIndexList, scrollTop], topList, transposer]) => {\n        const currentStickyItem = stickyItemsIndexList.findMaxValue(Math.max(scrollTop, 0))\n\n        if (topList.length === 1 && topList[0].index === currentStickyItem) {\n          return topList\n        }\n\n        const item = offsetList.itemAt(currentStickyItem)\n        return transposer.transpose([item])\n      })\n    )\n    .subscribe(topList$.next)\n\n  return {\n    stickyItems$,\n  }\n}\n","import { OffsetList } from '../OffsetList'\nimport { combineLatest, map, subject, TSubject, withLatestFrom, coldSubject } from '../tinyrx'\nimport { ItemHeight } from '../VirtuosoStore'\nimport { initialItemCountEngine } from './initialItemCountEngine'\nimport { Transposer, ListItem } from '../GroupIndexTransposer'\nimport { stickyItemsEngine } from './stickyItemsEngine'\n\ninterface OffsetListEngineParams {\n  itemHeight: number | undefined\n  defaultItemHeight: number | undefined\n  initialTopMostItemIndex: number | undefined\n  totalCount: number\n  viewportHeight$: TSubject<number>\n  scrollTop$: TSubject<number>\n  topList$: TSubject<ListItem[]>\n  transposer$: TSubject<Transposer>\n}\n\nexport function offsetListEngine({\n  totalCount,\n  itemHeight,\n  defaultItemHeight,\n  initialTopMostItemIndex,\n  viewportHeight$,\n  scrollTop$,\n  topList$,\n  transposer$,\n}: OffsetListEngineParams) {\n  const headerHeight$ = subject(0)\n  const footerHeight$ = subject(0)\n  const totalCount$ = subject(totalCount)\n  const itemHeights$ = subject<ItemHeight[]>()\n  const { pendingRenderAfterInitial$, initialItemCount$ } = initialItemCountEngine({ itemHeights$, viewportHeight$ })\n  const heightsChanged$ = coldSubject<[boolean, OffsetList]>()\n\n  let initialOffsetList = OffsetList.create()\n\n  if (itemHeight) {\n    initialOffsetList = initialOffsetList.insert(0, 0, itemHeight)\n  }\n\n  if (defaultItemHeight) {\n    initialOffsetList = initialOffsetList.insert(0, 0, defaultItemHeight)\n  }\n\n  if (initialTopMostItemIndex) {\n    initialOffsetList = initialOffsetList.setInitialIndex(initialTopMostItemIndex)\n  }\n\n  const offsetList$ = subject(initialOffsetList)\n  const { stickyItems$ } = stickyItemsEngine({ offsetList$, scrollTop$, topList$, transposer$ })\n\n  const totalHeight$ = combineLatest(offsetList$, totalCount$, headerHeight$, footerHeight$).pipe(\n    map(\n      ([offsetList, totalCount, headerHeight, footerHeight]) =>\n        offsetList.total(totalCount - 1) + headerHeight + footerHeight\n    )\n  )\n\n  if (!itemHeight) {\n    itemHeights$\n      .pipe(withLatestFrom(offsetList$, stickyItems$, pendingRenderAfterInitial$))\n      .subscribe(([heights, offsetList, stickyItems, pendingRenderAfterInitial]) => {\n        let newList = offsetList\n\n        if (pendingRenderAfterInitial) {\n          newList = OffsetList.create()\n          pendingRenderAfterInitial = false\n        }\n\n        for (const { start, end, size } of heights) {\n          if (newList.empty() && start === end && stickyItems.indexOf(start) > -1) {\n            newList = newList.insertSpots(stickyItems, size)\n          } else {\n            newList = newList.insert(start, end, size)\n          }\n        }\n\n        if (newList !== offsetList) {\n          offsetList$.next(newList)\n          heightsChanged$.next([true, newList])\n        } else {\n          heightsChanged$.next([false, newList])\n        }\n      })\n  }\n\n  return {\n    totalCount$,\n    offsetList$,\n    totalHeight$,\n    headerHeight$,\n    footerHeight$,\n    initialItemCount$,\n    itemHeights$,\n    stickyItems$,\n    heightsChanged$,\n  }\n}\n","import { TObservable, subject, combineLatest, map } from '../tinyrx'\n\ninterface ScrolledToBottomParams {\n  scrollTop$: TObservable<number>\n  viewportHeight$: TObservable<number>\n  totalHeight$: TObservable<number>\n}\n\nexport function scrolledToBottomEngine({ totalHeight$, viewportHeight$, scrollTop$ }: ScrolledToBottomParams) {\n  const scrolledToBottom$ = subject(false)\n\n  let notAtBottom: number\n\n  combineLatest(scrollTop$, viewportHeight$, totalHeight$)\n    .pipe(\n      map(([scrollTop, viewportHeight, totalHeight]) => {\n        if (viewportHeight === 0) return false\n        return totalHeight - viewportHeight - scrollTop <= 1 || totalHeight <= viewportHeight\n      })\n    )\n    .subscribe(value => {\n      clearTimeout(notAtBottom)\n      if (!value) {\n        notAtBottom = setTimeout(() => scrolledToBottom$.next(false))\n      } else {\n        scrolledToBottom$.next(true)\n      }\n    })\n\n  return {\n    scrolledToBottom$,\n  }\n}\n","import {\n  TObservable,\n  subject,\n  filter,\n  mapTo,\n  throttleTime,\n  scan,\n  map,\n  withLatestFrom,\n  duc,\n  combineLatest,\n} from '../tinyrx'\nimport { ComponentType } from 'react'\n\nexport interface ListRange {\n  startIndex: number\n  endIndex: number\n}\n\nexport interface ScrollSeekToggle {\n  (velocity: number, range: ListRange): boolean\n}\n\nexport type TSeekPlaceholder = ComponentType<{ height: number; index: number }>\n\nexport interface ScrollSeekConfiguration {\n  enter: ScrollSeekToggle\n  change: (velocity: number, range: ListRange) => void\n  exit: ScrollSeekToggle\n  placeholder: TSeekPlaceholder\n}\n\ninterface ScrollSeekParams {\n  isScrolling$: TObservable<boolean>\n  scrollTop$: TObservable<number>\n  rangeChanged$: TObservable<ListRange>\n}\n\nexport function scrollSeekEngine({ isScrolling$, scrollTop$, rangeChanged$: range$ }: ScrollSeekParams) {\n  const scrollVelocity$ = subject(0)\n  const isSeeking$ = subject(false)\n  const scrollSeekConfiguration$ = subject<ScrollSeekConfiguration | undefined | false>(false)\n\n  isScrolling$\n    .pipe(\n      filter(val => !val),\n      mapTo(0)\n    )\n    .subscribe(scrollVelocity$.next)\n\n  scrollTop$\n    .pipe(\n      throttleTime(100),\n      scan(([_, prev], next) => [prev, next], [0, 0]),\n      map(([prev, next]) => next - prev)\n    )\n    .subscribe(scrollVelocity$.next)\n\n  scrollVelocity$\n    .pipe(\n      withLatestFrom(scrollSeekConfiguration$, isSeeking$, range$),\n      filter(([_, config]) => !!config),\n      map(([speed, config, isSeeking, range]: any) => {\n        const { exit, enter } = config!\n        if (isSeeking) {\n          if (exit(speed, range)) {\n            return false\n          }\n        } else {\n          if (enter(speed, range)) {\n            return true\n          }\n        }\n        return isSeeking\n      }),\n      duc()\n    )\n    .subscribe(isSeeking$.next)\n\n  combineLatest(isSeeking$, scrollVelocity$, range$)\n    .pipe(withLatestFrom(scrollSeekConfiguration$))\n    .subscribe(([[isSeeking, velocity, range], config]) => isSeeking && config && config!.change(velocity, range))\n\n  return { isSeeking$, scrollSeekConfiguration$, scrollVelocity$ }\n}\n","import { subject, TObservable, TSubject, withLatestFrom } from '../tinyrx'\nimport { TScrollLocation } from '../EngineCommons'\nimport { OffsetList } from '../OffsetList'\n\nexport interface InitialTopMostItemIndexParams {\n  initialTopMostItemIndex: number | undefined\n  scrollTop$: TObservable<number>\n  scrollTo$: TSubject<ScrollToOptions>\n  scrollToIndex$: TSubject<TScrollLocation>\n  offsetList$: TObservable<OffsetList>\n}\n\nexport function initialTopMostItemIndexEngine({\n  initialTopMostItemIndex,\n  scrollToIndex$,\n  scrollTop$,\n  scrollTo$,\n  offsetList$,\n}: InitialTopMostItemIndexParams) {\n  const scrolledToTopMostItem$ = subject(!initialTopMostItemIndex)\n\n  scrollTop$\n    .pipe(withLatestFrom(scrollTo$, scrolledToTopMostItem$))\n    .subscribe(([scrollTop, scrollTo, scrolledToTopMostItem]) => {\n      if (scrollTop === scrollTo.top && !scrolledToTopMostItem) {\n        // skip a tick, so that the list$ can grab the scrollTop$ update\n        setTimeout(() => {\n          scrolledToTopMostItem$.next(true)\n        })\n      }\n    })\n\n  offsetList$.pipe(withLatestFrom(scrolledToTopMostItem$)).subscribe(([_, scrolledToTopMostItem]) => {\n    if (!scrolledToTopMostItem) {\n      // hack: wait for the viewport to get populated :(\n      setTimeout(() => {\n        scrollToIndex$.next(initialTopMostItemIndex!)\n      })\n    }\n  })\n\n  return {\n    scrolledToTopMostItem$,\n  }\n}\n","import { TScrollLocation } from '../EngineCommons'\nimport { OffsetList } from '../OffsetList'\nimport { coldSubject, map, subject, TObservable, TSubject, withLatestFrom, filter } from '../tinyrx'\nimport { initialTopMostItemIndexEngine } from './initialTopMostItemEngine'\n\nexport interface ScrollToIndexParams {\n  heightsChanged$: TSubject<[boolean, OffsetList]>\n  offsetList$: TSubject<OffsetList>\n  topListHeight$: TObservable<number>\n  stickyItems$: TObservable<number[]>\n  viewportHeight$: TSubject<number>\n  totalCount$: TObservable<number>\n  totalHeight$: TObservable<number>\n  scrollTop$: TObservable<number>\n  initialTopMostItemIndex: number | undefined\n}\n\nexport function scrollToIndexEngine({\n  offsetList$,\n  topListHeight$,\n  stickyItems$,\n  viewportHeight$,\n  totalCount$,\n  totalHeight$,\n  initialTopMostItemIndex,\n  heightsChanged$,\n  scrollTop$,\n}: ScrollToIndexParams) {\n  const scrollToIndex$ = coldSubject<TScrollLocation>()\n  const scrollToIndexRequestPending$ = subject(false)\n  const scrollTopReportedAfterScrollToIndex$ = subject(true)\n  const scrollTo$ = coldSubject<ScrollToOptions>()\n\n  const { scrolledToTopMostItem$ } = initialTopMostItemIndexEngine({\n    scrollTo$,\n    offsetList$,\n    scrollToIndex$,\n    scrollTop$,\n    initialTopMostItemIndex,\n  })\n\n  heightsChanged$.pipe(withLatestFrom(scrolledToTopMostItem$)).subscribe(([[changed], scrolledToTopMostItem]) => {\n    if (!changed && scrolledToTopMostItem) {\n      scrollToIndexRequestPending$.next(false)\n      scrollTopReportedAfterScrollToIndex$.next(true)\n    }\n  })\n\n  scrollToIndex$\n    .pipe(\n      withLatestFrom(offsetList$, topListHeight$, stickyItems$, viewportHeight$, totalCount$, totalHeight$),\n      map(([location, offsetList, topListHeight, stickyItems, viewportHeight, totalCount, totalHeight]) => {\n        if (offsetList.empty()) {\n          setTimeout(() => scrollToIndex$.next(location))\n          return\n        }\n\n        if (typeof location === 'number') {\n          location = { index: location, align: 'start', behavior: 'auto' }\n        }\n        let { index, align = 'start' } = location\n\n        index = Math.max(0, index, Math.min(totalCount - 1, index))\n\n        let offset = offsetList.offsetOf(index)\n        if (align === 'end') {\n          offset = offset - viewportHeight + offsetList.itemAt(index).size\n        } else if (align === 'center') {\n          offset = Math.round(offset - viewportHeight / 2 + offsetList.itemAt(index).size / 2)\n        } else {\n          if (stickyItems.indexOf(index) === -1) {\n            offset -= topListHeight\n          }\n        }\n\n        scrollTopReportedAfterScrollToIndex$.next(false)\n        return {\n          top: Math.max(0, Math.min(offset, Math.floor(totalHeight - viewportHeight))),\n          behavior: location.behavior ?? 'auto',\n        }\n      }),\n      filter(value => value !== undefined)\n    )\n    .subscribe(scrollTo$.next as any)\n\n  scrollTop$.pipe(withLatestFrom(scrollTopReportedAfterScrollToIndex$)).subscribe(([_, scrollTopReported]) => {\n    if (!scrollTopReported) {\n      scrollTopReportedAfterScrollToIndex$.next(true)\n      scrollToIndexRequestPending$.next(true)\n    }\n  })\n\n  // if the list has received new heights, the scrollTo call calculations were wrong;\n  // we will retry by re-requesting the same index\n  offsetList$\n    .pipe(withLatestFrom(scrollToIndexRequestPending$, scrollToIndex$))\n    .subscribe(([_, scrollToIndexRequestPending, scrollToIndex]) => {\n      if (scrollToIndexRequestPending) {\n        scrollToIndex$.next(scrollToIndex)\n      }\n    })\n\n  return {\n    scrollToIndex$,\n    scrollTo$,\n    scrolledToTopMostItem$,\n  }\n}\n","import { TObservable, subject, combineLatest, filter, withLatestFrom, map, TSubject } from '../tinyrx'\nimport { OffsetList } from '../OffsetList'\nimport { Transposer, ListItem } from '../GroupIndexTransposer'\n\ninterface TopItemCountParams {\n  offsetList$: TObservable<OffsetList>\n  totalCount$: TObservable<number>\n  topList$: TSubject<ListItem[]>\n  viewportHeight$: TObservable<number>\n  transposer$: TObservable<Transposer>\n}\nexport function topItemCountEngine({\n  topList$,\n  transposer$,\n  viewportHeight$,\n  totalCount$,\n  offsetList$,\n}: TopItemCountParams) {\n  const topItemCount$ = subject<number>()\n\n  combineLatest(offsetList$, topItemCount$, totalCount$, viewportHeight$)\n    .pipe(\n      filter(params => params[1] > 0 && params[3] > 0),\n      withLatestFrom(transposer$),\n      map(([[offsetList, topItemCount, totalCount], transposer]) => {\n        const endIndex = Math.max(0, Math.min(topItemCount - 1, totalCount))\n        return transposer.transpose(offsetList.indexRange(0, endIndex))\n      })\n    )\n    .subscribe(topList$.next)\n  return { topItemCount$ }\n}\n","import { subject, map } from '../tinyrx'\nimport { ListItem } from '../GroupIndexTransposer'\n\nexport function topListEngine() {\n  const topList$ = subject<ListItem[]>([])\n\n  const topListHeight$ = topList$.pipe(map(items => items.reduce((total, item) => total + item.size, 0)))\n\n  const minListIndex$ = topList$.pipe(\n    map(topList => {\n      return topList.length && topList[topList.length - 1].index + 1\n    })\n  )\n\n  return {\n    topList$,\n    topListHeight$,\n    minListIndex$,\n  }\n}\n","import { TObservable, TSubscription } from './tinyrx'\n\nexport interface TOutput<T> {\n  (callback: TCallback<T> | undefined): void\n}\n\nexport interface TInput<T> {\n  (val: T): void\n}\n\ntype TCallback<T> = (val: T) => void\n\nexport function makeOutput<T>(observable: TObservable<T>): TOutput<T> {\n  let unsubscribe: TSubscription | undefined\n\n  return (callback: TCallback<T> | undefined) => {\n    if (unsubscribe) {\n      unsubscribe()\n    }\n    if (callback) {\n      unsubscribe = observable.subscribe(callback)\n    }\n  }\n}\n\nexport function makeInput<T>(subject: { next: (value: T) => void }): TInput<T> {\n  return subject.next\n}\n","import * as React from 'react'\nimport { ReactElement } from 'react'\nimport { coldSubject, combineLatest, duc, filter, map, subject, withLatestFrom } from '../src/tinyrx'\nimport { buildIsScrolling } from './EngineCommons'\nimport { adjustForPrependedItemsEngine } from './engines/adjustForPrependedItemsEngine'\nimport { followOutputEngine } from './engines/followOutputEngine'\nimport { groupCountEngine } from './engines/groupCountEgine'\nimport { listEngine } from './engines/listEngine'\nimport { maxRangeSizeEngine } from './engines/maxRangeSizeEngine'\nimport { offsetListEngine } from './engines/offsetListEngine'\nimport { scrolledToBottomEngine } from './engines/scrolledToBottomEngine'\nimport { ListRange, scrollSeekEngine } from './engines/scrollSeekEngine'\nimport { scrollToIndexEngine } from './engines/scrollToIndexEngine'\nimport { topItemCountEngine } from './engines/topItemCountEngine'\nimport { topListEngine } from './engines/topListEngine'\nimport { ListItem, StubIndexTransposer, Transposer } from './GroupIndexTransposer'\nimport { makeInput, makeOutput } from './rxio'\n\nexport interface ItemHeight {\n  start: number\n  end: number\n  size: number\n}\n\ninterface TVirtuosoConstructorParams {\n  overscan?: number\n  totalCount?: number\n  topItems?: number\n  itemHeight?: number\n  defaultItemHeight?: number\n  initialTopMostItemIndex?: number\n}\n\nconst VirtuosoStore = ({\n  overscan = 0,\n  totalCount = 0,\n  itemHeight,\n  initialTopMostItemIndex,\n  defaultItemHeight,\n}: TVirtuosoConstructorParams) => {\n  const transposer$ = subject<Transposer>(new StubIndexTransposer())\n  const viewportHeight$ = subject(0)\n  const scrollTop$ = subject(0, false)\n  const isScrolling$ = buildIsScrolling(scrollTop$)\n\n  const { topList$, minListIndex$, topListHeight$ } = topListEngine()\n  const {\n    stickyItems$,\n    initialItemCount$,\n    itemHeights$,\n    offsetList$,\n    totalCount$,\n    headerHeight$,\n    footerHeight$,\n    totalHeight$,\n    heightsChanged$,\n  } = offsetListEngine({\n    totalCount,\n    itemHeight,\n    defaultItemHeight,\n    initialTopMostItemIndex,\n    viewportHeight$,\n    scrollTop$,\n    transposer$,\n    topList$,\n  })\n\n  const { groupCounts$, groupIndices$ } = groupCountEngine({ totalCount$, transposer$, stickyItems$ })\n\n  const { scrolledToBottom$ } = scrolledToBottomEngine({ totalHeight$, viewportHeight$, scrollTop$ })\n\n  const { scrolledToTopMostItem$, scrollToIndex$, scrollTo$ } = scrollToIndexEngine({\n    initialTopMostItemIndex,\n    scrollTop$,\n    offsetList$,\n    viewportHeight$,\n    totalHeight$,\n    stickyItems$,\n    totalCount$,\n    topListHeight$,\n    heightsChanged$,\n  })\n\n  const { listHeight$, list$, listOffset$, startReached$, endReached$ } = listEngine({\n    overscan,\n    defaultItemHeight,\n    viewportHeight$,\n    scrollTop$,\n    totalHeight$,\n    topListHeight$,\n    headerHeight$,\n    footerHeight$,\n    minListIndex$,\n    totalCount$,\n    offsetList$,\n    scrolledToTopMostItem$,\n    transposer$,\n  })\n\n  const { adjustForPrependedItems$, adjustmentInProgress$ } = adjustForPrependedItemsEngine({\n    offsetList$,\n    scrollTop$,\n    scrollTo$,\n  })\n\n  const { maxRangeSize$ } = maxRangeSizeEngine({ scrollTo$, offsetList$, scrollTop$, list$ })\n\n  const { topItemCount$ } = topItemCountEngine({ offsetList$, totalCount$, transposer$, viewportHeight$, topList$ })\n\n  const { followOutput$ } = followOutputEngine({ totalCount$, scrollToIndex$, scrolledToBottom$ })\n\n  const stickyItemsOffset$ = listOffset$.pipe(map(offset => -offset))\n\n  const rangeChanged$ = coldSubject<ListRange>()\n\n  list$\n    .pipe(\n      withLatestFrom(adjustmentInProgress$),\n      filter<[ListItem[], boolean]>(([list, inProgress]) => list.length !== 0 && !inProgress),\n      map(([list]) => {\n        const { index: startIndex } = list[0]\n        const { index: endIndex } = list[list.length - 1]\n        return { startIndex, endIndex }\n      }),\n      duc((current, next) => !current || current.startIndex !== next.startIndex || current.endIndex !== next.endIndex)\n    )\n    .subscribe(rangeChanged$.next)\n\n  const { isSeeking$, scrollVelocity$, scrollSeekConfiguration$ } = scrollSeekEngine({\n    scrollTop$,\n    isScrolling$,\n    rangeChanged$,\n  })\n\n  const MAX_OFFSET_HEIGHT = 15000000\n  const domTotalHeight$ = totalHeight$.pipe(map(value => Math.min(value, MAX_OFFSET_HEIGHT)))\n\n  const scrollTopMultiplier$ = combineLatest(totalHeight$, domTotalHeight$, viewportHeight$).pipe(\n    map(([totalHeight, domTotalHeight, viewportHeight]) => {\n      if (totalHeight === domTotalHeight || domTotalHeight === viewportHeight) {\n        return 1\n      }\n      return (totalHeight - viewportHeight) / (domTotalHeight - viewportHeight)\n    })\n  )\n\n  const domScrollTop$ = subject(0, false)\n\n  const domListOffset$ = combineLatest(listOffset$, scrollTopMultiplier$).pipe(\n    map(([offset, multiplier]) => offset / multiplier)\n  )\n\n  combineLatest(domScrollTop$, scrollTopMultiplier$)\n    .pipe(map(([domScrollTop, multiplier]) => domScrollTop * multiplier))\n    .subscribe(scrollTop$.next)\n\n  const computeItemKey$ = subject((itemIndex: number) => itemIndex as React.Key)\n  const renderProp$ = subject((index: number, _groupIndex?: number) => index as any)\n  const groupRenderProp$ = subject((index: number) => index as any)\n  const itemContainer$ = subject<React.ComponentType<any> | string>('div')\n  const groupContainer$ = subject<React.ComponentType<any> | string>('div')\n  const itemRender$ = subject<any>(false)\n  const dataKey$ = subject<string | symbol | undefined>(Symbol('data-key'))\n\n  combineLatest(\n    renderProp$,\n    groupRenderProp$,\n    scrollSeekConfiguration$,\n    computeItemKey$,\n    itemContainer$,\n    groupContainer$,\n    dataKey$\n  )\n    .pipe(\n      map(([render, groupRender, scrollSeek, computeItemKey, ItemContainer, GroupContainer, _dataKey]) => {\n        return {\n          render: (item: any, { key, renderPlaceholder, ...itemProps }: any) => {\n            if (computeItemKey) {\n              key = computeItemKey(item.index)\n            }\n\n            if (item.type === 'group') {\n              return React.createElement(GroupContainer, { key, ...itemProps }, groupRender(item.groupIndex))\n            } else {\n              let children: ReactElement\n              if (scrollSeek && renderPlaceholder) {\n                children = React.createElement(scrollSeek.placeholder, {\n                  height: itemProps['data-known-size'],\n                  index: item.index,\n                })\n              } else {\n                children = render(item.transposedIndex, item.groupIndex)\n              }\n\n              return React.createElement(ItemContainer, { ...itemProps, key }, children)\n            }\n          },\n        }\n      })\n    )\n    .subscribe(itemRender$.next)\n\n  return {\n    groupCounts: makeInput(groupCounts$),\n    itemHeights: makeInput(itemHeights$),\n    headerHeight: makeInput(headerHeight$),\n    footerHeight: makeInput(footerHeight$),\n    listHeight: makeInput(listHeight$),\n    viewportHeight: makeInput(viewportHeight$),\n    scrollTop: makeInput(domScrollTop$),\n    topItemCount: makeInput(topItemCount$),\n    totalCount: makeInput(totalCount$),\n    scrollToIndex: makeInput(scrollToIndex$),\n    initialItemCount: makeInput(initialItemCount$),\n    followOutput: makeInput(followOutput$),\n    adjustForPrependedItems: makeInput(adjustForPrependedItems$),\n    maxRangeSize: makeInput(maxRangeSize$),\n    scrollSeekConfiguration: makeInput(scrollSeekConfiguration$),\n\n    renderProp: makeInput(renderProp$),\n    groupRenderProp: makeInput(groupRenderProp$),\n    computeItemKey: makeInput(computeItemKey$),\n    itemContainer: makeInput(itemContainer$),\n    groupContainer: makeInput(groupContainer$),\n    dataKey: makeInput(dataKey$),\n\n    itemRender: makeOutput(itemRender$),\n\n    list: makeOutput(list$),\n    isSeeking: makeOutput(isSeeking$),\n    scrollVelocity: makeOutput(scrollVelocity$),\n    itemsRendered: makeOutput(list$),\n    topList: makeOutput(topList$),\n    listOffset: makeOutput(domListOffset$),\n    totalHeight: makeOutput(domTotalHeight$),\n    startReached: makeOutput(startReached$),\n    endReached: makeOutput(endReached$),\n    atBottomStateChange: makeOutput(scrolledToBottom$),\n    totalListHeightChanged: makeOutput(totalHeight$),\n    rangeChanged: makeOutput(rangeChanged$),\n    isScrolling: makeOutput(isScrolling$),\n    stickyItems: makeOutput(stickyItems$),\n    groupIndices: makeOutput(groupIndices$),\n    stickyItemsOffset: makeOutput(stickyItemsOffset$),\n    scrollTo: makeOutput(scrollTo$),\n  }\n}\n\nexport { VirtuosoStore }\n","import { CSSProperties } from 'react'\n\nexport const viewportStyle: CSSProperties = {\n  top: 0,\n  position: 'absolute',\n  height: '100%',\n  width: '100%',\n}\n","import { useEffect, useRef, useState } from 'react'\nimport ResizeObserver from 'resize-observer-polyfill'\nimport { TInput, TOutput } from './rxio'\n\nexport type CallbackRefParam = HTMLElement | null\nexport type CallbackRef = (ref: CallbackRefParam) => void\n\ntype UseHeight = (\n  input: TInput<number>,\n  onMount?: (ref: CallbackRefParam) => void,\n  onResize?: (ref: HTMLElement) => void\n) => CallbackRef\n\nexport const useHeight: UseHeight = (input, onMount, onResize) => {\n  const ref = useRef<CallbackRefParam>(null)\n  const animationFrameID = useRef<number>(0)\n  const observer = new ResizeObserver(entries => {\n    const newHeight = Math.round(entries[0].contentRect.height)\n    if (onResize) {\n      animationFrameID.current = window.requestAnimationFrame(() => {\n        const element = entries[0].target as HTMLElement\n        if (document.body.contains(element)) {\n          onResize(element)\n        }\n      })\n    }\n    input(newHeight)\n  })\n\n  const callbackRef = (elRef: CallbackRefParam) => {\n    if (elRef) {\n      observer.observe(elRef)\n      if (onMount) {\n        onMount(elRef)\n      }\n      ref.current = elRef\n    } else {\n      observer.unobserve(ref.current!)\n      ref.current = null\n    }\n  }\n\n  useEffect(() => () => window.cancelAnimationFrame(animationFrameID.current), [])\n  return callbackRef\n}\n\nfunction callbackToValue<T>(output: (callback: (val: T) => void) => void, defaultValue: T) {\n  return () => {\n    let result = defaultValue\n    output(val => {\n      result = val\n    })\n    return result\n  }\n}\n\nexport function useOutput<T>(output: TOutput<T>, initialValue: T): T {\n  const [value, setValue] = useState(callbackToValue<T>(output, initialValue))\n\n  useEffect(() => {\n    output(setValue)\n    return () => output(undefined)\n  }, [output])\n  return value\n}\n\ntype UseSize = (callback: (params: { element: HTMLElement; width: number; height: number }) => void) => CallbackRef\n\nexport const useSize: UseSize = callback => {\n  const ref = useRef<CallbackRefParam>(null)\n  const currentSize = useRef([0, 0])\n\n  const observer = new ResizeObserver(entries => {\n    const { width, height } = entries[0].contentRect\n    if (currentSize.current[0] !== width || currentSize.current[1] !== height) {\n      currentSize.current = [width, height]\n      callback({\n        element: entries[0].target as HTMLElement,\n        width: Math.round(width),\n        height: Math.round(height),\n      })\n    }\n  })\n\n  const callbackRef = (elRef: CallbackRefParam) => {\n    if (elRef) {\n      observer.observe(elRef)\n      ref.current = elRef\n    } else {\n      observer.unobserve(ref.current!)\n      ref.current = null\n    }\n  }\n\n  return callbackRef\n}\n\nexport function simpleMemoize<T extends () => any>(func: T): T {\n  let called = false\n  let result: any\n\n  return (() => {\n    if (!called) {\n      called = true\n      result = func()\n    }\n    return result\n  }) as T\n}\n\nconst WEBKIT_STICKY = '-webkit-sticky'\nconst STICKY = 'sticky'\n\nexport const positionStickyCssValue = simpleMemoize(() => {\n  const node = document.createElement('div')\n  node.style.position = WEBKIT_STICKY\n  return node.style.position === WEBKIT_STICKY ? WEBKIT_STICKY : STICKY\n})\n","import * as React from 'react'\nimport { FC } from 'react'\n\nexport const VirtuosoFiller: FC<{ height: number }> = ({ height }) => (\n  <div style={{ height: `${height}px`, position: 'absolute', top: 0 }}>&nbsp;</div>\n)\n","import * as React from 'react'\nimport { useContext, ReactElement, CSSProperties, ReactNode, createElement, ComponentType } from 'react'\nimport { useOutput, positionStickyCssValue } from './Utils'\nimport { VirtuosoContext } from './VirtuosoContext'\nimport { ListItem } from './GroupIndexTransposer'\n\nexport interface TRenderProps {\n  key: React.Key\n  'data-index': number\n  'data-known-size': number\n  renderPlaceholder: boolean\n  style?: CSSProperties\n}\nexport type TRender = (item: ListItem, props: TRenderProps) => ReactElement\n\nexport interface VirtuosoListProps {\n  emptyComponent?: ComponentType\n}\n\nexport const VirtuosoList: React.FC<VirtuosoListProps> = React.memo(({ emptyComponent }) => {\n  const { isSeeking, topList, list, itemRender } = useContext(VirtuosoContext)!\n  const items = useOutput<ListItem[]>(list, [])\n  const topItems = useOutput<ListItem[]>(topList, [])\n  const render = useOutput(itemRender, false as any)\n  const renderPlaceholder = useOutput(isSeeking, false)\n\n  const renderedItems: ReactNode[] = []\n  let topOffset = 0\n  const renderedTopItemIndices: number[] = []\n\n  const marginTop = topItems.reduce((acc, item) => {\n    return acc + item.size\n  }, 0)\n\n  topItems.forEach((item, index) => {\n    const itemIndex = item.index\n    renderedTopItemIndices.push(itemIndex)\n\n    const style: CSSProperties = {\n      top: `${topOffset}px`,\n      marginTop: index === 0 ? `${-marginTop}px` : undefined,\n      zIndex: 2,\n      position: positionStickyCssValue(),\n    }\n\n    const props = {\n      key: itemIndex,\n      'data-index': itemIndex,\n      'data-known-size': item.size,\n      renderPlaceholder,\n      style,\n    }\n\n    render && renderedItems.push(render.render(item, props))\n    topOffset += item.size\n  })\n\n  items.forEach(item => {\n    if (renderedTopItemIndices.indexOf(item.index) > -1) {\n      return\n    }\n\n    render &&\n      renderedItems.push(\n        render.render(item, {\n          key: item.index,\n          'data-index': item.index,\n          'data-known-size': item.size,\n          renderPlaceholder,\n        })\n      )\n  })\n\n  if (renderedItems.length === 0 && emptyComponent) return createElement(emptyComponent)\n  return <>{renderedItems}</>\n})\n","import * as React from 'react'\nimport { FC, CSSProperties, useCallback, useRef } from 'react'\n\nconst scrollerStyle: React.CSSProperties = {\n  height: '100%',\n  overflowY: 'auto',\n  WebkitOverflowScrolling: 'touch',\n  position: 'relative',\n  outline: 'none',\n}\n\nexport type TScrollContainer = FC<{\n  style: CSSProperties\n  className?: string\n  reportScrollTop: (scrollTop: number) => void\n  scrollTo: (callback: (scrollTop: ScrollToOptions) => void) => void\n}>\n\nconst DefaultScrollContainer: TScrollContainer = ({ className, style, reportScrollTop, scrollTo, children }) => {\n  const elRef = useRef<HTMLElement | null>(null)\n  const smoothScrollTarget = useRef<number | null>(null)\n  const currentScrollTop = useRef<number | null>()\n\n  const onScroll: EventListener = useCallback(\n    (e: Event) => {\n      const scrollTop = (e.target as HTMLDivElement).scrollTop\n      currentScrollTop.current = scrollTop\n      if (smoothScrollTarget.current !== null) {\n        if (smoothScrollTarget.current === scrollTop) {\n          // console.log('reporting smooth scrolling')\n          smoothScrollTarget.current = null\n          reportScrollTop(scrollTop)\n        } else {\n          // console.log('skip reporting')\n        }\n      } else {\n        reportScrollTop(scrollTop)\n      }\n    },\n    [reportScrollTop]\n  )\n\n  const ref = useCallback(\n    (theRef: HTMLElement | null) => {\n      if (theRef) {\n        theRef.addEventListener('scroll', onScroll, { passive: true })\n        elRef.current = theRef\n      } else {\n        if (elRef.current) {\n          elRef.current.removeEventListener('scroll', onScroll)\n        }\n      }\n    },\n    [onScroll]\n  )\n\n  scrollTo(location => {\n    if (currentScrollTop.current !== location.top) {\n      if (location.behavior === 'smooth') {\n        smoothScrollTarget.current = location.top!\n      }\n      elRef.current && elRef.current!.scrollTo(location)\n    }\n  })\n\n  return (\n    <div ref={ref} style={style} tabIndex={0} className={className}>\n      {children}\n    </div>\n  )\n}\n\nexport const VirtuosoScroller: FC<{\n  className?: string\n  style: CSSProperties\n  ScrollContainer?: TScrollContainer\n  scrollTop: (scrollTop: number) => void\n  scrollTo: (callback: (scrollTop: ScrollToOptions) => void) => void\n}> = ({ children, style, className, ScrollContainer = DefaultScrollContainer, scrollTop, scrollTo }) => {\n  return (\n    <ScrollContainer\n      style={{ ...scrollerStyle, ...style }}\n      reportScrollTop={scrollTop}\n      scrollTo={scrollTo}\n      className={className}\n    >\n      {children}\n    </ScrollContainer>\n  )\n}\n","import * as React from 'react'\nimport { CSSProperties, FC, ReactElement, useContext, ComponentType } from 'react'\nimport { ItemHeight } from 'VirtuosoStore'\nimport { viewportStyle } from './Style'\nimport { CallbackRef, useHeight, useOutput } from './Utils'\nimport { VirtuosoContext } from './VirtuosoContext'\nimport { VirtuosoFiller } from './VirtuosoFiller'\nimport { VirtuosoList } from './VirtuosoList'\nimport { TScrollContainer, VirtuosoScroller } from './VirtuosoScroller'\n\nexport const DefaultHeaderContainer: React.FC<{ headerRef: CallbackRef }> = ({ children, headerRef }) => (\n  <header ref={headerRef}>{children}</header>\n)\n\nexport const DefaultFooterContainer: React.FC<{ footerRef: CallbackRef }> = ({ children, footerRef }) => (\n  <footer ref={footerRef}>{children}</footer>\n)\n\nexport const DefaultListContainer: React.FC<{ listRef: CallbackRef; style: CSSProperties }> = ({\n  children,\n  listRef,\n  style,\n}) => {\n  return (\n    <div ref={listRef} style={style}>\n      {children}\n    </div>\n  )\n}\n\nexport type TListContainer = typeof DefaultListContainer\nexport type THeaderContainer = typeof DefaultHeaderContainer\nexport type TFooterContainer = typeof DefaultFooterContainer\n\nexport { TScrollContainer }\n\nconst VirtuosoHeader: FC<{ header: () => ReactElement; HeaderContainer?: THeaderContainer }> = ({\n  header,\n  HeaderContainer = DefaultHeaderContainer,\n}) => {\n  const headerCallbackRef = useHeight(useContext(VirtuosoContext)!.headerHeight)\n  return <HeaderContainer headerRef={headerCallbackRef}>{header()}</HeaderContainer>\n}\n\nconst VirtuosoFooter: FC<{ footer: () => ReactElement; FooterContainer?: TFooterContainer }> = ({\n  footer,\n  FooterContainer = DefaultFooterContainer,\n}) => {\n  const footerCallbackRef = useHeight(useContext(VirtuosoContext)!.footerHeight)\n  return <FooterContainer footerRef={footerCallbackRef}>{footer()}</FooterContainer>\n}\n\nconst getHeights = (children: HTMLCollection) => {\n  const results: ItemHeight[] = []\n  for (let i = 0, len = children.length; i < len; i++) {\n    const child = children.item(i) as HTMLElement\n\n    if (!child || child.dataset.index === undefined) {\n      continue\n    }\n\n    const index = parseInt(child.dataset.index!)\n    const knownSize = parseInt(child.dataset.knownSize!)\n    const size = child.offsetHeight\n\n    if (size === knownSize || size === 0) {\n      continue\n    }\n\n    const lastResult = results[results.length - 1]\n    if (results.length === 0 || lastResult.size !== size || lastResult.end !== index - 1) {\n      results.push({ start: index, end: index, size })\n    } else {\n      results[results.length - 1].end++\n    }\n  }\n\n  return results\n}\n\nconst ListWrapper: React.FC<{ fixedItemHeight: boolean; ListContainer: TListContainer }> = ({\n  fixedItemHeight,\n  children,\n  ListContainer,\n}) => {\n  const { listHeight, itemHeights, listOffset } = useContext(VirtuosoContext)!\n  const translate = useOutput<number>(listOffset, 0)\n  const style = { marginTop: `${translate}px` }\n\n  const listCallbackRef = useHeight(\n    listHeight,\n    () => {},\n    ref => {\n      if (!fixedItemHeight) {\n        const measuredItemHeights = getHeights(ref!.children)\n        itemHeights(measuredItemHeights)\n      }\n    }\n  )\n\n  return (\n    <ListContainer listRef={listCallbackRef} style={style}>\n      {children}\n    </ListContainer>\n  )\n}\n\nexport const VirtuosoView: React.FC<{\n  style: CSSProperties\n  className?: string\n  header?: () => ReactElement\n  footer?: () => ReactElement\n  ScrollContainer?: TScrollContainer\n  ListContainer: TListContainer\n  HeaderContainer?: THeaderContainer\n  FooterContainer?: TFooterContainer\n  fixedItemHeight: boolean\n  emptyComponent?: ComponentType\n}> = ({\n  style,\n  header,\n  footer,\n  fixedItemHeight,\n  ScrollContainer,\n  ListContainer,\n  HeaderContainer,\n  FooterContainer,\n  className,\n  emptyComponent,\n}) => {\n  const { scrollTo, scrollTop, totalHeight, viewportHeight } = useContext(VirtuosoContext)!\n  const fillerHeight = useOutput<number>(totalHeight, 0)\n  const reportScrollTop = (st: number) => {\n    scrollTop(Math.max(st, 0))\n  }\n\n  const viewportCallbackRef = useHeight(viewportHeight)\n\n  return (\n    <VirtuosoScroller\n      style={style}\n      ScrollContainer={ScrollContainer}\n      className={className}\n      scrollTo={scrollTo}\n      scrollTop={reportScrollTop}\n    >\n      <div ref={viewportCallbackRef} style={viewportStyle}>\n        <ListWrapper fixedItemHeight={fixedItemHeight} ListContainer={ListContainer}>\n          {header && <VirtuosoHeader header={header} HeaderContainer={HeaderContainer} />}\n          <VirtuosoList emptyComponent={emptyComponent} />\n          {footer && <VirtuosoFooter footer={footer} FooterContainer={FooterContainer} />}\n        </ListWrapper>\n      </div>\n\n      <VirtuosoFiller height={fillerHeight} />\n    </VirtuosoScroller>\n  )\n}\n","import * as React from 'react'\nimport {\n  CSSProperties,\n  FC,\n  forwardRef,\n  ReactElement,\n  useImperativeHandle,\n  useEffect,\n  useState,\n  ComponentType,\n} from 'react'\nimport { TScrollLocation } from './EngineCommons'\nimport { ListRange, ScrollSeekConfiguration } from './engines/scrollSeekEngine'\nimport { ListItem } from './GroupIndexTransposer'\nimport { TSubscriber } from './tinyrx'\nimport { VirtuosoContext } from './VirtuosoContext'\nimport { TRenderProps } from './VirtuosoList'\nimport { VirtuosoStore } from './VirtuosoStore'\nimport {\n  DefaultListContainer,\n  THeaderContainer,\n  TFooterContainer,\n  TListContainer,\n  TScrollContainer,\n  VirtuosoView,\n} from './VirtuosoView'\n\nexport type VirtuosoState = ReturnType<typeof VirtuosoStore>\n\nexport type TItemContainer = React.FC<Omit<TRenderProps, 'renderPlaceholder' | 'scrollVelocity'>>\n\nexport interface VirtuosoProps {\n  totalCount: number\n  overscan?: number\n  topItems?: number\n  header?: () => ReactElement\n  footer?: () => ReactElement\n  item: (index: number) => ReactElement\n  computeItemKey?: (index: number) => React.Key\n  prependItemCount?: number\n  itemHeight?: number\n  defaultItemHeight?: number\n  startReached?: () => void\n  endReached?: (index: number) => void\n  scrollingStateChange?: TSubscriber<boolean>\n  atBottomStateChange?: TSubscriber<boolean>\n  itemsRendered?: TSubscriber<ListItem[]>\n  rangeChanged?: TSubscriber<ListRange>\n  totalListHeightChanged?: TSubscriber<number>\n  style?: CSSProperties\n  dataKey?: string\n  className?: string\n  initialItemCount?: number\n  initialTopMostItemIndex?: number\n  followOutput?: boolean\n  ScrollContainer?: TScrollContainer\n  HeaderContainer?: THeaderContainer\n  FooterContainer?: TFooterContainer\n  ListContainer?: TListContainer\n  ItemContainer?: TItemContainer\n  maxHeightCacheSize?: number\n  scrollSeek?: ScrollSeekConfiguration\n  emptyComponent?: ComponentType\n}\n\nexport interface TVirtuosoPresentationProps {\n  contextValue: VirtuosoState\n  header?: () => ReactElement\n  footer?: () => ReactElement\n  style?: CSSProperties\n  className?: string\n  itemHeight?: number\n  ScrollContainer?: TScrollContainer\n  HeaderContainer?: THeaderContainer\n  FooterContainer?: TFooterContainer\n  ListContainer?: TListContainer\n  emptyComponent?: ComponentType\n}\n\nexport { TScrollContainer, TListContainer }\n\nconst DEFAULT_STYLE = {}\nexport const VirtuosoPresentation: FC<TVirtuosoPresentationProps> = React.memo(\n  ({\n    contextValue,\n    style,\n    className,\n    header,\n    footer,\n    itemHeight,\n    ScrollContainer,\n    ListContainer,\n    HeaderContainer,\n    FooterContainer,\n    emptyComponent,\n  }) => {\n    return (\n      <VirtuosoContext.Provider value={contextValue}>\n        <VirtuosoView\n          style={style || DEFAULT_STYLE}\n          className={className}\n          header={header}\n          footer={footer}\n          fixedItemHeight={itemHeight !== undefined}\n          ScrollContainer={ScrollContainer}\n          HeaderContainer={HeaderContainer}\n          FooterContainer={FooterContainer}\n          ListContainer={ListContainer || DefaultListContainer}\n          emptyComponent={emptyComponent}\n        />\n      </VirtuosoContext.Provider>\n    )\n  }\n)\n\nexport interface VirtuosoMethods {\n  scrollToIndex(location: TScrollLocation): void\n  adjustForPrependedItems(count: number): void\n}\n\nexport const Virtuoso = forwardRef<VirtuosoMethods, VirtuosoProps>((props, ref) => {\n  const [state] = useState(() => VirtuosoStore(props))\n  useImperativeHandle(\n    ref,\n    () => ({\n      scrollToIndex: (location: TScrollLocation) => {\n        state.scrollToIndex(location)\n      },\n\n      adjustForPrependedItems: (count: number) => {\n        state.adjustForPrependedItems(count)\n      },\n    }),\n    [state]\n  )\n\n  useEffect(() => {\n    state.isScrolling(props.scrollingStateChange)\n    state.atBottomStateChange(props.atBottomStateChange)\n    state.startReached(props.startReached)\n    state.endReached(props.endReached)\n    state.topItemCount(props.topItems || 0)\n    state.totalCount(props.totalCount)\n    props.initialItemCount && state.initialItemCount(props.initialItemCount)\n    state.itemsRendered(props.itemsRendered)\n    state.totalListHeightChanged(props.totalListHeightChanged)\n    state.followOutput(!!props.followOutput)\n    state.maxRangeSize(props.maxHeightCacheSize || Infinity)\n    state.rangeChanged(props.rangeChanged)\n    state.scrollSeekConfiguration(props.scrollSeek)\n    state.computeItemKey(props.computeItemKey || (key => key))\n    state.itemContainer(props.ItemContainer || 'div')\n    state.renderProp(props.item)\n    state.dataKey(props.dataKey)\n\n    return () => {\n      state.itemsRendered(undefined)\n      state.totalListHeightChanged(undefined)\n    }\n  }, [\n    state,\n    props.scrollingStateChange,\n    props.atBottomStateChange,\n    props.startReached,\n    props.endReached,\n    props.topItems,\n    props.totalCount,\n    props.initialItemCount,\n    props.itemsRendered,\n    props.totalListHeightChanged,\n    props.followOutput,\n    props.maxHeightCacheSize,\n    props.rangeChanged,\n    props.scrollSeek,\n    props.item,\n    props.ItemContainer,\n    props.computeItemKey,\n    props.dataKey,\n  ])\n\n  return (\n    <VirtuosoPresentation\n      contextValue={state}\n      style={props.style}\n      className={props.className}\n      header={props.header}\n      footer={props.footer}\n      itemHeight={props.itemHeight}\n      ScrollContainer={props.ScrollContainer}\n      HeaderContainer={props.HeaderContainer}\n      FooterContainer={props.FooterContainer}\n      ListContainer={props.ListContainer}\n      emptyComponent={props.emptyComponent}\n    />\n  )\n})\n\nVirtuoso.displayName = 'Virtuoso'\n","import * as React from 'react'\nimport { forwardRef, ReactElement, useImperativeHandle, useState, useEffect } from 'react'\nimport { TScrollLocation } from './EngineCommons'\nimport { TItemContainer, VirtuosoPresentation, VirtuosoProps } from './Virtuoso'\nimport { VirtuosoStore } from './VirtuosoStore'\n\ntype GroupedVirtuosoProps = Pick<VirtuosoProps, Exclude<keyof VirtuosoProps, 'totalCount' | 'topItems' | 'item'>> & {\n  groupCounts: number[]\n  group: (groupIndex: number) => ReactElement\n  item: (index: number, groupIndex?: number) => ReactElement\n  groupIndices?: (indices: number[]) => void\n  GroupContainer?: TItemContainer\n}\n\nexport interface GroupedVirtuosoMethods {\n  scrollToIndex(location: TScrollLocation): void\n}\n\nexport const GroupedVirtuoso = forwardRef<GroupedVirtuosoMethods, GroupedVirtuosoProps>((props, ref) => {\n  const [state] = useState(VirtuosoStore(props))\n  useImperativeHandle(\n    ref,\n    () => ({\n      scrollToIndex: (location: TScrollLocation) => {\n        state.scrollToIndex(location)\n      },\n    }),\n    [state]\n  )\n\n  useEffect(() => {\n    state.startReached(props.startReached)\n    state.endReached(props.endReached)\n    state.rangeChanged(props.rangeChanged)\n    state.atBottomStateChange(props.atBottomStateChange)\n    state.isScrolling(props.scrollingStateChange)\n    state.groupCounts(props.groupCounts)\n    state.groupIndices(props.groupIndices)\n    state.itemsRendered(props.itemsRendered)\n    state.totalListHeightChanged(props.totalListHeightChanged)\n    state.renderProp(props.item)\n    state.groupRenderProp(props.group)\n    state.itemContainer(props.ItemContainer || 'div')\n    state.groupContainer(props.GroupContainer || 'div')\n    state.scrollSeekConfiguration(props.scrollSeek)\n\n    return () => {\n      state.itemsRendered(undefined)\n      state.totalListHeightChanged(undefined)\n    }\n  }, [\n    state,\n    props.startReached,\n    props.endReached,\n    props.rangeChanged,\n    props.atBottomStateChange,\n    props.scrollingStateChange,\n    props.groupCounts,\n    props.groupIndices,\n    props.itemsRendered,\n    props.totalListHeightChanged,\n    props.item,\n    props.group,\n    props.GroupContainer,\n    props.ItemContainer,\n    props.scrollSeek,\n  ])\n\n  return (\n    <VirtuosoPresentation\n      contextValue={state}\n      style={props.style}\n      className={props.className}\n      header={props.header}\n      footer={props.footer}\n      itemHeight={props.itemHeight}\n      ScrollContainer={props.ScrollContainer}\n      HeaderContainer={props.HeaderContainer}\n      FooterContainer={props.FooterContainer}\n      ListContainer={props.ListContainer}\n    />\n  )\n})\n\nGroupedVirtuoso.displayName = 'GroupedVirtuoso'\n","import * as React from 'react'\nimport { subject, map, combineLatest, withLatestFrom, coldSubject } from './tinyrx'\nimport { makeInput, makeOutput } from './rxio'\nimport { TScrollLocation, TContainer, buildIsScrolling } from './EngineCommons'\nimport { ListRange, scrollSeekEngine } from './engines/scrollSeekEngine'\n\ntype GridDimensions = [\n  number, // container width,\n  number, // container height,\n  number | undefined, // item container width,\n  number | undefined, // item container height\n  number | undefined, // item content width\n  number | undefined // item content height\n]\n\ntype GridItemRange = [\n  number, // start index\n  number // end index\n]\n\ntype GridItemsRenderer = (\n  item: (index: number) => React.ReactElement,\n  itemClassName: string,\n  ItemContainer: TContainer,\n  computeItemKey: (index: number) => number\n) => React.ReactElement[]\n\nconst { ceil, floor, min, max } = Math\n\nconst hackFloor = (val: number) => (ceil(val) - val < 0.03 ? ceil(val) : floor(val))\n\nexport const VirtuosoGridEngine = (initialItemCount = 0) => {\n  const itemsRender = subject<any>(false)\n  const gridDimensions$ = subject<GridDimensions>([0, 0, undefined, undefined, undefined, undefined])\n  const totalCount$ = subject(0)\n  const scrollTop$ = subject(0)\n  const overscan$ = subject(0)\n  const itemRange$ = subject<GridItemRange>([0, max(initialItemCount - 1, 0)])\n  const remainingHeight$ = subject(0)\n  const listOffset$ = subject(0)\n  const scrollToIndex$ = coldSubject<TScrollLocation>()\n  const rangeChanged$ = coldSubject<ListRange>()\n\n  combineLatest(gridDimensions$, scrollTop$, overscan$, totalCount$)\n    .pipe(withLatestFrom(itemRange$))\n    .subscribe(\n      ([[[viewportWidth, viewportHeight, itemWidth, itemHeight], scrollTop, overscan, totalCount], itemRange]) => {\n        if (itemWidth === undefined || itemHeight === undefined) {\n          return\n        }\n\n        if (totalCount === 0) {\n          itemRange$.next([0, -1])\n          listOffset$.next(0)\n          rangeChanged$.next({ startIndex: 0, endIndex: -1 })\n          return\n        }\n\n        const [startIndex, endIndex] = itemRange\n        const itemsPerRow = hackFloor(viewportWidth / itemWidth)\n\n        const toRowIndex = (index: number, roundFunc = floor) => {\n          return roundFunc(index / itemsPerRow)\n        }\n\n        const updateRange = (down: boolean): void => {\n          const [topOverscan, bottomOverscan] = down ? [0, overscan] : [overscan, 0]\n\n          let startIndex = itemsPerRow * floor((scrollTop - topOverscan) / itemHeight)\n\n          let endIndex = itemsPerRow * ceil((scrollTop + viewportHeight + bottomOverscan) / itemHeight) - 1\n\n          endIndex = min(totalCount - 1, endIndex)\n          startIndex = min(endIndex, max(0, startIndex))\n\n          itemRange$.next([startIndex, endIndex])\n          listOffset$.next(toRowIndex(startIndex) * itemHeight)\n          rangeChanged$.next({ startIndex, endIndex })\n        }\n\n        const listTop = itemHeight * toRowIndex(startIndex)\n        const listBottom = itemHeight * toRowIndex(endIndex) + itemHeight\n\n        // totalCount has decreased, we have to re-render\n        if (totalCount < endIndex - 1) {\n          updateRange(true)\n          // user is scrolling up - list top is below the top edge of the viewport\n        } else if (listTop > scrollTop) {\n          updateRange(false)\n          // user is scrolling down - list bottom is above the bottom edge of the viewport\n        } else if (listBottom < scrollTop + viewportHeight) {\n          updateRange(true)\n        }\n\n        remainingHeight$.next(itemHeight * toRowIndex(totalCount - endIndex - 1, ceil))\n      }\n    )\n\n  const scrollTo$ = scrollToIndex$.pipe(\n    withLatestFrom(gridDimensions$, totalCount$),\n    map(([location, [viewportWidth, viewportHeight, itemWidth, itemHeight], totalCount]) => {\n      if (itemWidth === undefined || itemHeight === undefined) {\n        return { top: 0, behavior: 'auto' } as ScrollOptions\n      }\n\n      if (typeof location === 'number') {\n        location = { index: location, align: 'start' }\n      }\n\n      let { index, align = 'start', behavior = 'auto' } = location\n\n      index = Math.max(0, index, Math.min(totalCount - 1, index))\n\n      const itemsPerRow = hackFloor(viewportWidth / itemWidth)\n\n      let offset = floor(index / itemsPerRow) * itemHeight\n\n      if (align === 'end') {\n        offset = offset - viewportHeight + itemHeight\n      } else if (align === 'center') {\n        offset = Math.round(offset - viewportHeight / 2 + itemHeight / 2)\n      }\n\n      return { top: offset, behavior } as ScrollToOptions\n    })\n  )\n\n  const isScrolling$ = buildIsScrolling(scrollTop$)\n\n  const endReached$ = coldSubject<number>()\n  let currentEndIndex = 0\n\n  itemRange$.pipe(withLatestFrom(totalCount$)).subscribe(([[_, endIndex], totalCount]) => {\n    if (totalCount === 0) {\n      return\n    }\n\n    if (endIndex === totalCount - 1) {\n      if (currentEndIndex !== endIndex) {\n        currentEndIndex = endIndex\n        endReached$.next(endIndex)\n      }\n    }\n  })\n\n  const { isSeeking$, scrollSeekConfiguration$ } = scrollSeekEngine({\n    scrollTop$,\n    isScrolling$,\n    rangeChanged$,\n  })\n\n  combineLatest(itemRange$, isSeeking$, scrollSeekConfiguration$, gridDimensions$)\n    .pipe(\n      map(([[startIndex, endIndex], renderPlaceholder, scrollSeek, [_, __, ___, ____, _____, itemHeight]]) => {\n        const render: GridItemsRenderer = (item, itemClassName, ItemContainer, computeItemKey) => {\n          const items = []\n          for (let index = startIndex; index <= endIndex; index++) {\n            const key = computeItemKey(index)\n            let children: React.ReactElement\n\n            if (scrollSeek && renderPlaceholder && itemHeight) {\n              children = React.createElement(scrollSeek.placeholder, {\n                height: itemHeight,\n                index,\n              })\n            } else {\n              children = item(index)\n            }\n\n            items.push(\n              React.createElement(\n                ItemContainer,\n                {\n                  key,\n                  className: itemClassName,\n                },\n                children\n              )\n            )\n          }\n\n          return items\n        }\n        return { render }\n      })\n    )\n    .subscribe(itemsRender.next)\n\n  return {\n    gridDimensions: makeInput(gridDimensions$),\n    totalCount: makeInput(totalCount$),\n    scrollTop: makeInput(scrollTop$),\n    overscan: makeInput(overscan$),\n    scrollToIndex: makeInput(scrollToIndex$),\n    scrollSeekConfiguration: makeInput(scrollSeekConfiguration$),\n\n    itemsRender: makeOutput(itemsRender),\n\n    itemRange: makeOutput(itemRange$),\n    remainingHeight: makeOutput(remainingHeight$),\n    listOffset: makeOutput(listOffset$),\n    scrollTo: makeOutput(scrollTo$),\n    isScrolling: makeOutput(isScrolling$),\n    endReached: makeOutput(endReached$),\n    rangeChanged: makeOutput(rangeChanged$),\n  }\n}\n","import * as React from 'react'\nimport { CSSProperties, ReactElement } from 'react'\nimport { TSubscriber } from './tinyrx'\nimport { VirtuosoGridEngine } from './VirtuosoGridEngine'\nimport { VirtuosoScroller, TScrollContainer } from './VirtuosoScroller'\nimport { useOutput, useSize } from './Utils'\nimport { viewportStyle } from './Style'\nimport { TScrollLocation, TContainer } from './EngineCommons'\nimport { ListRange, ScrollSeekConfiguration } from './engines/scrollSeekEngine'\n\nexport interface VirtuosoGridProps {\n  totalCount: number\n  overscan?: number\n  item: (index: number) => ReactElement\n  style?: CSSProperties\n  className?: string\n  ScrollContainer?: TScrollContainer\n  ListContainer?: TContainer\n  ItemContainer?: TContainer\n  listClassName?: string\n  itemClassName?: string\n  scrollingStateChange?: (isScrolling: boolean) => void\n  endReached?: (index: number) => void\n  initialItemCount?: number\n  rangeChanged?: TSubscriber<ListRange>\n  computeItemKey?: (index: number) => number\n  scrollSeek?: ScrollSeekConfiguration\n}\n\ntype VirtuosoGridState = ReturnType<typeof VirtuosoGridEngine>\n\ntype VirtuosoGridFCProps = Omit<VirtuosoGridProps, 'overscan' | 'totalCount'> & { engine: VirtuosoGridState }\n\nexport class VirtuosoGrid extends React.PureComponent<VirtuosoGridProps, VirtuosoGridState> {\n  public state = VirtuosoGridEngine(this.props.initialItemCount)\n\n  public static getDerivedStateFromProps(props: VirtuosoGridProps, engine: VirtuosoGridState) {\n    engine.overscan(props.overscan || 0)\n    engine.totalCount(props.totalCount)\n    engine.isScrolling(props.scrollingStateChange)\n    engine.endReached(props.endReached)\n    engine.rangeChanged(props.rangeChanged)\n    engine.scrollSeekConfiguration(props.scrollSeek)\n    return null\n  }\n\n  public scrollToIndex(location: TScrollLocation) {\n    this.state.scrollToIndex(location)\n  }\n\n  public render() {\n    return <VirtuosoGridFC {...this.props} engine={this.state} />\n  }\n}\n\nconst VirtuosoGridFC: React.FC<VirtuosoGridFCProps> = ({\n  ScrollContainer,\n  ItemContainer = 'div',\n  ListContainer = 'div',\n  className,\n  item,\n  itemClassName = 'virtuoso-grid-item',\n  listClassName = 'virtuoso-grid-list',\n  engine,\n  style = { height: '100%' },\n  computeItemKey = key => key,\n}) => {\n  const { listOffset, remainingHeight, gridDimensions, scrollTo, scrollTop, itemsRender } = engine\n\n  const fillerHeight = useOutput<number>(remainingHeight, 0)\n  const translate = useOutput<number>(listOffset, 0)\n  const listStyle = { paddingTop: `${translate}px`, paddingBottom: `${fillerHeight}px` }\n\n  const render = useOutput(itemsRender, false)\n\n  const viewportCallbackRef = useSize(({ element, width, height }) => {\n    const firstItem = element.firstChild!.firstChild as HTMLElement\n    const firstItemContent = firstItem!.firstChild as HTMLElement\n    gridDimensions([\n      width,\n      height,\n      firstItem.offsetWidth,\n      firstItem.offsetHeight,\n      firstItemContent.offsetWidth,\n      firstItemContent.offsetHeight,\n    ])\n  })\n\n  return (\n    <VirtuosoScroller\n      style={style}\n      ScrollContainer={ScrollContainer}\n      className={className}\n      scrollTo={scrollTo}\n      scrollTop={scrollTop}\n    >\n      <div ref={viewportCallbackRef} style={viewportStyle}>\n        {React.createElement(\n          ListContainer,\n          {\n            style: listStyle,\n            className: listClassName,\n          },\n          render.render(item, itemClassName, ItemContainer, computeItemKey)\n        )}\n      </div>\n    </VirtuosoScroller>\n  )\n}\n"]},"metadata":{},"sourceType":"module"}