{"ast":null,"code":"'use strict';\n\nvar emptyArray = Object.freeze([]);\nvar emptyObject = Object.freeze(Object.create(null));\nvar namedEntities = Object.freeze({\n  '&amp;': '&',\n  '&apos;': \"'\",\n  '&gt;': '>',\n  '&lt;': '<',\n  '&quot;': '\"'\n});\nvar NODE_TYPE_CDATA = 'cdata';\nvar NODE_TYPE_COMMENT = 'comment';\nvar NODE_TYPE_DOCUMENT = 'document';\nvar NODE_TYPE_ELEMENT = 'element';\nvar NODE_TYPE_TEXT = 'text';\nvar Syntax;\n\nmodule.exports = function parseXml(xml, options) {\n  if (options === void 0) {\n    options = emptyObject;\n  }\n\n  if (Syntax === void 0) {\n    // Lazy require to defer regex parsing until first use.\n    Syntax = require('./lib/syntax');\n  }\n\n  if (xml[0] === \"\\uFEFF\") {\n    // Strip byte order mark.\n    xml = xml.slice(1);\n  }\n\n  xml = xml.replace(/\\r\\n?/g, '\\n'); // Normalize CRLF and CR to LF.\n\n  var doc = {\n    type: NODE_TYPE_DOCUMENT,\n    children: [],\n    parent: null,\n    toJSON: nodeToJson\n  };\n  var state = {\n    length: xml.length,\n    options: options,\n    parent: doc,\n    pos: 0,\n    prevPos: 0,\n    xml: xml\n  };\n  state.replaceReference = replaceReference.bind(state);\n  consumeProlog(state);\n\n  if (!consumeElement(state)) {\n    error(state, 'Root element is missing or invalid');\n  }\n\n  while (consumeMisc(state)) {} // eslint-disable-line no-empty\n\n\n  if (!isEof(state)) {\n    error(state, \"Extra content at the end of the document\");\n  }\n\n  return doc;\n}; // -- Private Functions --------------------------------------------------------\n\n\nfunction addNode(state, node) {\n  node.parent = state.parent;\n  node.toJSON = nodeToJson;\n  state.parent.children.push(node);\n}\n\nfunction addText(state, text) {\n  var children = state.parent.children;\n  var prevNode = children[children.length - 1];\n\n  if (prevNode !== void 0 && prevNode.type === NODE_TYPE_TEXT) {\n    // The previous node is a text node, so we can append to it and avoid\n    // creating another node.\n    prevNode.text += text;\n  } else {\n    addNode(state, {\n      type: NODE_TYPE_TEXT,\n      text: text\n    });\n  }\n} // Each `consume*` function takes the current state as an argument and returns\n// `true` if `state.pos` was advanced (meaning some XML was consumed) or `false`\n// if nothing was consumed.\n\n\nfunction consumeCDSect(state) {\n  var _scan = scan(state, Syntax.Anchored.CDSect),\n      match = _scan[0],\n      text = _scan[1];\n\n  if (match === void 0) {\n    return false;\n  }\n\n  if (state.options.preserveCdata) {\n    addNode(state, {\n      type: NODE_TYPE_CDATA,\n      text: text\n    });\n  } else {\n    addText(state, text);\n  }\n\n  return true;\n}\n\nfunction consumeCharData(state) {\n  var _scan2 = scan(state, Syntax.Anchored.CharData),\n      text = _scan2[0];\n\n  if (text === void 0) {\n    return false;\n  }\n\n  var cdataCloseIndex = text.indexOf(']]>');\n\n  if (cdataCloseIndex !== -1) {\n    state.pos = state.prevPos + cdataCloseIndex;\n    error(state, 'Element content may not contain the CDATA section close delimiter `]]>`');\n  } // Note: XML 1.0 5th ed. says `CharData` is \"any string of characters which\n  // does not contain the start-delimiter of any markup and does not include the\n  // CDATA-section-close delimiter\", but the conformance test suite and\n  // well-established parsers like libxml seem to restrict `CharData` to\n  // characters that match the `Char` symbol, so that's what I've done here.\n\n\n  if (!Syntax.CharOnly.test(text)) {\n    state.pos = state.prevPos + text.search(new RegExp(\"(?!\" + Syntax.Char.source + \")\"));\n    error(state, 'Element content contains an invalid character');\n  }\n\n  addText(state, text);\n  return true;\n}\n\nfunction consumeComment(state) {\n  var _scan3 = scan(state, Syntax.Anchored.Comment),\n      content = _scan3[1];\n\n  if (content === void 0) {\n    return false;\n  }\n\n  if (state.options.preserveComments) {\n    addNode(state, {\n      type: NODE_TYPE_COMMENT,\n      content: content.trim()\n    });\n  }\n\n  return true;\n}\n\nfunction consumeDoctypeDecl(state) {\n  return scan(state, Syntax.Anchored.doctypedecl).length > 0;\n}\n\nfunction consumeElement(state) {\n  var _scan4 = scan(state, Syntax.Anchored.EmptyElemTag),\n      tag = _scan4[0],\n      name = _scan4[1],\n      attrs = _scan4[2];\n\n  var isEmpty = tag !== void 0;\n\n  if (!isEmpty) {\n    var _scan5 = scan(state, Syntax.Anchored.STag);\n\n    tag = _scan5[0];\n    name = _scan5[1];\n    attrs = _scan5[2];\n\n    if (tag === void 0) {\n      return false;\n    }\n  }\n\n  var parent = state.parent;\n  var parsedAttrs = parseAttrs(state, attrs);\n  var node = {\n    type: NODE_TYPE_ELEMENT,\n    name: name,\n    attributes: parsedAttrs,\n    children: []\n  };\n  var xmlSpace = parsedAttrs['xml:space'];\n\n  if (xmlSpace === 'preserve' || xmlSpace !== 'default' && parent.preserveWhitespace) {\n    node.preserveWhitespace = true;\n  }\n\n  if (!isEmpty) {\n    state.parent = node;\n    consumeCharData(state);\n\n    while (consumeElement(state) || consumeReference(state) || consumeCDSect(state) || consumePI(state) || consumeComment(state)) {\n      consumeCharData(state);\n    }\n\n    var _scan6 = scan(state, Syntax.Anchored.ETag),\n        endName = _scan6[1];\n\n    if (endName !== name) {\n      state.pos = state.prevPos;\n      error(state, \"Missing end tag for element \" + name);\n    }\n\n    state.parent = parent;\n  }\n\n  addNode(state, node);\n  return true;\n}\n\nfunction consumeMisc(state) {\n  return consumeComment(state) || consumePI(state) || consumeWhitespace(state);\n}\n\nfunction consumePI(state) {\n  var _scan7 = scan(state, Syntax.Anchored.PI),\n      match = _scan7[0],\n      target = _scan7[1];\n\n  if (match === void 0) {\n    return false;\n  }\n\n  if (target.toLowerCase() === 'xml') {\n    state.pos = state.prevPos;\n    error(state, 'XML declaration is only allowed at the start of the document');\n  }\n\n  return true;\n}\n\nfunction consumeProlog(state) {\n  var pos = state.pos;\n  scan(state, Syntax.Anchored.XMLDecl);\n\n  while (consumeMisc(state)) {} // eslint-disable-line no-empty\n\n\n  if (consumeDoctypeDecl(state)) {\n    while (consumeMisc(state)) {} // eslint-disable-line no-empty\n\n  }\n\n  return state.pos > pos;\n}\n\nfunction consumeReference(state) {\n  var _scan8 = scan(state, Syntax.Anchored.Reference),\n      ref = _scan8[0];\n\n  if (ref === void 0) {\n    return false;\n  }\n\n  addText(state, state.replaceReference(ref));\n  return true;\n}\n\nfunction consumeWhitespace(state) {\n  return scan(state, Syntax.Anchored.S).length > 0;\n}\n\nfunction error(state, message) {\n  var pos = state.pos,\n      xml = state.xml;\n  var column = 1;\n  var excerpt = '';\n  var line = 1; // Find the line and column where the error occurred.\n\n  for (var i = 0; i < pos; ++i) {\n    var _char = xml[i];\n\n    if (_char === '\\n') {\n      column = 1;\n      excerpt = '';\n      line += 1;\n    } else {\n      column += 1;\n      excerpt += _char;\n    }\n  }\n\n  var eol = xml.indexOf('\\n', pos);\n  excerpt += eol === -1 ? xml.slice(pos) : xml.slice(pos, eol);\n  var excerptStart = 0; // Keep the excerpt below 50 chars, but always keep the error position in\n  // view.\n\n  if (excerpt.length > 50) {\n    if (column < 40) {\n      excerpt = excerpt.slice(0, 50);\n    } else {\n      excerptStart = column - 20;\n      excerpt = excerpt.slice(excerptStart, column + 30);\n    }\n  }\n\n  var err = new Error(message + \" (line \" + line + \", column \" + column + \")\\n\" + (\"  \" + excerpt + \"\\n\") + ' '.repeat(column - excerptStart + 1) + '^\\n');\n  err.column = column;\n  err.excerpt = excerpt;\n  err.line = line;\n  err.pos = pos;\n  throw err;\n}\n\nfunction isEof(state) {\n  return state.pos >= state.length - 1;\n}\n\nfunction nodeToJson() {\n  var json = Object.assign(Object.create(null), this); // eslint-disable-line no-invalid-this\n\n  delete json.parent;\n  return json;\n}\n\nfunction normalizeAttrValue(state, value) {\n  return value.replace(/[\\x20\\t\\r\\n]/g, ' ').replace(Syntax.Global.Reference, state.replaceReference);\n}\n\nfunction parseAttrs(state, attrs) {\n  var parsedAttrs = Object.create(null);\n\n  if (!attrs) {\n    return parsedAttrs;\n  }\n\n  var attrPairs = attrs.match(Syntax.Global.Attribute).sort();\n\n  for (var i = 0, len = attrPairs.length; i < len; ++i) {\n    var attrPair = attrPairs[i];\n    var eqMatch = attrPair.match(Syntax.Eq);\n    var name = attrPair.slice(0, eqMatch.index);\n    var value = attrPair.slice(eqMatch.index + eqMatch[0].length);\n\n    if (name in parsedAttrs) {\n      state.pos = state.prevPos;\n      error(state, \"Attribute `\" + name + \"` redefined\");\n    }\n\n    value = normalizeAttrValue(state, value.slice(1, -1));\n\n    if (name === 'xml:space') {\n      if (value !== 'default' && value !== 'preserve') {\n        state.pos = state.prevPos;\n        error(state, \"Value of the `xml:space` attribute must be \\\"default\\\" or \\\"preserve\\\"\");\n      }\n    }\n\n    parsedAttrs[name] = value;\n  }\n\n  return parsedAttrs;\n}\n\nfunction replaceReference(ref) {\n  var state = this; // eslint-disable-line no-invalid-this\n\n  if (ref[ref.length - 1] !== ';') {\n    error(state, \"Invalid reference: `\" + ref + \"`\");\n  }\n\n  if (ref[1] === '#') {\n    // This is a character entity.\n    var codePoint;\n\n    if (ref[2] === 'x') {\n      codePoint = parseInt(ref.slice(3, -1), 16);\n    } else {\n      codePoint = parseInt(ref.slice(2, -1), 10);\n    }\n\n    if (isNaN(codePoint)) {\n      state.pos = state.prevPos;\n      error(state, \"Invalid character entity `\" + ref + \"`\");\n    }\n\n    var _char2 = String.fromCodePoint(codePoint);\n\n    if (!Syntax.Char.test(_char2)) {\n      state.pos = state.prevPos;\n      error(state, \"Invalid character entity `\" + ref + \"`\");\n    }\n\n    return _char2;\n  } // This is a named entity.\n\n\n  var value = namedEntities[ref];\n\n  if (value !== void 0) {\n    return value;\n  }\n\n  if (state.options.resolveUndefinedEntity) {\n    var resolvedValue = state.options.resolveUndefinedEntity(ref);\n\n    if (resolvedValue !== null && resolvedValue !== void 0) {\n      return resolvedValue;\n    }\n  }\n\n  if (state.options.ignoreUndefinedEntities) {\n    return ref;\n  }\n\n  state.pos = state.prevPos;\n  error(state, \"Named entity isn't defined: `\" + ref + \"`\");\n}\n\nfunction scan(state, regex) {\n  var pos = state.pos,\n      xml = state.xml;\n  var xmlToScan = pos > 0 ? xml.slice(pos) : xml;\n  var matches = xmlToScan.match(regex);\n\n  if (matches === null) {\n    return emptyArray;\n  }\n\n  state.prevPos = state.pos;\n  state.pos += matches[0].length;\n  return matches;\n}","map":{"version":3,"sources":["/Users/akshatdhankher/Desktop/HCI/hci-ClassMates/src/ChatPageUI/node_modules/@rgrove/parse-xml/dist/commonjs/index.js"],"names":["emptyArray","Object","freeze","emptyObject","create","namedEntities","NODE_TYPE_CDATA","NODE_TYPE_COMMENT","NODE_TYPE_DOCUMENT","NODE_TYPE_ELEMENT","NODE_TYPE_TEXT","Syntax","module","exports","parseXml","xml","options","require","slice","replace","doc","type","children","parent","toJSON","nodeToJson","state","length","pos","prevPos","replaceReference","bind","consumeProlog","consumeElement","error","consumeMisc","isEof","addNode","node","push","addText","text","prevNode","consumeCDSect","_scan","scan","Anchored","CDSect","match","preserveCdata","consumeCharData","_scan2","CharData","cdataCloseIndex","indexOf","CharOnly","test","search","RegExp","Char","source","consumeComment","_scan3","Comment","content","preserveComments","trim","consumeDoctypeDecl","doctypedecl","_scan4","EmptyElemTag","tag","name","attrs","isEmpty","_scan5","STag","parsedAttrs","parseAttrs","attributes","xmlSpace","preserveWhitespace","consumeReference","consumePI","_scan6","ETag","endName","consumeWhitespace","_scan7","PI","target","toLowerCase","XMLDecl","_scan8","Reference","ref","S","message","column","excerpt","line","i","_char","eol","excerptStart","err","Error","repeat","json","assign","normalizeAttrValue","value","Global","attrPairs","Attribute","sort","len","attrPair","eqMatch","Eq","index","codePoint","parseInt","isNaN","_char2","String","fromCodePoint","resolveUndefinedEntity","resolvedValue","ignoreUndefinedEntities","regex","xmlToScan","matches"],"mappings":"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","sourcesContent":["'use strict';\n\nvar emptyArray = Object.freeze([]);\nvar emptyObject = Object.freeze(Object.create(null));\nvar namedEntities = Object.freeze({\n  '&amp;': '&',\n  '&apos;': \"'\",\n  '&gt;': '>',\n  '&lt;': '<',\n  '&quot;': '\"'\n});\nvar NODE_TYPE_CDATA = 'cdata';\nvar NODE_TYPE_COMMENT = 'comment';\nvar NODE_TYPE_DOCUMENT = 'document';\nvar NODE_TYPE_ELEMENT = 'element';\nvar NODE_TYPE_TEXT = 'text';\nvar Syntax;\n\nmodule.exports = function parseXml(xml, options) {\n  if (options === void 0) {\n    options = emptyObject;\n  }\n\n  if (Syntax === void 0) {\n    // Lazy require to defer regex parsing until first use.\n    Syntax = require('./lib/syntax');\n  }\n\n  if (xml[0] === \"\\uFEFF\") {\n    // Strip byte order mark.\n    xml = xml.slice(1);\n  }\n\n  xml = xml.replace(/\\r\\n?/g, '\\n'); // Normalize CRLF and CR to LF.\n\n  var doc = {\n    type: NODE_TYPE_DOCUMENT,\n    children: [],\n    parent: null,\n    toJSON: nodeToJson\n  };\n  var state = {\n    length: xml.length,\n    options: options,\n    parent: doc,\n    pos: 0,\n    prevPos: 0,\n    xml: xml\n  };\n  state.replaceReference = replaceReference.bind(state);\n  consumeProlog(state);\n\n  if (!consumeElement(state)) {\n    error(state, 'Root element is missing or invalid');\n  }\n\n  while (consumeMisc(state)) {} // eslint-disable-line no-empty\n\n\n  if (!isEof(state)) {\n    error(state, \"Extra content at the end of the document\");\n  }\n\n  return doc;\n}; // -- Private Functions --------------------------------------------------------\n\n\nfunction addNode(state, node) {\n  node.parent = state.parent;\n  node.toJSON = nodeToJson;\n  state.parent.children.push(node);\n}\n\nfunction addText(state, text) {\n  var children = state.parent.children;\n  var prevNode = children[children.length - 1];\n\n  if (prevNode !== void 0 && prevNode.type === NODE_TYPE_TEXT) {\n    // The previous node is a text node, so we can append to it and avoid\n    // creating another node.\n    prevNode.text += text;\n  } else {\n    addNode(state, {\n      type: NODE_TYPE_TEXT,\n      text: text\n    });\n  }\n} // Each `consume*` function takes the current state as an argument and returns\n// `true` if `state.pos` was advanced (meaning some XML was consumed) or `false`\n// if nothing was consumed.\n\n\nfunction consumeCDSect(state) {\n  var _scan = scan(state, Syntax.Anchored.CDSect),\n      match = _scan[0],\n      text = _scan[1];\n\n  if (match === void 0) {\n    return false;\n  }\n\n  if (state.options.preserveCdata) {\n    addNode(state, {\n      type: NODE_TYPE_CDATA,\n      text: text\n    });\n  } else {\n    addText(state, text);\n  }\n\n  return true;\n}\n\nfunction consumeCharData(state) {\n  var _scan2 = scan(state, Syntax.Anchored.CharData),\n      text = _scan2[0];\n\n  if (text === void 0) {\n    return false;\n  }\n\n  var cdataCloseIndex = text.indexOf(']]>');\n\n  if (cdataCloseIndex !== -1) {\n    state.pos = state.prevPos + cdataCloseIndex;\n    error(state, 'Element content may not contain the CDATA section close delimiter `]]>`');\n  } // Note: XML 1.0 5th ed. says `CharData` is \"any string of characters which\n  // does not contain the start-delimiter of any markup and does not include the\n  // CDATA-section-close delimiter\", but the conformance test suite and\n  // well-established parsers like libxml seem to restrict `CharData` to\n  // characters that match the `Char` symbol, so that's what I've done here.\n\n\n  if (!Syntax.CharOnly.test(text)) {\n    state.pos = state.prevPos + text.search(new RegExp(\"(?!\" + Syntax.Char.source + \")\"));\n    error(state, 'Element content contains an invalid character');\n  }\n\n  addText(state, text);\n  return true;\n}\n\nfunction consumeComment(state) {\n  var _scan3 = scan(state, Syntax.Anchored.Comment),\n      content = _scan3[1];\n\n  if (content === void 0) {\n    return false;\n  }\n\n  if (state.options.preserveComments) {\n    addNode(state, {\n      type: NODE_TYPE_COMMENT,\n      content: content.trim()\n    });\n  }\n\n  return true;\n}\n\nfunction consumeDoctypeDecl(state) {\n  return scan(state, Syntax.Anchored.doctypedecl).length > 0;\n}\n\nfunction consumeElement(state) {\n  var _scan4 = scan(state, Syntax.Anchored.EmptyElemTag),\n      tag = _scan4[0],\n      name = _scan4[1],\n      attrs = _scan4[2];\n\n  var isEmpty = tag !== void 0;\n\n  if (!isEmpty) {\n    var _scan5 = scan(state, Syntax.Anchored.STag);\n\n    tag = _scan5[0];\n    name = _scan5[1];\n    attrs = _scan5[2];\n\n    if (tag === void 0) {\n      return false;\n    }\n  }\n\n  var parent = state.parent;\n  var parsedAttrs = parseAttrs(state, attrs);\n  var node = {\n    type: NODE_TYPE_ELEMENT,\n    name: name,\n    attributes: parsedAttrs,\n    children: []\n  };\n  var xmlSpace = parsedAttrs['xml:space'];\n\n  if (xmlSpace === 'preserve' || xmlSpace !== 'default' && parent.preserveWhitespace) {\n    node.preserveWhitespace = true;\n  }\n\n  if (!isEmpty) {\n    state.parent = node;\n    consumeCharData(state);\n\n    while (consumeElement(state) || consumeReference(state) || consumeCDSect(state) || consumePI(state) || consumeComment(state)) {\n      consumeCharData(state);\n    }\n\n    var _scan6 = scan(state, Syntax.Anchored.ETag),\n        endName = _scan6[1];\n\n    if (endName !== name) {\n      state.pos = state.prevPos;\n      error(state, \"Missing end tag for element \" + name);\n    }\n\n    state.parent = parent;\n  }\n\n  addNode(state, node);\n  return true;\n}\n\nfunction consumeMisc(state) {\n  return consumeComment(state) || consumePI(state) || consumeWhitespace(state);\n}\n\nfunction consumePI(state) {\n  var _scan7 = scan(state, Syntax.Anchored.PI),\n      match = _scan7[0],\n      target = _scan7[1];\n\n  if (match === void 0) {\n    return false;\n  }\n\n  if (target.toLowerCase() === 'xml') {\n    state.pos = state.prevPos;\n    error(state, 'XML declaration is only allowed at the start of the document');\n  }\n\n  return true;\n}\n\nfunction consumeProlog(state) {\n  var pos = state.pos;\n  scan(state, Syntax.Anchored.XMLDecl);\n\n  while (consumeMisc(state)) {} // eslint-disable-line no-empty\n\n\n  if (consumeDoctypeDecl(state)) {\n    while (consumeMisc(state)) {} // eslint-disable-line no-empty\n\n  }\n\n  return state.pos > pos;\n}\n\nfunction consumeReference(state) {\n  var _scan8 = scan(state, Syntax.Anchored.Reference),\n      ref = _scan8[0];\n\n  if (ref === void 0) {\n    return false;\n  }\n\n  addText(state, state.replaceReference(ref));\n  return true;\n}\n\nfunction consumeWhitespace(state) {\n  return scan(state, Syntax.Anchored.S).length > 0;\n}\n\nfunction error(state, message) {\n  var pos = state.pos,\n      xml = state.xml;\n  var column = 1;\n  var excerpt = '';\n  var line = 1; // Find the line and column where the error occurred.\n\n  for (var i = 0; i < pos; ++i) {\n    var _char = xml[i];\n\n    if (_char === '\\n') {\n      column = 1;\n      excerpt = '';\n      line += 1;\n    } else {\n      column += 1;\n      excerpt += _char;\n    }\n  }\n\n  var eol = xml.indexOf('\\n', pos);\n  excerpt += eol === -1 ? xml.slice(pos) : xml.slice(pos, eol);\n  var excerptStart = 0; // Keep the excerpt below 50 chars, but always keep the error position in\n  // view.\n\n  if (excerpt.length > 50) {\n    if (column < 40) {\n      excerpt = excerpt.slice(0, 50);\n    } else {\n      excerptStart = column - 20;\n      excerpt = excerpt.slice(excerptStart, column + 30);\n    }\n  }\n\n  var err = new Error(message + \" (line \" + line + \", column \" + column + \")\\n\" + (\"  \" + excerpt + \"\\n\") + ' '.repeat(column - excerptStart + 1) + '^\\n');\n  err.column = column;\n  err.excerpt = excerpt;\n  err.line = line;\n  err.pos = pos;\n  throw err;\n}\n\nfunction isEof(state) {\n  return state.pos >= state.length - 1;\n}\n\nfunction nodeToJson() {\n  var json = Object.assign(Object.create(null), this); // eslint-disable-line no-invalid-this\n\n  delete json.parent;\n  return json;\n}\n\nfunction normalizeAttrValue(state, value) {\n  return value.replace(/[\\x20\\t\\r\\n]/g, ' ').replace(Syntax.Global.Reference, state.replaceReference);\n}\n\nfunction parseAttrs(state, attrs) {\n  var parsedAttrs = Object.create(null);\n\n  if (!attrs) {\n    return parsedAttrs;\n  }\n\n  var attrPairs = attrs.match(Syntax.Global.Attribute).sort();\n\n  for (var i = 0, len = attrPairs.length; i < len; ++i) {\n    var attrPair = attrPairs[i];\n    var eqMatch = attrPair.match(Syntax.Eq);\n    var name = attrPair.slice(0, eqMatch.index);\n    var value = attrPair.slice(eqMatch.index + eqMatch[0].length);\n\n    if (name in parsedAttrs) {\n      state.pos = state.prevPos;\n      error(state, \"Attribute `\" + name + \"` redefined\");\n    }\n\n    value = normalizeAttrValue(state, value.slice(1, -1));\n\n    if (name === 'xml:space') {\n      if (value !== 'default' && value !== 'preserve') {\n        state.pos = state.prevPos;\n        error(state, \"Value of the `xml:space` attribute must be \\\"default\\\" or \\\"preserve\\\"\");\n      }\n    }\n\n    parsedAttrs[name] = value;\n  }\n\n  return parsedAttrs;\n}\n\nfunction replaceReference(ref) {\n  var state = this; // eslint-disable-line no-invalid-this\n\n  if (ref[ref.length - 1] !== ';') {\n    error(state, \"Invalid reference: `\" + ref + \"`\");\n  }\n\n  if (ref[1] === '#') {\n    // This is a character entity.\n    var codePoint;\n\n    if (ref[2] === 'x') {\n      codePoint = parseInt(ref.slice(3, -1), 16);\n    } else {\n      codePoint = parseInt(ref.slice(2, -1), 10);\n    }\n\n    if (isNaN(codePoint)) {\n      state.pos = state.prevPos;\n      error(state, \"Invalid character entity `\" + ref + \"`\");\n    }\n\n    var _char2 = String.fromCodePoint(codePoint);\n\n    if (!Syntax.Char.test(_char2)) {\n      state.pos = state.prevPos;\n      error(state, \"Invalid character entity `\" + ref + \"`\");\n    }\n\n    return _char2;\n  } // This is a named entity.\n\n\n  var value = namedEntities[ref];\n\n  if (value !== void 0) {\n    return value;\n  }\n\n  if (state.options.resolveUndefinedEntity) {\n    var resolvedValue = state.options.resolveUndefinedEntity(ref);\n\n    if (resolvedValue !== null && resolvedValue !== void 0) {\n      return resolvedValue;\n    }\n  }\n\n  if (state.options.ignoreUndefinedEntities) {\n    return ref;\n  }\n\n  state.pos = state.prevPos;\n  error(state, \"Named entity isn't defined: `\" + ref + \"`\");\n}\n\nfunction scan(state, regex) {\n  var pos = state.pos,\n      xml = state.xml;\n  var xmlToScan = pos > 0 ? xml.slice(pos) : xml;\n  var matches = xmlToScan.match(regex);\n\n  if (matches === null) {\n    return emptyArray;\n  }\n\n  state.prevPos = state.pos;\n  state.pos += matches[0].length;\n  return matches;\n}"]},"metadata":{},"sourceType":"module"}