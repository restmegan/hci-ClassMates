'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _extends = require('@babel/runtime/helpers/extends');
var React = require('react');
var streamChat = require('stream-chat');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var Dayjs = require('dayjs');
var LocalizedFormat = require('dayjs/plugin/localizedFormat');
var emojiRegex = require('emoji-regex');
var RootReactMarkdown = require('react-markdown');
var ReactMarkdown = require('react-markdown/with-html');
var linkify = require('linkifyjs');
var _regeneratorRuntime = require('@babel/runtime/regenerator');
var _asyncToGenerator = require('@babel/runtime/helpers/asyncToGenerator');
var _classCallCheck = require('@babel/runtime/helpers/classCallCheck');
var _createClass = require('@babel/runtime/helpers/createClass');
var i18n = require('i18next');
var calendar = require('dayjs/plugin/calendar');
var updateLocale = require('dayjs/plugin/updateLocale');
var localeData = require('dayjs/plugin/localeData');
var relativeTime = require('dayjs/plugin/relativeTime');
require('dayjs/locale/nl');
require('dayjs/locale/ru');
require('dayjs/locale/tr');
require('dayjs/locale/fr');
require('dayjs/locale/hi');
require('dayjs/locale/it');
require('dayjs/locale/en');
var PropTypes = require('prop-types');
var _slicedToArray = require('@babel/runtime/helpers/slicedToArray');
var _toConsumableArray = require('@babel/runtime/helpers/toConsumableArray');
var _objectWithoutProperties = require('@babel/runtime/helpers/objectWithoutProperties');
var DefaultMedia = require('react-player');
var sanitizeUrl = require('@braintree/sanitize-url');
var reactFileUtils = require('react-file-utils');
var prettybytes = require('pretty-bytes');
var Carousel = require('react-images');
var _assertThisInitialized = require('@babel/runtime/helpers/assertThisInitialized');
var _inherits = require('@babel/runtime/helpers/inherits');
var _possibleConstructorReturn = require('@babel/runtime/helpers/possibleConstructorReturn');
var _getPrototypeOf = require('@babel/runtime/helpers/getPrototypeOf');
var Textarea = require('react-textarea-autosize');
var getCaretCoordinates = require('textarea-caret');
var CustomEvent = require('custom-event');
var reactIs = require('react-is');
var debounce = require('lodash.debounce');
var throttle = require('lodash.throttle');
var uuid = require('uuid');
var mmlReact = require('mml-react');
var Immutable = require('seamless-immutable');
var deepequal = require('react-fast-compare');
var uniqBy = require('lodash.uniqby');
var reactVirtuoso = require('react-virtuoso');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _extends__default = /*#__PURE__*/_interopDefaultLegacy(_extends);
var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);
var Dayjs__default = /*#__PURE__*/_interopDefaultLegacy(Dayjs);
var LocalizedFormat__default = /*#__PURE__*/_interopDefaultLegacy(LocalizedFormat);
var emojiRegex__default = /*#__PURE__*/_interopDefaultLegacy(emojiRegex);
var RootReactMarkdown__default = /*#__PURE__*/_interopDefaultLegacy(RootReactMarkdown);
var ReactMarkdown__default = /*#__PURE__*/_interopDefaultLegacy(ReactMarkdown);
var _regeneratorRuntime__default = /*#__PURE__*/_interopDefaultLegacy(_regeneratorRuntime);
var _asyncToGenerator__default = /*#__PURE__*/_interopDefaultLegacy(_asyncToGenerator);
var _classCallCheck__default = /*#__PURE__*/_interopDefaultLegacy(_classCallCheck);
var _createClass__default = /*#__PURE__*/_interopDefaultLegacy(_createClass);
var i18n__default = /*#__PURE__*/_interopDefaultLegacy(i18n);
var calendar__default = /*#__PURE__*/_interopDefaultLegacy(calendar);
var updateLocale__default = /*#__PURE__*/_interopDefaultLegacy(updateLocale);
var localeData__default = /*#__PURE__*/_interopDefaultLegacy(localeData);
var relativeTime__default = /*#__PURE__*/_interopDefaultLegacy(relativeTime);
var PropTypes__default = /*#__PURE__*/_interopDefaultLegacy(PropTypes);
var _slicedToArray__default = /*#__PURE__*/_interopDefaultLegacy(_slicedToArray);
var _toConsumableArray__default = /*#__PURE__*/_interopDefaultLegacy(_toConsumableArray);
var _objectWithoutProperties__default = /*#__PURE__*/_interopDefaultLegacy(_objectWithoutProperties);
var DefaultMedia__default = /*#__PURE__*/_interopDefaultLegacy(DefaultMedia);
var prettybytes__default = /*#__PURE__*/_interopDefaultLegacy(prettybytes);
var Carousel__default = /*#__PURE__*/_interopDefaultLegacy(Carousel);
var _assertThisInitialized__default = /*#__PURE__*/_interopDefaultLegacy(_assertThisInitialized);
var _inherits__default = /*#__PURE__*/_interopDefaultLegacy(_inherits);
var _possibleConstructorReturn__default = /*#__PURE__*/_interopDefaultLegacy(_possibleConstructorReturn);
var _getPrototypeOf__default = /*#__PURE__*/_interopDefaultLegacy(_getPrototypeOf);
var Textarea__default = /*#__PURE__*/_interopDefaultLegacy(Textarea);
var getCaretCoordinates__default = /*#__PURE__*/_interopDefaultLegacy(getCaretCoordinates);
var CustomEvent__default = /*#__PURE__*/_interopDefaultLegacy(CustomEvent);
var debounce__default = /*#__PURE__*/_interopDefaultLegacy(debounce);
var throttle__default = /*#__PURE__*/_interopDefaultLegacy(throttle);
var Immutable__default = /*#__PURE__*/_interopDefaultLegacy(Immutable);
var deepequal__default = /*#__PURE__*/_interopDefaultLegacy(deepequal);
var uniqBy__default = /*#__PURE__*/_interopDefaultLegacy(uniqBy);

/**
 * @typedef {import('../types').ChatContextValue} ChatContextProps
 */

var ChatContext = /*#__PURE__*/React__default['default'].createContext(
/** @type {ChatContextProps} */
{
  client: new streamChat.StreamChat(''),
  setActiveChannel: function setActiveChannel() {
    return null;
  }
});
/**
 * @function
 * @template P
 * @param {React.ComponentType<P>} OriginalComponent
 * @returns {React.ComponentType<Exclude<P, ChatContextProps>>}
 */

function withChatContext(OriginalComponent) {
  /** @param {Exclude<P, ChatContextProps>} props */
  var ContextAwareComponent = function ContextComponent(props) {
    return /*#__PURE__*/React__default['default'].createElement(ChatContext.Consumer, null, function (context) {
      return /*#__PURE__*/React__default['default'].createElement(OriginalComponent, _extends__default['default']({}, context, props));
    });
  };

  ContextAwareComponent.displayName = (OriginalComponent.displayName || OriginalComponent.name || 'Component').replace('Base', '');
  return ContextAwareComponent;
}

/**
 * @typedef {import('../types').ChannelContextValue} ChannelContextProps
 */

var ChannelContext = /*#__PURE__*/React__default['default'].createContext(
/** @type {ChannelContextProps} */
{});
/**
 * @function
 * @template P
 * @param { React.ComponentType<P> } OriginalComponent
 * @returns {React.ComponentType<Exclude<P, ChannelContextProps>>}
 */

function withChannelContext(OriginalComponent) {
  /** @param {Exclude<P, ChannelContextProps>} props */
  var ContextAwareComponent = function ContextComponent(props) {
    return /*#__PURE__*/React__default['default'].createElement(ChannelContext.Consumer, null, function (context) {
      return /*#__PURE__*/React__default['default'].createElement(OriginalComponent, _extends__default['default']({}, context, props));
    });
  };

  ContextAwareComponent.displayName = (OriginalComponent.displayName || OriginalComponent.name || 'Component').replace('Base', '');
  return ContextAwareComponent;
}

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var emojiSetDef = {
  spriteUrl: 'https://getstream.imgix.net/images/emoji-sprite.png',
  size: 20,
  sheetColumns: 2,
  sheetRows: 3,
  sheetSize: 64
};
/** @type {import("types").commonEmojiInterface} */

var commonEmoji = {
  emoticons: [],
  short_names: [],
  custom: true
};
/** @type {import("types").MinimalEmojiInterface[]} */

var defaultMinimalEmojis = [_objectSpread(_objectSpread({
  id: 'like',
  name: 'like',
  colons: ':+1:',
  sheet_x: 0,
  sheet_y: 0
}, commonEmoji), emojiSetDef), _objectSpread(_objectSpread({
  id: 'love',
  name: 'love',
  colons: ':heart:',
  sheet_x: 1,
  sheet_y: 2
}, commonEmoji), emojiSetDef), _objectSpread(_objectSpread({
  id: 'haha',
  name: 'haha',
  colons: ':joy:',
  sheet_x: 1,
  sheet_y: 0
}, commonEmoji), emojiSetDef), _objectSpread(_objectSpread({
  id: 'wow',
  name: 'wow',
  colons: ':astonished:',
  sheet_x: 0,
  sheet_y: 2
}, commonEmoji), emojiSetDef), _objectSpread(_objectSpread({
  id: 'sad',
  name: 'sad',
  colons: ':pensive:',
  sheet_x: 0,
  sheet_y: 1
}, commonEmoji), emojiSetDef), _objectSpread(_objectSpread({
  id: 'angry',
  name: 'angry',
  colons: ':angry:',
  sheet_x: 1,
  sheet_y: 1
}, commonEmoji), emojiSetDef)]; // use this only for small lists like in ReactionSelector

/** @typedef {import('emoji-mart').Data} EmojiData
 * @type {(data: EmojiData) => EmojiData}
 */

var getStrippedEmojiData = function getStrippedEmojiData(data) {
  return _objectSpread(_objectSpread({}, data), {}, {
    emojis: {}
  });
};

/**
 * @typedef {import('../types').EmojiContextValue} EmojiContextProps
 */

var EmojiContext = /*#__PURE__*/React__default['default'].createContext(
/** @type {EmojiContextProps} */
{
  emojiData: {},
  EmojiPicker: null,
  Emoji: null,
  defaultMinimalEmojis,
  commonEmoji
});
/**
 * @function
 * @template P
 * @param {React.ComponentType<P>} OriginalComponent
 * @returns {React.ComponentType<Exclude<P, EmojiContextProps>>}
 */

function withEmojiContext(OriginalComponent) {
  /** @param {Exclude<P, EmojiContextProps>} props */
  var ContextAwareComponent = function ContextComponent(props) {
    return /*#__PURE__*/React__default['default'].createElement(EmojiContext.Consumer, null, function (context) {
      return /*#__PURE__*/React__default['default'].createElement(OriginalComponent, _extends__default['default']({}, context, props));
    });
  };

  ContextAwareComponent.displayName = (OriginalComponent.displayName || OriginalComponent.name || 'Component').replace('Base', '');
  return ContextAwareComponent;
}

Dayjs__default['default'].extend(LocalizedFormat__default['default']);
/**
 * @typedef {Required<import('../types').TranslationContextValue>} TranslationContextProps
 */

var TranslationContext = /*#__PURE__*/React__default['default'].createContext(
/** @type {TranslationContextProps} */
{
  t:
  /** @param {string} key */
  function t(key) {
    return key;
  },
  tDateTimeParser: function tDateTimeParser(input) {
    return Dayjs__default['default'](input);
  }
});
/**
 * @function
 * @template P
 * @param {React.ComponentType<P>} OriginalComponent
 * @returns {React.ComponentType<Exclude<P, TranslationContextProps>>}
 */

function withTranslationContext(OriginalComponent) {
  /** @param {Exclude<P, TranslationContextProps>} props */
  var ContextAwareComponent = function ContextComponent(props) {
    return /*#__PURE__*/React__default['default'].createElement(TranslationContext.Consumer, null, function (context) {
      return /*#__PURE__*/React__default['default'].createElement(OriginalComponent, _extends__default['default']({}, context, props));
    });
  };

  ContextAwareComponent.displayName = (OriginalComponent.displayName || OriginalComponent.name || 'Component').replace('Base', '');
  return ContextAwareComponent;
}

// @ts-check
/** @type {(text: string | undefined) => boolean} */

var isOnlyEmojis = function isOnlyEmojis(text) {
  if (!text) return false;
  var noEmojis = text.replace(emojiRegex__default['default'](), '');
  var noSpace = noEmojis.replace(/[\s\n]/gm, '');
  return !noSpace;
};
/** @type {(thing: any) => boolean} */

var isPromise = function isPromise(thing) {
  return typeof (thing === null || thing === void 0 ? void 0 : thing.then) === 'function';
};
/**
 * @typedef {{created_at: number}} Datelike
 * @type {(a: Datelike, b: Datelike) => number}
 **/

var byDate = function byDate(a, b) {
  return a.created_at - b.created_at;
};
/** @type {import('react-markdown').NodeType[]} */

var allowedMarkups = ['html', // @ts-ignore
'root', 'text', 'break', 'paragraph', 'emphasis', 'strong', 'link', 'list', 'listItem', 'code', 'inlineCode', 'blockquote', 'delete'];
/** @type {(message: string) => (string|null)[]} */

var matchMarkdownLinks = function matchMarkdownLinks(message) {
  var regexMdLinks = /\[([^\[]+)\](\(.*\))/gm;
  var matches = message.match(regexMdLinks);
  var singleMatch = /\[([^\[]+)\]\((.*)\)/;
  var links = matches ? matches.map(function (match) {
    var i = singleMatch.exec(match);
    return i && i[2];
  }) : [];
  return links;
};
/** @type {(input: string, length: number) => string} */


var truncate = function truncate(input, length) {
  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '...';

  if (input.length > length) {
    return "".concat(input.substring(0, length - end.length)).concat(end);
  }

  return input;
};
var markDownRenderers = {
  /** @param {{ href: string | undefined; children: React.ReactElement; }} props   */
  link: function link(props) {
    if (!props.href || !props.href.startsWith('http') && !props.href.startsWith('mailto:')) {
      return props.children;
    }

    return /*#__PURE__*/React__default['default'].createElement("a", {
      href: props.href,
      target: "_blank",
      rel: "nofollow noreferrer noopener"
    }, props.children);
  }
};
/** @type {(input: string | undefined, mentioned_users: import('stream-chat').UserResponse[] | undefined) => React.ReactNode} */

var renderText = function renderText(text, mentioned_users) {
  // take the @ mentions and turn them into markdown?
  // translate links
  if (!text) return null;
  var newText = text;
  var markdownLinks = matchMarkdownLinks(newText); // extract all valid links/emails within text and replace it with proper markup

  linkify.find(newText).forEach(function (_ref) {
    var type = _ref.type,
        href = _ref.href,
        value = _ref.value;
    // check if message is already  markdown
    var noParsingNeeded = markdownLinks && markdownLinks.filter(function (text) {
      return (text === null || text === void 0 ? void 0 : text.indexOf(href)) !== -1;
    });
    if (noParsingNeeded.length > 0) return;
    var displayLink = type === 'email' ? value : truncate(value.replace(/(http(s?):\/\/)?(www\.)?/, ''), 20);
    newText = newText.replace(value, "[".concat(displayLink, "](").concat(encodeURI(href), ")"));
  });

  if (mentioned_users && mentioned_users.length) {
    for (var i = 0; i < mentioned_users.length; i++) {
      var username = mentioned_users[i].name || mentioned_users[i].id;

      if (username) {
        username = escapeRegExp(username);
      }

      var mkdown = "**@".concat(username, "**");
      var re = new RegExp("@".concat(username), 'g');
      newText = newText.replace(re, mkdown);
    }
  }

  return /*#__PURE__*/React__default['default'].createElement(ReactMarkdown__default['default'], {
    allowedTypes: allowedMarkups,
    source: newText,
    renderers: markDownRenderers,
    escapeHtml: true,
    unwrapDisallowed: true,
    transformLinkUri: function transformLinkUri(uri) {
      return uri.startsWith('app://') ? uri : RootReactMarkdown__default['default'].uriTransformer(uri);
    }
  });
};
/** @param { string } text */

function escapeRegExp(text) {
  return text.replace(/[-[\]{}()*+?.,\\^$|#]/g, '\\$&');
} // https://stackoverflow.com/a/6860916/2570866


function generateRandomId() {
  // prettier-ignore
  return S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4();
}

function S4() {
  return ((1 + Math.random()) * 0x10000 | 0).toString(16).substring(1);
} // @ts-ignore


var smartRender = function smartRender(ElementOrComponentOrLiteral, props, fallback) {
  if (ElementOrComponentOrLiteral === undefined) {
    ElementOrComponentOrLiteral = fallback;
  }

  if ( /*#__PURE__*/React__default['default'].isValidElement(ElementOrComponentOrLiteral)) {
    // Flow cast through any, to make flow believe it's a React.Element
    var element = ElementOrComponentOrLiteral; // eslint-disable-line

    return element;
  } // Flow cast through any to remove React.Element after previous check

  /** @type {React.Component} */


  var ComponentOrLiteral = ElementOrComponentOrLiteral;

  if (typeof ComponentOrLiteral === 'string' || typeof ComponentOrLiteral === 'number' || typeof ComponentOrLiteral === 'boolean' || ComponentOrLiteral == null) {
    return ComponentOrLiteral;
  } // @ts-ignore


  return /*#__PURE__*/React__default['default'].createElement(ComponentOrLiteral, props);
};
/**
 * @type { import('prop-types').Validator<any> }
 **/

var checkChannelPropType = function checkChannelPropType(propValue, _, componentName) {
  var _propValue$constructo;

  if ((propValue === null || propValue === void 0 ? void 0 : (_propValue$constructo = propValue.constructor) === null || _propValue$constructo === void 0 ? void 0 : _propValue$constructo.name) !== streamChat.Channel.name) {
    return Error("Failed prop type: Invalid prop `channel` of type `".concat(propValue.constructor.name, "` supplied to `").concat(componentName, "`, expected instance of `").concat(streamChat.Channel.name, "`."));
  }

  return null;
};
/**
 * @type { import('prop-types').Validator<any> }
 **/

var checkClientPropType = function checkClientPropType(propValue, _, componentName) {
  var _propValue$constructo2;

  if ((propValue === null || propValue === void 0 ? void 0 : (_propValue$constructo2 = propValue.constructor) === null || _propValue$constructo2 === void 0 ? void 0 : _propValue$constructo2.name) !== streamChat.StreamChat.name) {
    return Error("Failed prop type: Invalid prop `client` of type `".concat(propValue.constructor.name, "` supplied to `").concat(componentName, "`, expected instance of `").concat(streamChat.StreamChat.name, "`."));
  }

  return null;
};

var Cancel="Cancel";var Close="Close";var Delete="Delete";var Delivered="Delivered";var Flag="Flag";var Mute="Mute";var New="New";var Pin="Pin";var Send="Send";var Thread="Thread";var Unmute="Unmute";var Unpin="Unpin";var live="live";var enTranslations = {"1 reply":"1 reply","Attach files":"Attach files",Cancel:Cancel,"Channel Missing":"Channel Missing",Close:Close,"Commands matching":"Commands matching","Connection failure, reconnecting now...":"Connection failure, reconnecting now...",Delete:Delete,Delivered:Delivered,"Edit Message":"Edit Message","Emoji matching":"Emoji matching","Empty message...":"Empty message...","Error adding flag: Either the flag already exist or there is issue with network connection ...":"Error adding flag: Either the flag already exist or there is issue with network connection ...","Error connecting to chat, refresh the page to try again.":"Error connecting to chat, refresh the page to try again.","Error muting a user ...":"Error muting a user ...","Error pinning message":"Error pinning message","Error removing message pin":"Error removing message pin","Error unmuting a user ...":"Error unmuting a user ...","Error ¬∑ Unsent":"Error ¬∑ Unsent","Error: {{ errorMessage }}":"Error: {{ errorMessage }}",Flag:Flag,"Message Failed ¬∑ Click to try again":"Message Failed ¬∑ Click to try again","Message deleted":"Message deleted","Message failed. Click to try again.":"Message failed. Click to try again.","Message has been successfully flagged":"Message has been successfully flagged","Message pinned":"Message pinned",Mute:Mute,New:New,"New Messages!":"New Messages!","Nothing yet...":"Nothing yet...","Only visible to you":"Only visible to you","Open emoji picker":"Open emoji picker","People matching":"People matching","Pick your emoji":"Pick your emoji",Pin:Pin,"Pinned by":"Pinned by",Send:Send,"Sending...":"Sending...","Start of a new thread":"Start of a new thread","This message was deleted...":"This message was deleted...",Thread:Thread,"Type your message":"Type your message",Unmute:Unmute,Unpin:Unpin,"You have no channels currently":"You have no channels currently","You've reached the maximum number of files":"You've reached the maximum number of files",live:live,"this content could not be displayed":"this content could not be displayed","{{ commaSeparatedUsers }} and {{ lastUser }} are typing...":"{{ commaSeparatedUsers }} and {{ lastUser }} are typing...","{{ commaSeparatedUsers }} and {{ moreCount }} more":"{{ commaSeparatedUsers }} and {{ moreCount }} more","{{ commaSeparatedUsers }}, and {{ lastUser }}":"{{ commaSeparatedUsers }}, and {{ lastUser }}","{{ firstUser }} and {{ secondUser }}":"{{ firstUser }} and {{ secondUser }}","{{ firstUser }} and {{ secondUser }} are typing...":"{{ firstUser }} and {{ secondUser }} are typing...","{{ imageCount }} more":"{{ imageCount }} more","{{ memberCount }} members":"{{ memberCount }} members","{{ replyCount }} replies":"{{ replyCount }} replies","{{ user }} has been muted":"{{ user }} has been muted","{{ user }} has been unmuted":"{{ user }} has been unmuted","{{ user }} is typing...":"{{ user }} is typing...","{{ watcherCount }} online":"{{ watcherCount }} online","üèô Attachment...":"üèô Attachment..."};

var Cancel$1="";var Close$1="";var Delete$1="";var Delivered$1="";var Flag$1="";var Mute$1="";var New$1="";var Pin$1="";var Send$1="";var Thread$1="";var Unmute$1="";var Unpin$1="";var live$1="live";var nlTranslations = {"1 reply":"","Attach files":"",Cancel:Cancel$1,"Channel Missing":"Kanaal niet gevonden",Close:Close$1,"Commands matching":"Bijpassende opdrachten","Connection failure, reconnecting now...":"",Delete:Delete$1,Delivered:Delivered$1,"Edit Message":"","Emoji matching":"Emoji-overeenkomsten","Empty message...":"Leeg bericht...","Error adding flag: Either the flag already exist or there is issue with network connection ...":"","Error connecting to chat, refresh the page to try again.":"","Error muting a user ...":"","Error pinning message":"","Error removing message pin":"","Error unmuting a user ...":"","Error ¬∑ Unsent":"","Error: {{ errorMessage }}":"",Flag:Flag$1,"Message Failed ¬∑ Click to try again":"","Message deleted":"Bericht verwijderd","Message failed. Click to try again.":"","Message has been successfully flagged":"","Message pinned":"",Mute:Mute$1,New:New$1,"New Messages!":"","Nothing yet...":"Nog niets ...","Only visible to you":"","Open emoji picker":"","People matching":"Mensen die matchen","Pick your emoji":"",Pin:Pin$1,"Pinned by":"",Send:Send$1,"Sending...":"","Start of a new thread":"","This message was deleted...":"",Thread:Thread$1,"Type your message":"",Unmute:Unmute$1,Unpin:Unpin$1,"You have no channels currently":"","You've reached the maximum number of files":"",live:live$1,"this content could not be displayed":"Deze inhoud kan niet weergegeven worden","{{ commaSeparatedUsers }} and {{ lastUser }} are typing...":"","{{ commaSeparatedUsers }} and {{ moreCount }} more":"","{{ commaSeparatedUsers }}, and {{ lastUser }}":"","{{ firstUser }} and {{ secondUser }}":"","{{ firstUser }} and {{ secondUser }} are typing...":"","{{ imageCount }} more":"","{{ memberCount }} members":"{{ memberCount }} deelnemers","{{ replyCount }} replies":"","{{ user }} has been muted":"","{{ user }} has been unmuted":"","{{ user }} is typing...":"","{{ watcherCount }} online":"{{ watcherCount }} online","üèô Attachment...":"üèô Bijlage..."};

var Cancel$2="";var Close$2="";var Delete$2="";var Delivered$2="";var Flag$2="";var Mute$2="";var New$2="";var Pin$2="";var Send$2="";var Thread$2="";var Unmute$2="";var Unpin$2="";var live$2="–í –ø—Ä—è–º–æ–º —ç—Ñ–∏—Ä–µ";var ruTranslations = {"1 reply":"","Attach files":"",Cancel:Cancel$2,"Channel Missing":"–ö–∞–Ω–∞–ª –Ω–µ –Ω–∞–π–¥–µ–Ω",Close:Close$2,"Commands matching":"–°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –∫–æ–º–∞–Ω–¥","Connection failure, reconnecting now...":"",Delete:Delete$2,Delivered:Delivered$2,"Edit Message":"","Emoji matching":"–°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —ç–º–æ–¥–∑–∏","Empty message...":"–ü—É—Å—Ç–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ...","Error adding flag: Either the flag already exist or there is issue with network connection ...":"","Error connecting to chat, refresh the page to try again.":"","Error muting a user ...":"","Error pinning message":"","Error removing message pin":"","Error unmuting a user ...":"","Error ¬∑ Unsent":"","Error: {{ errorMessage }}":"",Flag:Flag$2,"Message Failed ¬∑ Click to try again":"","Message deleted":"–°–æ–æ–±—â–µ–Ω–∏–µ —É–¥–∞–ª–µ–Ω–æ","Message failed. Click to try again.":"","Message has been successfully flagged":"","Message pinned":"",Mute:Mute$2,New:New$2,"New Messages!":"","Nothing yet...":"–ü–æ–∫–∞ –Ω–∏—á–µ–≥–æ –Ω–µ—Ç...","Only visible to you":"","Open emoji picker":"","People matching":"–°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ –ª—é–¥–∏","Pick your emoji":"",Pin:Pin$2,"Pinned by":"",Send:Send$2,"Sending...":"","Start of a new thread":"","This message was deleted...":"",Thread:Thread$2,"Type your message":"",Unmute:Unmute$2,Unpin:Unpin$2,"You have no channels currently":"","You've reached the maximum number of files":"",live:live$2,"this content could not be displayed":"–≠—Ç–æ—Ç –∫–æ–Ω—Ç–µ–Ω—Ç –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –æ—Ç–æ–±—Ä–∞–∂–µ–Ω –≤ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç","{{ commaSeparatedUsers }} and {{ lastUser }} are typing...":"","{{ commaSeparatedUsers }} and {{ moreCount }} more":"","{{ commaSeparatedUsers }}, and {{ lastUser }}":"","{{ firstUser }} and {{ secondUser }}":"","{{ firstUser }} and {{ secondUser }} are typing...":"","{{ imageCount }} more":"","{{ memberCount }} members":"{{ memberCount }} —á–ª–µ–Ω—ã","{{ replyCount }} replies":"","{{ user }} has been muted":"","{{ user }} has been unmuted":"","{{ user }} is typing...":"","{{ watcherCount }} online":"{{ watcherCount }} –≤ —Å–µ—Ç–∏","üèô Attachment...":"üèô –í–ª–æ–∂–µ–Ω–∏–µ..."};

var Cancel$3="";var Close$3="";var Delete$3="";var Delivered$3="";var Flag$3="";var Mute$3="";var New$3="";var Pin$3="";var Send$3="";var Thread$3="";var Unmute$3="";var Unpin$3="";var live$3="canlƒ±";var trTranslations = {"1 reply":"","Attach files":"",Cancel:Cancel$3,"Channel Missing":"Kanal bulunamƒ±yor",Close:Close$3,"Commands matching":"E≈üle≈üen komutlar","Connection failure, reconnecting now...":"",Delete:Delete$3,Delivered:Delivered$3,"Edit Message":"","Emoji matching":"Emoji e≈üle≈ütirme","Empty message...":"Bo≈ü mesaj...","Error adding flag: Either the flag already exist or there is issue with network connection ...":"","Error connecting to chat, refresh the page to try again.":"","Error muting a user ...":"","Error pinning message":"","Error removing message pin":"","Error unmuting a user ...":"","Error ¬∑ Unsent":"","Error: {{ errorMessage }}":"",Flag:Flag$3,"Message Failed ¬∑ Click to try again":"","Message deleted":"Mesaj silindi","Message failed. Click to try again.":"","Message has been successfully flagged":"","Message pinned":"",Mute:Mute$3,New:New$3,"New Messages!":"","Nothing yet...":"≈ûimdilik hi√ßbir ≈üey...","Only visible to you":"","Open emoji picker":"","People matching":"E≈üle≈üen ki≈üiler","Pick your emoji":"",Pin:Pin$3,"Pinned by":"",Send:Send$3,"Sending...":"","Start of a new thread":"","This message was deleted...":"",Thread:Thread$3,"Type your message":"",Unmute:Unmute$3,Unpin:Unpin$3,"You have no channels currently":"","You've reached the maximum number of files":"",live:live$3,"this content could not be displayed":"bu i√ßerik g√∂sterilemiyor","{{ commaSeparatedUsers }} and {{ lastUser }} are typing...":"","{{ commaSeparatedUsers }} and {{ moreCount }} more":"","{{ commaSeparatedUsers }}, and {{ lastUser }}":"","{{ firstUser }} and {{ secondUser }}":"","{{ firstUser }} and {{ secondUser }} are typing...":"","{{ imageCount }} more":"","{{ memberCount }} members":"{{ memberCount }} √ºyeler","{{ replyCount }} replies":"","{{ user }} has been muted":"","{{ user }} has been unmuted":"","{{ user }} is typing...":"","{{ watcherCount }} online":"{{ watcherCount }} √ßevrimi√ßi","üèô Attachment...":"üèô Ek..."};

var Cancel$4="";var Close$4="";var Delete$4="";var Delivered$4="";var Flag$4="";var Mute$4="";var New$4="";var Pin$4="";var Send$4="";var Thread$4="";var Unmute$4="";var Unpin$4="";var live$4="en direct";var frTranslations = {"1 reply":"","Attach files":"",Cancel:Cancel$4,"Channel Missing":"Canal Manquant",Close:Close$4,"Commands matching":"Correspondance des commandes","Connection failure, reconnecting now...":"",Delete:Delete$4,Delivered:Delivered$4,"Edit Message":"","Emoji matching":"Correspondance emoji","Empty message...":"Message vide...","Error adding flag: Either the flag already exist or there is issue with network connection ...":"","Error connecting to chat, refresh the page to try again.":"","Error muting a user ...":"","Error pinning message":"","Error removing message pin":"","Error unmuting a user ...":"","Error ¬∑ Unsent":"","Error: {{ errorMessage }}":"",Flag:Flag$4,"Message Failed ¬∑ Click to try again":"","Message deleted":"Message supprim√©","Message failed. Click to try again.":"","Message has been successfully flagged":"","Message pinned":"",Mute:Mute$4,New:New$4,"New Messages!":"","Nothing yet...":"Aucun message...","Only visible to you":"","Open emoji picker":"","People matching":"Correspondance de personnes","Pick your emoji":"",Pin:Pin$4,"Pinned by":"",Send:Send$4,"Sending...":"","Start of a new thread":"","This message was deleted...":"",Thread:Thread$4,"Type your message":"",Unmute:Unmute$4,Unpin:Unpin$4,"You have no channels currently":"","You've reached the maximum number of files":"",live:live$4,"this content could not be displayed":"ce contenu n'a pu √™tre affich√©","{{ commaSeparatedUsers }} and {{ lastUser }} are typing...":"","{{ commaSeparatedUsers }} and {{ moreCount }} more":"","{{ commaSeparatedUsers }}, and {{ lastUser }}":"","{{ firstUser }} and {{ secondUser }}":"","{{ firstUser }} and {{ secondUser }} are typing...":"","{{ imageCount }} more":"","{{ memberCount }} members":"{{ memberCount }} membres","{{ replyCount }} replies":"","{{ user }} has been muted":"","{{ user }} has been unmuted":"","{{ user }} is typing...":"","{{ watcherCount }} online":"{{ watcherCount }} en ligne","üèô Attachment...":"üèô Pi√®ce jointe..."};

var Cancel$5="";var Close$5="";var Delete$5="";var Delivered$5="";var Flag$5="";var Mute$5="";var New$5="";var Pin$5="";var Send$5="";var Thread$5="";var Unmute$5="";var Unpin$5="";var live$5="‡§≤‡§æ‡§á‡§µ";var hiTranslations = {"1 reply":"","Attach files":"",Cancel:Cancel$5,"Channel Missing":"‡§ö‡•à‡§®‡§≤ ‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à",Close:Close$5,"Commands matching":"‡§Æ‡•á‡§≤ ‡§ñ‡§æ‡§§‡•Ä ‡§π‡•à","Connection failure, reconnecting now...":"",Delete:Delete$5,Delivered:Delivered$5,"Edit Message":"","Emoji matching":"‡§á‡§Æ‡•ã‡§ú‡•Ä ‡§Æ‡§ø‡§≤‡§æ‡§®","Empty message...":"‡§ñ‡§æ‡§≤‡•Ä ‡§∏‡§Ç‡§¶‡•á‡§∂ ...","Error adding flag: Either the flag already exist or there is issue with network connection ...":"","Error connecting to chat, refresh the page to try again.":"","Error muting a user ...":"","Error pinning message":"","Error removing message pin":"","Error unmuting a user ...":"","Error ¬∑ Unsent":"","Error: {{ errorMessage }}":"",Flag:Flag$5,"Message Failed ¬∑ Click to try again":"","Message deleted":"‡§Æ‡•à‡§∏‡•á‡§ú ‡§π‡§ü‡§æ ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ","Message failed. Click to try again.":"","Message has been successfully flagged":"","Message pinned":"",Mute:Mute$5,New:New$5,"New Messages!":"","Nothing yet...":"‡§ï‡•ã‡§à ‡§Æ‡•à‡§∏‡•á‡§ú ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à","Only visible to you":"","Open emoji picker":"","People matching":"‡§Æ‡•á‡§≤ ‡§ñ‡§æ‡§§‡•á ‡§≤‡•ã‡§ó","Pick your emoji":"",Pin:Pin$5,"Pinned by":"",Send:Send$5,"Sending...":"","Start of a new thread":"","This message was deleted...":"",Thread:Thread$5,"Type your message":"",Unmute:Unmute$5,Unpin:Unpin$5,"You have no channels currently":"","You've reached the maximum number of files":"",live:live$5,"this content could not be displayed":"‡§Ø‡§π ‡§ï‡•â‡§®‡•ç‡§ü‡•á‡§Ç‡§ü ‡§≤‡•ã‡§° ‡§®‡§π‡•Ä‡§Ç ‡§π‡•ã ‡§™‡§æ‡§Ø‡§æ","{{ commaSeparatedUsers }} and {{ lastUser }} are typing...":"","{{ commaSeparatedUsers }} and {{ moreCount }} more":"","{{ commaSeparatedUsers }}, and {{ lastUser }}":"","{{ firstUser }} and {{ secondUser }}":"","{{ firstUser }} and {{ secondUser }} are typing...":"","{{ imageCount }} more":"","{{ memberCount }} members":"{{ memberCount }} ‡§Æ‡•á‡§Ç‡§¨‡§∞‡•ç‡§∏","{{ replyCount }} replies":"","{{ user }} has been muted":"","{{ user }} has been unmuted":"","{{ user }} is typing...":"","{{ watcherCount }} online":"{{ watcherCount }} online","üèô Attachment...":"üèô ‡§Ö‡§ü‡•à‡§ö‡§Æ‡•á‡§Ç‡§ü"};

var Cancel$6="";var Close$6="";var Delete$6="";var Delivered$6="";var Flag$6="";var Mute$6="";var New$6="";var Pin$6="";var Send$6="";var Thread$6="";var Unmute$6="";var Unpin$6="";var live$6="live";var itTranslations = {"1 reply":"","Attach files":"",Cancel:Cancel$6,"Channel Missing":"Il canale non esiste",Close:Close$6,"Commands matching":"Comandi corrispondenti","Connection failure, reconnecting now...":"",Delete:Delete$6,Delivered:Delivered$6,"Edit Message":"","Emoji matching":"Abbinamento emoji","Empty message...":"Message vuoto...","Error adding flag: Either the flag already exist or there is issue with network connection ...":"","Error connecting to chat, refresh the page to try again.":"","Error muting a user ...":"","Error pinning message":"","Error removing message pin":"","Error unmuting a user ...":"","Error ¬∑ Unsent":"","Error: {{ errorMessage }}":"",Flag:Flag$6,"Message Failed ¬∑ Click to try again":"","Message deleted":"Messaggio cancellato","Message failed. Click to try again.":"","Message has been successfully flagged":"","Message pinned":"",Mute:Mute$6,New:New$6,"New Messages!":"","Nothing yet...":"Ancora niente...","Only visible to you":"","Open emoji picker":"","People matching":"Persone che corrispondono","Pick your emoji":"",Pin:Pin$6,"Pinned by":"",Send:Send$6,"Sending...":"","Start of a new thread":"","This message was deleted...":"",Thread:Thread$6,"Type your message":"",Unmute:Unmute$6,Unpin:Unpin$6,"You have no channels currently":"","You've reached the maximum number of files":"",live:live$6,"this content could not be displayed":"questo contenuto non pu√≥ essere mostrato","{{ commaSeparatedUsers }} and {{ lastUser }} are typing...":"","{{ commaSeparatedUsers }} and {{ moreCount }} more":"","{{ commaSeparatedUsers }}, and {{ lastUser }}":"","{{ firstUser }} and {{ secondUser }}":"","{{ firstUser }} and {{ secondUser }} are typing...":"","{{ imageCount }} more":"","{{ memberCount }} members":"{{ memberCount }} membri","{{ replyCount }} replies":"","{{ user }} has been muted":"","{{ user }} has been unmuted":"","{{ user }} is typing...":"","{{ watcherCount }} online":"{{ watcherCount }} online","üèô Attachment...":"üèô Allegato..."};

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var defaultNS = 'translation';
var defaultLng = 'en';
Dayjs__default['default'].extend(updateLocale__default['default']);
Dayjs__default['default'].updateLocale('nl', {
  calendar: {
    sameDay: '[vandaag om] LT',
    nextDay: '[morgen om] LT',
    nextWeek: 'dddd [om] LT',
    lastDay: '[gisteren om] LT',
    lastWeek: '[afgelopen] dddd [om] LT',
    sameElse: 'L'
  }
});
Dayjs__default['default'].updateLocale('it', {
  calendar: {
    sameDay: '[Oggi alle] LT',
    nextDay: '[Domani alle] LT',
    nextWeek: 'dddd [alle] LT',
    lastDay: '[Ieri alle] LT',
    lastWeek: '[lo scorso] dddd [alle] LT',
    sameElse: 'L'
  }
});
Dayjs__default['default'].updateLocale('hi', {
  calendar: {
    sameDay: '[‡§Ü‡§ú] LT',
    nextDay: '[‡§ï‡§≤] LT',
    nextWeek: 'dddd, LT',
    lastDay: '[‡§ï‡§≤] LT',
    lastWeek: '[‡§™‡§ø‡§õ‡§≤‡•á] dddd, LT',
    sameElse: 'L'
  },
  // Hindi notation for meridiems are quite fuzzy in practice. While there exists
  // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
  meridiemParse: /‡§∞‡§æ‡§§|‡§∏‡•Å‡§¨‡§π|‡§¶‡•ã‡§™‡§π‡§∞|‡§∂‡§æ‡§Æ/,

  meridiemHour(hour, meridiem) {
    if (hour === 12) {
      hour = 0;
    }

    if (meridiem === '‡§∞‡§æ‡§§') {
      return hour < 4 ? hour : hour + 12;
    } else if (meridiem === '‡§∏‡•Å‡§¨‡§π') {
      return hour;
    } else if (meridiem === '‡§¶‡•ã‡§™‡§π‡§∞') {
      return hour >= 10 ? hour : hour + 12;
    } else if (meridiem === '‡§∂‡§æ‡§Æ') {
      return hour + 12;
    }
  },

  meridiem(hour) {
    if (hour < 4) {
      return '‡§∞‡§æ‡§§';
    } else if (hour < 10) {
      return '‡§∏‡•Å‡§¨‡§π';
    } else if (hour < 17) {
      return '‡§¶‡•ã‡§™‡§π‡§∞';
    } else if (hour < 20) {
      return '‡§∂‡§æ‡§Æ';
    } else {
      return '‡§∞‡§æ‡§§';
    }
  }

});
Dayjs__default['default'].updateLocale('fr', {
  calendar: {
    sameDay: '[Aujourd‚Äôhui √†] LT',
    nextDay: '[Demain √†] LT',
    nextWeek: 'dddd [√†] LT',
    lastDay: '[Hier √†] LT',
    lastWeek: 'dddd [dernier √†] LT',
    sameElse: 'L'
  }
});
Dayjs__default['default'].updateLocale('tr', {
  calendar: {
    sameDay: '[bug√ºn saat] LT',
    nextDay: '[yarƒ±n saat] LT',
    nextWeek: '[gelecek] dddd [saat] LT',
    lastDay: '[d√ºn] LT',
    lastWeek: '[ge√ßen] dddd [saat] LT',
    sameElse: 'L'
  }
});
Dayjs__default['default'].updateLocale('ru', {
  calendar: {
    sameDay: '[–°–µ–≥–æ–¥–Ω—è, –≤] LT',
    nextDay: '[–ó–∞–≤—Ç—Ä–∞, –≤] LT',
    lastDay: '[–í—á–µ—Ä–∞, –≤] LT'
  }
});
var en_locale = {
  weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
  months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_')
};
/**
 * Wrapper around [i18next](https://www.i18next.com/) class for Stream related translations.
 * Instance of this class should be provided to Chat component to handle translations.
 * Stream provides following list of in-built translations:
 * 1. English (en)
 * 2. Dutch (nl)
 * 3. Russian (ru)
 * 4. Turkish (tr)
 * 5. French (fr)
 * 6. Italian (it)
 * 7. Hindi (hi)
 *
 * Simplest way to start using chat components in one of the in-built languages would be following:
 *
 * ```
 * const i18n = new Streami18n({ language 'nl' });
 * <Chat client={chatClient} i18nInstance={i18n}>
 *  ...
 * </Chat>
 * ```
 *
 * If you would like to override certain keys in in-built translation.
 * UI will be automatically updated in this case.
 *
 * ```
 * const i18n = new Streami18n({
 *  language: 'nl',
 *  translationsForLanguage: {
 *    'Nothing yet...': 'Nog Niet ...',
 *    '{{ firstUser }} and {{ secondUser }} are typing...': '{{ firstUser }} en {{ secondUser }} zijn aan het typen...',
 *  }
 * });
 *
 * If you would like to register additional languages, use registerTranslation. You can add as many languages as you want:
 *
 * i18n.registerTranslation('zh', {
 *  'Nothing yet...': 'Nog Niet ...',
 *  '{{ firstUser }} and {{ secondUser }} are typing...': '{{ firstUser }} en {{ secondUser }} zijn aan het typen...',
 * });
 *
 * <Chat client={chatClient} i18nInstance={i18n}>
 *  ...
 * </Chat>
 * ```
 *
 * You can use the same function to add whole new language as well.
 *
 * ```
 * const i18n = new Streami18n();
 *
 * i18n.registerTranslation('mr', {
 *  'Nothing yet...': '‡§ï‡§æ‡§π‡•Ä‡§π‡•Ä ‡§®‡§æ‡§π‡•Ä  ...',
 *  '{{ firstUser }} and {{ secondUser }} are typing...': '{{ firstUser }} ‡§Ü‡§£‡§ø {{ secondUser }} ‡§ü‡•Ä‡§™‡•Ä ‡§ï‡§∞‡§§ ‡§Ü‡§π‡•á‡§§ ',
 * });
 *
 * // Make sure to call setLanguage to reflect new language in UI.
 * i18n.setLanguage('it');
 * <Chat client={chatClient} i18nInstance={i18n}>
 *  ...
 * </Chat>
 * ```
 *
 * ## Datetime translations
 *
 * Stream react chat components uses [dayjs](https://day.js.org/en/) internally by default to format datetime stamp.
 * e.g., in ChannelPreview, MessageContent components.
 * Dayjs has locale support as well - https://day.js.org/docs/en/i18n/i18n
 * Dayjs is a lightweight alternative to Momentjs with the same modern API.
 *
 * Dayjs provides locale config for plenty of languages, you can check the whole list of locale configs at following url
 * https://github.com/iamkun/dayjs/tree/dev/src/locale
 *
 * You can either provide the dayjs locale config while registering
 * language with Streami18n (either via constructor or registerTranslation()) or you can provide your own Dayjs or Moment instance
 * to Streami18n constructor, which will be then used internally (using the language locale) in components.
 *
 * 1. Via language registration
 *
 * e.g.,
 * ```
 * const i18n = new Streami18n({
 *  language: 'nl',
 *  dayjsLocaleConfigForLanguage: {
 *    months: [...],
 *    monthsShort: [...],
 *    calendar: {
 *      sameDay: ...'
 *    }
 *  }
 * });
 * ```
 *
 * Similarly, you can add locale config for moment while registering translation via `registerTranslation` function.
 *
 * e.g.,
 * ```
 * const i18n = new Streami18n();
 *
 * i18n.registerTranslation(
 *  'mr',
 *  {
 *    'Nothing yet...': '‡§ï‡§æ‡§π‡•Ä‡§π‡•Ä ‡§®‡§æ‡§π‡•Ä  ...',
 *    '{{ firstUser }} and {{ secondUser }} are typing...': '{{ firstUser }} ‡§Ü‡§£‡§ø {{ secondUser }} ‡§ü‡•Ä‡§™‡•Ä ‡§ï‡§∞‡§§ ‡§Ü‡§π‡•á‡§§ ',
 *  },
 *  {
 *    months: [...],
 *    monthsShort: [...],
 *    calendar: {
 *      sameDay: ...'
 *    }
 *  }
 * );
 *```
 * 2. Provide your own Moment object
 *
 * ```js
 * import 'moment/locale/nl';
 * import 'moment/locale/it';
 * // or if you want to include all locales
 * import 'moment/min/locales';
 *
 * import Moment from moment
 *
 * const i18n = new Streami18n({
 *  language: 'nl',
 *  DateTimeParser: Moment
 * })
 * ```
 *
 * 3. Provide your own Dayjs object
 *
 * ```js
 * import Dayjs from 'dayjs'
 *
 * import 'dayjs/locale/nl';
 * import 'dayjs/locale/it';
 * // or if you want to include all locales
 * import 'dayjs/min/locales';
 *
 * const i18n = new Streami18n({
 *  language: 'nl',
 *  DateTimeParser: Dayjs
 * })
 * ```
 * If you would like to stick with english language for datetimes in Stream compoments, you can set `disableDateTimeTranslations` to true.
 *
 */

var defaultStreami18nOptions = {
  language: 'en',
  disableDateTimeTranslations: false,
  debug: false,
  logger: function logger(msg) {
    return console.warn(msg);
  },
  dayjsLocaleConfigForLanguage: null,
  DateTimeParser: Dayjs__default['default']
};
var Streami18n = /*#__PURE__*/function () {
  /**
   * dayjs.defineLanguage('nl') also changes the global locale. We don't want to do that
   * when user calls registerTranslation() function. So intead we will store the locale configs
   * given to registerTranslation() function in `dayjsLocales` object, and register the required locale
   * with moment, when setLanguage is called.
   * */

  /**
   * Contructor accepts following options:
   *  - language (String) default: 'en'
   *    Language code e.g., en, tr
   *
   *  - translationsForLanguage (object)
   *    Translations object. Please check src/i18n/en.json for example.
   *
   *  - disableDateTimeTranslations (boolean) default: false
   *    Disable translations for datetimes
   *
   *  - debug (boolean) default: false
   *    Enable debug mode in internal i18n class
   *
   *  - logger (function) default: () => {}
   *    Logger function to log warnings/errors from this class
   *
   *  - dayjsLocaleConfigForLanguage (object) default: 'enConfig'
   *    [Config object](https://momentjs.com/docs/#/i18n/changing-locale/) for internal moment object,
   *    corresponding to language (param)
   *
   *  - DateTimeParser (function) Moment or Dayjs instance/function.
   *    Make sure to load all the required locales in this Moment or Dayjs instance that you will be provide to Streami18n
   *
   * @param {*} options
   */
  function Streami18n() {
    var _this = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck__default['default'](this, Streami18n);

    _defineProperty__default['default'](this, "i18nInstance", i18n__default['default'].createInstance());

    _defineProperty__default['default'](this, "Dayjs", null);

    _defineProperty__default['default'](this, "setLanguageCallback", function () {
      return null;
    });

    _defineProperty__default['default'](this, "initialized", false);

    _defineProperty__default['default'](this, "t", null);

    _defineProperty__default['default'](this, "tDateTimeParser", null);

    _defineProperty__default['default'](this, "translations", {
      en: {
        [defaultNS]: enTranslations
      },
      nl: {
        [defaultNS]: nlTranslations
      },
      ru: {
        [defaultNS]: ruTranslations
      },
      tr: {
        [defaultNS]: trTranslations
      },
      fr: {
        [defaultNS]: frTranslations
      },
      hi: {
        [defaultNS]: hiTranslations
      },
      it: {
        [defaultNS]: itTranslations
      }
    });

    _defineProperty__default['default'](this, "dayjsLocales", {});

    _defineProperty__default['default'](this, "localeExists", function (language) {
      if (_this.isCustomDateTimeParser) return true;
      return Object.keys(Dayjs__default['default'].Ls).indexOf(language) > -1;
    });

    _defineProperty__default['default'](this, "validateCurrentLanguage", function () {
      var availableLanguages = Object.keys(_this.translations);

      if (availableLanguages.indexOf(_this.currentLanguage) === -1) {
        _this.logger("Streami18n: '".concat(_this.currentLanguage, "' language is not registered.") + " Please make sure to call streami18n.registerTranslation('".concat(_this.currentLanguage, "', {...}) or ") + "use one the built-in supported languages - ".concat(_this.getAvailableLanguages()));

        _this.currentLanguage = defaultLng;
      }
    });

    _defineProperty__default['default'](this, "geti18Instance", function () {
      return _this.i18nInstance;
    });

    _defineProperty__default['default'](this, "getAvailableLanguages", function () {
      return Object.keys(_this.translations);
    });

    _defineProperty__default['default'](this, "getTranslations", function () {
      return _this.translations;
    });

    var finalOptions = _objectSpread$1(_objectSpread$1({}, defaultStreami18nOptions), options); // Prepare the i18next configuration.


    this.logger = finalOptions.logger;
    this.currentLanguage = finalOptions.language;
    this.DateTimeParser = finalOptions.DateTimeParser;

    try {
      // This is a shallow check to see if given parser is instance of Dayjs.
      // For some reason Dayjs.isDayjs(this.DateTimeParser()) doesn't work.
      if (this.DateTimeParser && this.DateTimeParser.extend) {
        this.DateTimeParser.extend(LocalizedFormat__default['default']);
        this.DateTimeParser.extend(calendar__default['default']);
        this.DateTimeParser.extend(localeData__default['default']);
        this.DateTimeParser.extend(relativeTime__default['default']);
      }
    } catch (error) {
      throw Error("Streami18n: Looks like you wanted to provide Dayjs instance, but something went wrong while adding plugins ".concat(error));
    }

    this.isCustomDateTimeParser = !!options.DateTimeParser;
    var translationsForLanguage = finalOptions.translationsForLanguage;

    if (translationsForLanguage) {
      this.translations[this.currentLanguage] = {
        [defaultNS]: translationsForLanguage
      };
    } // If translations don't exist for given language, then set it as empty object.


    if (!this.translations[this.currentLanguage]) {
      this.translations[this.currentLanguage] = {
        [defaultNS]: {}
      };
    }

    this.i18nextConfig = {
      nsSeparator: false,
      keySeparator: false,
      fallbackLng: false,
      debug: finalOptions.debug,
      lng: this.currentLanguage,
      interpolation: {
        escapeValue: false
      },
      parseMissingKeyHandler: function parseMissingKeyHandler(key) {
        _this.logger("Streami18n: Missing translation for key: ".concat(key));

        return key;
      }
    };
    this.validateCurrentLanguage(this.currentLanguage);
    var dayjsLocaleConfigForLanguage = finalOptions.dayjsLocaleConfigForLanguage;

    if (dayjsLocaleConfigForLanguage) {
      this.addOrUpdateLocale(this.currentLanguage, _objectSpread$1({}, dayjsLocaleConfigForLanguage));
    } else if (!this.localeExists(this.currentLanguage)) {
      this.logger("Streami18n: Streami18n(...) - Locale config for ".concat(this.currentLanguage, " does not exist in momentjs.") + "Please import the locale file using \"import 'moment/locale/".concat(this.currentLanguage, "';\" in your app or ") + "register the locale config with Streami18n using registerTranslation(language, translation, customDayjsLocale)");
    }

    this.tDateTimeParser = function (timestamp) {
      if (finalOptions.disableDateTimeTranslations || !_this.localeExists(_this.currentLanguage)) {
        return _this.DateTimeParser(timestamp).locale(defaultLng);
      }

      return _this.DateTimeParser(timestamp).locale(_this.currentLanguage);
    };
  }
  /**
   * Initializes the i18next instance with configuration (which enables natural language as default keys)
   */


  _createClass__default['default'](Streami18n, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {
        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.validateCurrentLanguage();
                _context.prev = 1;
                _context.next = 4;
                return this.i18nInstance.init(_objectSpread$1(_objectSpread$1({}, this.i18nextConfig), {}, {
                  resources: this.translations,
                  lng: this.currentLanguage
                }));

              case 4:
                this.t = _context.sent;
                this.initialized = true;
                return _context.abrupt("return", {
                  t: this.t,
                  tDateTimeParser: this.tDateTimeParser
                });

              case 9:
                _context.prev = 9;
                _context.t0 = _context["catch"](1);
                this.logger("Something went wrong with init:", _context.t0);

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[1, 9]]);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "getTranslators",

    /**
     * Returns current version translator function.
     */
    value: function () {
      var _getTranslators = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2() {
        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this.initialized) {
                  _context2.next = 7;
                  break;
                }

                if (this.dayjsLocales[this.currentLanguage]) {
                  this.addOrUpdateLocale(this.currentLanguage, this.dayjsLocales[this.currentLanguage]);
                }

                _context2.next = 4;
                return this.init();

              case 4:
                return _context2.abrupt("return", _context2.sent);

              case 7:
                return _context2.abrupt("return", {
                  t: this.t,
                  tDateTimeParser: this.tDateTimeParser
                });

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getTranslators() {
        return _getTranslators.apply(this, arguments);
      }

      return getTranslators;
    }()
    /**
     * Register translation
     *
     * @param {*} language
     * @param {*} translation
     * @param {*} customDayjsLocale
     */

  }, {
    key: "registerTranslation",
    value: function registerTranslation(language, translation, customDayjsLocale) {
      if (!translation) {
        this.logger("Streami18n: registerTranslation(language, translation, customDayjsLocale) called without translation");
        return;
      }

      if (!this.translations[language]) {
        this.translations[language] = {
          [defaultNS]: translation
        };
      } else {
        this.translations[language][defaultNS] = translation;
      }

      if (customDayjsLocale) {
        this.dayjsLocales[language] = _objectSpread$1({}, customDayjsLocale);
      } else if (!this.localeExists(language)) {
        this.logger("Streami18n: registerTranslation(language, translation, customDayjsLocale) - " + "Locale config for ".concat(language, " does not exist in Dayjs.") + "Please import the locale file using \"import 'dayjs/locale/".concat(language, "';\" in your app or ") + "register the locale config with Streami18n using registerTranslation(language, translation, customDayjsLocale)");
      }

      if (this.initialized) {
        this.i18nInstance.addResources(language, defaultNS, translation);
      }
    }
  }, {
    key: "addOrUpdateLocale",
    value: function addOrUpdateLocale(key, config) {
      if (this.localeExists(key)) {
        Dayjs__default['default'].updateLocale(key, _objectSpread$1({}, config));
      } else {
        // Merging the custom locale config with en config, so missing keys can default to english.
        Dayjs__default['default'].locale(_objectSpread$1({
          name: key
        }, _objectSpread$1(_objectSpread$1({}, en_locale), config)), null, true);
      }
    }
    /**
     * Changes the language.
     * @param {*} language
     */

  }, {
    key: "setLanguage",
    value: function () {
      var _setLanguage = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(language) {
        var t;
        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                this.currentLanguage = language;

                if (this.initialized) {
                  _context3.next = 3;
                  break;
                }

                return _context3.abrupt("return");

              case 3:
                _context3.prev = 3;
                _context3.next = 6;
                return this.i18nInstance.changeLanguage(language);

              case 6:
                t = _context3.sent;

                if (this.dayjsLocales[language]) {
                  this.addOrUpdateLocale(this.currentLanguage, this.dayjsLocales[this.currentLanguage]);
                }

                this.setLanguageCallback(t);
                return _context3.abrupt("return", t);

              case 12:
                _context3.prev = 12;
                _context3.t0 = _context3["catch"](3);
                this.logger("Failed to set language:", _context3.t0);

              case 15:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[3, 12]]);
      }));

      function setLanguage(_x) {
        return _setLanguage.apply(this, arguments);
      }

      return setLanguage;
    }()
    /**
     * @param {(t: import('i18next').TFunction) => void} callback
     */

  }, {
    key: "registerSetLanguageCallback",
    value: function registerSetLanguageCallback(callback) {
      this.setLanguageCallback = callback;
    }
  }]);

  return Streami18n;
}();

var version="3.6.0";

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var useChat = function useChat(_ref) {
  var _client$user;

  var client = _ref.client,
      initialNavOpen = _ref.initialNavOpen,
      i18nInstance = _ref.i18nInstance;

  var _useState = React.useState(
  /** @type { Required<import('../types').TranslationContextValue>} */
  {
    t:
    /** @param {string} key */
    function t(key) {
      return key;
    },
    tDateTimeParser: function tDateTimeParser(input) {
      return Dayjs__default['default'](input);
    },
    userLanguage: ''
  }),
      _useState2 = _slicedToArray__default['default'](_useState, 2),
      translators = _useState2[0],
      setTranslators = _useState2[1];

  var _useState3 = React.useState(
  /** @type {import('stream-chat').Mute[]} */
  []),
      _useState4 = _slicedToArray__default['default'](_useState3, 2),
      mutes = _useState4[0],
      setMutes = _useState4[1];

  var _useState5 = React.useState(initialNavOpen),
      _useState6 = _slicedToArray__default['default'](_useState5, 2),
      navOpen = _useState6[0],
      setNavOpen = _useState6[1];

  var _useState7 = React.useState(
  /** @type {ChannelState} */
  undefined),
      _useState8 = _slicedToArray__default['default'](_useState7, 2),
      channel = _useState8[0],
      setChannel = _useState8[1];

  var openMobileNav = function openMobileNav() {
    return setTimeout(function () {
      return setNavOpen(true);
    }, 100);
  };

  var closeMobileNav = function closeMobileNav() {
    return setNavOpen(false);
  };

  var clientMutes = client === null || client === void 0 ? void 0 : (_client$user = client.user) === null || _client$user === void 0 ? void 0 : _client$user.mutes;
  React.useEffect(function () {
    var userAgent = client.getUserAgent();

    if (!userAgent.includes('stream-chat-react')) {
      /**
       * results in something like: 'stream-chat-react-2.3.2-stream-chat-javascript-client-browser-2.2.2'
       */
      client.setUserAgent("stream-chat-react-".concat(version, "-").concat(userAgent));
    }
  }, []); // eslint-disable-line react-hooks/exhaustive-deps

  React.useEffect(function () {
    setMutes(clientMutes || []);
    /** @param {import('stream-chat').Event} e */

    var handleEvent = function handleEvent(e) {
      var _e$me;

      if (e.type === 'notification.mutes_updated') setMutes(((_e$me = e.me) === null || _e$me === void 0 ? void 0 : _e$me.mutes) || []);
    };

    if (client) client.on(handleEvent);
    return function () {
      return client && client.off(handleEvent);
    };
  }, [client, clientMutes]);
  React.useEffect(function () {
    var streami18n;

    if (i18nInstance instanceof Streami18n) {
      streami18n = i18nInstance;
    } else {
      streami18n = new Streami18n({
        language: 'en'
      });
    }

    streami18n.registerSetLanguageCallback(function (t) {
      return setTranslators(function (prevTranslator) {
        return _objectSpread$2(_objectSpread$2({}, prevTranslator), {}, {
          t
        });
      });
    });
    streami18n.getTranslators().then(function (translator) {
      if (translator) {
        var _client$user2;

        setTranslators(_objectSpread$2(_objectSpread$2({}, translator), {}, {
          userLanguage: (client === null || client === void 0 ? void 0 : (_client$user2 = client.user) === null || _client$user2 === void 0 ? void 0 : _client$user2.language) || ''
        }));
      }
    });
  }, [client, i18nInstance]);
  var setActiveChannel = React.useCallback(
  /*#__PURE__*/

  /**
   * @param {ChannelState} activeChannel
   * @param {{ limit?: number; offset?: number }} [watchers]
   * @param {React.BaseSyntheticEvent} [e]
   */
  function () {
    var _ref2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(activeChannel) {
      var watchers,
          e,
          _args = arguments;
      return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              watchers = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              e = _args.length > 2 ? _args[2] : undefined;
              if (e && e.preventDefault) e.preventDefault();

              if (!(activeChannel && Object.keys(watchers).length)) {
                _context.next = 6;
                break;
              }

              _context.next = 6;
              return activeChannel.query({
                watch: true,
                watchers
              });

            case 6:
              setChannel(activeChannel);
              closeMobileNav();

            case 8:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x) {
      return _ref2.apply(this, arguments);
    };
  }(), []);
  return {
    channel,
    closeMobileNav,
    mutes,
    navOpen,
    openMobileNav,
    setActiveChannel,
    translators
  };
};

/**
 * CustomChat - This component is a replacement for the Chat component. The only difference between both is
 * that the CustomChat component does not come with a default set of emojis, allowing for a custom set of emoji
 * related components
 *
 * @example ../../docs/CustomChat.md
 * @typedef {import('stream-chat').Channel | undefined} ChannelState
 * @type {React.FC<import('../types').CustomChatProps>}>}
 */

var CustomChat = function CustomChat(_ref) {
  var client = _ref.client,
      _ref$theme = _ref.theme,
      theme = _ref$theme === void 0 ? 'messaging light' : _ref$theme,
      i18nInstance = _ref.i18nInstance,
      _ref$initialNavOpen = _ref.initialNavOpen,
      initialNavOpen = _ref$initialNavOpen === void 0 ? true : _ref$initialNavOpen,
      children = _ref.children,
      emojiData = _ref.emojiData,
      EmojiPicker = _ref.EmojiPicker,
      EmojiIndex = _ref.EmojiIndex,
      Emoji = _ref.Emoji;
  var emojiConfig = {
    emojiData,
    EmojiPicker,
    Emoji,
    EmojiIndex,
    defaultMinimalEmojis,
    commonEmoji,
    emojiSetDef
  };

  var _useChat = useChat({
    client,
    initialNavOpen,
    i18nInstance
  }),
      setActiveChannel = _useChat.setActiveChannel,
      navOpen = _useChat.navOpen,
      mutes = _useChat.mutes,
      channel = _useChat.channel,
      openMobileNav = _useChat.openMobileNav,
      closeMobileNav = _useChat.closeMobileNav,
      translators = _useChat.translators;

  if (!translators.t) return null;
  return /*#__PURE__*/React__default['default'].createElement(ChatContext.Provider, {
    value: {
      client,
      theme,
      channel,
      mutes,
      navOpen,
      setActiveChannel,
      openMobileNav,
      closeMobileNav
    }
  }, /*#__PURE__*/React__default['default'].createElement(TranslationContext.Provider, {
    value: translators
  }, /*#__PURE__*/React__default['default'].createElement(EmojiContext.Provider, {
    value: emojiConfig
  }, children)));
};

CustomChat.propTypes = {
  /** The StreamChat client object */
  client:
  /** @type {PropTypes.Validator<import('stream-chat').StreamChat>} */
  PropTypes__default['default'].object.isRequired,

  /**
   *
   * Theme could be used for custom styling of the components.
   *
   * You can override the classes used in our components under parent theme class.
   *
   * e.g. If you want to build a theme where background of message is black
   *
   * ```
   *  <Chat client={client} theme={demo}>
   *    <Channel>
   *      <MessageList />
   *    </Channel>
   *  </Chat>
   * ```
   *
   * ```scss
   *  .demo.str-chat {
   *    .str-chat__message-simple {
   *      &-text-inner {
   *        background-color: black;
   *      }
   *    }
   *  }
   * ```
   *
   * Built in available themes:
   *
   *  - `messaging light`
   *  - `messaging dark`
   *  - `team light`
   *  - `team dark`
   *  - `commerce light`
   *  - `commerce dark`
   *  - `livestream light`
   *  - `livestream dark`
   */
  theme: PropTypes__default['default'].string,

  /** navOpen initial status */
  initialNavOpen: PropTypes__default['default'].bool
};

/**
 * AttachmentActions - The actions you can take on an attachment
 *
 * @example ../../docs/AttachmentActions.md
 * @type {React.FC<import('type').AttachmentActionsProps>}
 */

var AttachmentActions = function AttachmentActions(_ref) {
  var text = _ref.text,
      id = _ref.id,
      actions = _ref.actions,
      actionHandler = _ref.actionHandler;
  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__message-attachment-actions"
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__message-attachment-actions-form"
  }, /*#__PURE__*/React__default['default'].createElement("span", {
    key: 0
  }, text), actions.map(function (action) {
    return /*#__PURE__*/React__default['default'].createElement("button", {
      className: "str-chat__message-attachment-actions-button str-chat__message-attachment-actions-button--".concat(action.style),
      "data-testid": "".concat(action.name),
      key: "".concat(id, "-").concat(action.value),
      "data-value": action.value,
      onClick: function onClick(e) {
        return actionHandler(action.name, action.value, e);
      }
    }, action.text);
  })));
};

AttachmentActions.propTypes = {
  /** Unique id for action button key. Key is generated by concatenating this id with action value - {`${id}-${action.value}`} */
  id: PropTypes__default['default'].string.isRequired,

  /** The text for the form input */
  text: PropTypes__default['default'].string,

  /** A list of actions */
  actions: PropTypes__default['default'].array.isRequired,

  /**
   *
   * @param name {string} Name of action
   * @param value {string} Value of action
   * @param event Dom event that triggered this handler
   */
  actionHandler: PropTypes__default['default'].func.isRequired
};
var DefaultAttachmentActions = /*#__PURE__*/React__default['default'].memo(AttachmentActions);

var progressUpdateInterval = 500;
/**
 * Audio attachment with play/pause button and progress bar
 * @param {import("types").AudioProps} props
 */

var Audio = function Audio(_ref) {
  var og = _ref.og;
  var audioRef = React.useRef(
  /** @type {HTMLAudioElement | null} */
  null);

  var _useState = React.useState(false),
      _useState2 = _slicedToArray__default['default'](_useState, 2),
      isPlaying = _useState2[0],
      setIsPlaying = _useState2[1];

  var _useState3 = React.useState(0),
      _useState4 = _slicedToArray__default['default'](_useState3, 2),
      progress = _useState4[0],
      setProgress = _useState4[1];

  var updateProgress = React.useCallback(function () {
    if (audioRef.current !== null) {
      var position = audioRef.current.currentTime;
      var duration = audioRef.current.duration;
      var currentProgress = 100 / duration * position;
      setProgress(currentProgress);

      if (position === duration) {
        setIsPlaying(false);
      }
    }
  }, [audioRef]);
  React.useEffect(function () {
    if (audioRef.current !== null) {
      if (isPlaying) {
        audioRef.current.play();
        var interval = setInterval(updateProgress, progressUpdateInterval);
        return function () {
          return clearInterval(interval);
        };
      }

      audioRef.current.pause();
    }

    return function () {};
  }, [isPlaying, updateProgress]);
  var asset_url = og.asset_url,
      image_url = og.image_url,
      title = og.title,
      description = og.description,
      text = og.text;
  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__audio"
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__audio__wrapper"
  }, /*#__PURE__*/React__default['default'].createElement("audio", {
    ref: audioRef
  }, /*#__PURE__*/React__default['default'].createElement("source", {
    src: asset_url,
    type: "audio/mp3",
    "data-testid": "audio-source"
  })), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__audio__image"
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__audio__image--overlay"
  }, !isPlaying ? /*#__PURE__*/React__default['default'].createElement("div", {
    onClick: function onClick() {
      return setIsPlaying(true);
    },
    className: "str-chat__audio__image--button",
    "data-testid": "play-audio"
  }, /*#__PURE__*/React__default['default'].createElement("svg", {
    width: "40",
    height: "40",
    viewBox: "0 0 64 64",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React__default['default'].createElement("path", {
    d: "M32 58c14.36 0 26-11.64 26-26S46.36 6 32 6 6 17.64 6 32s11.64 26 26 26zm0 6C14.327 64 0 49.673 0 32 0 14.327 14.327 0 32 0c17.673 0 32 14.327 32 32 0 17.673-14.327 32-32 32zm13.237-28.412L26.135 45.625a3.27 3.27 0 0 1-4.426-1.4 3.319 3.319 0 0 1-.372-1.47L21 23.36c-.032-1.823 1.41-3.327 3.222-3.358a3.263 3.263 0 0 1 1.473.322l19.438 9.36a3.311 3.311 0 0 1 .103 5.905z",
    fillRule: "nonzero"
  }))) : /*#__PURE__*/React__default['default'].createElement("div", {
    onClick: function onClick() {
      return setIsPlaying(false);
    },
    className: "str-chat__audio__image--button",
    "data-testid": "pause-audio"
  }, /*#__PURE__*/React__default['default'].createElement("svg", {
    width: "40",
    height: "40",
    viewBox: "0 0 64 64",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React__default['default'].createElement("path", {
    d: "M32 58.215c14.478 0 26.215-11.737 26.215-26.215S46.478 5.785 32 5.785 5.785 17.522 5.785 32 17.522 58.215 32 58.215zM32 64C14.327 64 0 49.673 0 32 0 14.327 14.327 0 32 0c17.673 0 32 14.327 32 32 0 17.673-14.327 32-32 32zm-7.412-45.56h2.892a2.17 2.17 0 0 1 2.17 2.17v23.865a2.17 2.17 0 0 1-2.17 2.17h-2.892a2.17 2.17 0 0 1-2.17-2.17V20.61a2.17 2.17 0 0 1 2.17-2.17zm12.293 0h2.893a2.17 2.17 0 0 1 2.17 2.17v23.865a2.17 2.17 0 0 1-2.17 2.17h-2.893a2.17 2.17 0 0 1-2.17-2.17V20.61a2.17 2.17 0 0 1 2.17-2.17z",
    fillRule: "nonzero"
  })))), image_url && /*#__PURE__*/React__default['default'].createElement("img", {
    src: image_url,
    alt: "".concat(description)
  })), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__audio__content"
  }, /*#__PURE__*/React__default['default'].createElement("span", {
    className: "str-chat__audio__content--title"
  }, /*#__PURE__*/React__default['default'].createElement("strong", null, title)), /*#__PURE__*/React__default['default'].createElement("span", {
    className: "str-chat__audio__content--subtitle"
  }, text), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__audio__content--progress"
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    style: {
      width: "".concat(progress, "%")
    },
    "data-testid": "audio-progress"
  })))));
};

var DefaultAudio = /*#__PURE__*/React__default['default'].memo(Audio);

var giphyLogo = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAkCAYAAAB/up84AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABVhJREFUeNrsW6GS20AMdToGBgEGAQYBBgEBBQYFgQcP5hMO9jP6CYWFBwsPBgYUGBQEFAQUGAQYBBgYGHjmutt5O6NupbXXcZJrx5rJXGyv11o96Ukr52avr6/BJG9HZmMBMpvNYnxt1JzNZNoRAYFxM2Z8rT6FuueMcaH6s1KfhBn3U42r1Jg1rrfq+Bt5xgf1Z64+uQFQndNzLc1Ydfwg6F2p6wd1PVXfU+b6Gc9vHGuh8+jrsXVN61Sq64XggNw95tlH9XmP6y3W2OI+qvN3db6mN7/zBFAb8L2aNMJxRsDQC6jIuEyN039LnAvV8QJKRRijZUHmT8iiLpEFDHKJaB1TGN732WuAokEIDQCwhwGjsMEIMNgp6qY9JlsTgyXquCFG1d54IsbOsKAVPLDBcQJjUxB0RJwAltGntNQ46GhzqPnb0y0954RG/1iLQ7SRCkR+guiPtW6GFRg5gAlCrFvbJEZ0ngDAUn0/Y77fDCJFXuiB/AmGDC3PLg0YWLRW5CcJWWPglNxDKS6C59AcZBs/sYxbOQBqHHkuZYCsGCds4SQJDDx3RK3RjUb9EfMUcLQ57BHS64MAIYtYkvEt+d4wCzqr++ipkoTtkihOI2chREfA5KiC0GOAaMig05zoWJPjgMk39jxcPphDR0mSDrtq438g51iq8omQlEnYJfHoiAFxYQGko6bCPSmZ5wS+TRx0Zc5R4CtmHbEVJT+0p1uOYdNE1SMfOKNO0zXWEmItptApsfYa1LV0UZUPIHSCmlRYJhfokNWhX5IcsmIWbEAMCQWerWirhZK57MghNQyzgke3QuQWPUv4EAac9wCuJjmkNmvUNEwiobX+DgdEWoQGgNDPGtTWWhRRWONX5JlnePCZhP1JUCOzPN1O0C2MohP7xuiko8Qy9INUDBg2YPJMlzP8pRv0qYeUdu+Cy+RAKIYmtVqojM5kkS0DwkXlLuY0ICzgAEOlAd8fPe+rYJdppz61TiZ5G4AgcScWz05RcUtAkOwyJMtI4FzNt3suCWKfwLUhdqRC0yA/enB1CZ4vBZ2fhIptJ4x/5PYVavyzQ39N0V8ddnsQ+m3sfX02hjo3bIVJ7d5PhqojZxYdC3NEdv9oQMQWFFjHHqpLEsc9BZyF23c9cG0ZOJjUIN15V1mY8OOAhW0E77yWaP2eoO9VBFG/d6yX6/xuHT2z3AsQ5ImnjrZBF6XcUiKAEl0RlJzZ7ZtnbxmqSgRqfxmyD9k6wNDGzuExecB3Z1/ukBOjQH73MZbspChFp9nQ/EYY9+LaaIYOqlo7JjwISX+LcBwbjAOz2ZKS7BpOcq0o0R2HvZAbHpHPJGc+dm00paQuedmOA4O0WD5fyQ4V08Ip4ATxhYl8CCh76/0QLVyehlBVFyCpYJTcKmPjHoY8XNE2VQ8dbIkdr4Z95npBwcNVahKzNEMBSYSyz46iLm8sLunreG5O+xYTsaMUHYu6bMn79sRCT2+8l6SMV2cCT5e3UspBXbbd9n3nDIN/Q1KP3JDfWLcd8kZwCVX12hjeOlmOIMe+L6FGjJLC4QS5rz6hg/tThjZiU0Pr/g7D65/uCUafKgaUJu0lHjvox/XsjXA+GAOQUogIXV8/v7GoKOGJfYuHxvHjt7t3rEMHD2+E5PoR+5GCLCS+8g6Z2xgGt6anuwGC99MSKAl6RrfUs/ofje+b1PcjlJBlMMk4gKBUe77AqKVP/T1Jj30IQPmCTdkm6NeKb5BkJzCGdCA8XuFGZIOWCBEh/mwGiZ/rFZXk3xHEdkjHb6MknVOhypJe+Sac03XlL4fe3r81mH518q9GyCS3kV8CDADlsrVaJhTLAgAAAABJRU5ErkJggg==";

// @ts-check
/**
 * SafeAnchor - In all ways similar to a regular anchor tag.
 * The difference is that it sanitizes the href value and prevents XSS
 * @type {React.FC<React.AnchorHTMLAttributes<HTMLAnchorElement>>}
 */

var SafeAnchor = function SafeAnchor(_ref) {
  var href = _ref.href,
      children = _ref.children,
      target = _ref.target,
      className = _ref.className;
  if (!href) return null;
  var sanitized = sanitizeUrl.sanitizeUrl(href);
  return /*#__PURE__*/React__default['default'].createElement("a", {
    href: sanitized,
    target: target,
    className: className
  }, children);
};

var SafeAnchor$1 = /*#__PURE__*/React__default['default'].memo(SafeAnchor);

/**
 * Card - Simple Card Layout
 *
 * @example ../../docs/Card.md
 * @typedef {import('../types').CardProps} Props
 * @type React.FC<Props>
 */

var Card = function Card(_ref) {
  var title = _ref.title,
      title_link = _ref.title_link,
      og_scrape_url = _ref.og_scrape_url,
      image_url = _ref.image_url,
      thumb_url = _ref.thumb_url,
      text = _ref.text,
      type = _ref.type;

  var _useContext = React.useContext(TranslationContext),
      t = _useContext.t;

  var image = thumb_url || image_url;
  /** @type {(url?: string) => string | null} Typescript syntax */

  var trimUrl = function trimUrl(url) {
    if (url !== undefined && url !== null) {
      var _url$replace$split = url.replace(/^(?:https?:\/\/)?(?:www\.)?/i, '').split('/'),
          _url$replace$split2 = _slicedToArray__default['default'](_url$replace$split, 1),
          trimmedUrl = _url$replace$split2[0];

      return trimmedUrl;
    }

    return null;
  };

  if (!title && !title_link && !image) {
    return /*#__PURE__*/React__default['default'].createElement("div", {
      className: "str-chat__message-attachment-card str-chat__message-attachment-card--".concat(type)
    }, /*#__PURE__*/React__default['default'].createElement("div", {
      className: "str-chat__message-attachment-card--content"
    }, /*#__PURE__*/React__default['default'].createElement("div", {
      className: "str-chat__message-attachment-card--text"
    }, t('this content could not be displayed'))));
  }

  if (!title_link && !og_scrape_url) {
    return null;
  }

  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__message-attachment-card str-chat__message-attachment-card--".concat(type)
  }, image && /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__message-attachment-card--header"
  }, /*#__PURE__*/React__default['default'].createElement("img", {
    src: image,
    alt: image
  })), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__message-attachment-card--content"
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__message-attachment-card--flex"
  }, title && /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__message-attachment-card--title"
  }, title), text && /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__message-attachment-card--text"
  }, text), (title_link || og_scrape_url) && /*#__PURE__*/React__default['default'].createElement(SafeAnchor$1, {
    href: title_link || og_scrape_url,
    target: "_blank",
    rel: "noopener noreferrer",
    className: "str-chat__message-attachment-card--url"
  }, trimUrl(title_link || og_scrape_url))), type === 'giphy' && /*#__PURE__*/React__default['default'].createElement("img", {
    className: "str-chat__message-attachment-card__giphy-logo",
    "data-testid": "card-giphy",
    src: giphyLogo,
    alt: "giphy logo"
  })));
};

Card.propTypes = {
  /** Title returned by the OG scraper */
  title: PropTypes__default['default'].string,

  /** Link returned by the OG scraper */
  title_link: PropTypes__default['default'].string,

  /** The scraped url, used as a fallback if the OG-data doesn't include a link */
  og_scrape_url: PropTypes__default['default'].string,

  /** The url of the full sized image */
  image_url: PropTypes__default['default'].string,

  /** The url for thumbnail sized image */
  thumb_url: PropTypes__default['default'].string,

  /** Description returned by the OG scraper */
  text: PropTypes__default['default'].string
};
var DefaultCard = /*#__PURE__*/React__default['default'].memo(Card);

/** @type React.FC<import('../types').FileAttachmentProps> */

var FileAttachment = function FileAttachment(_ref) {
  var attachment = _ref.attachment;
  return /*#__PURE__*/React__default['default'].createElement("div", {
    "data-testid": "attachment-file",
    className: "str-chat__message-attachment-file--item"
  }, /*#__PURE__*/React__default['default'].createElement(reactFileUtils.FileIcon, {
    mimeType: attachment.mime_type,
    filename: attachment.title,
    big: true,
    size: 30
  }), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__message-attachment-file--item-text"
  }, /*#__PURE__*/React__default['default'].createElement(SafeAnchor$1, {
    href: attachment.asset_url,
    target: "_blank",
    download: true
  }, attachment.title), attachment.file_size && Number.isFinite(Number(attachment.file_size)) && /*#__PURE__*/React__default['default'].createElement("span", null, prettybytes__default['default'](attachment.file_size))));
};

var DefaultFile = /*#__PURE__*/React__default['default'].memo(FileAttachment);

// @ts-check
/**
 * Modal - Custom Image component used in modal
 * @type {React.FC<import('../types').ModalImageProps>}
 */

var ModalImage = function ModalImage(_ref) {
  var data = _ref.data;
  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__modal-image__wrapper",
    "data-testid": "modal-image"
  }, /*#__PURE__*/React__default['default'].createElement("img", {
    src: data.src,
    className: "str-chat__modal-image__image"
  }));
};

ModalImage.propTypes = {
  data: PropTypes__default['default'].shape({
    src: PropTypes__default['default'].string.isRequired
  }).isRequired
};

// @ts-check
/**
 * ImageModal - Small modal component
 * @type { React.FC<import('../types').ModalWrapperProps>}
 */

var ModalComponent = function ModalComponent(_ref) {
  var images = _ref.images,
      toggleModal = _ref.toggleModal,
      index = _ref.index,
      modalIsOpen = _ref.modalIsOpen;
  return /*#__PURE__*/React__default['default'].createElement(Carousel.ModalGateway, null, modalIsOpen ?
  /*#__PURE__*/
  // @ts-ignore
  React__default['default'].createElement(Carousel.Modal, {
    onClose: toggleModal
  }, /*#__PURE__*/React__default['default'].createElement(Carousel__default['default'], {
    views: images,
    currentIndex: index,
    components: {
      // @ts-ignore
      View: ModalImage
    }
  })) : null);
};

ModalComponent.propTypes = {
  images: PropTypes__default['default'].array.isRequired,
  toggleModal: PropTypes__default['default'].func.isRequired,
  index: PropTypes__default['default'].number,
  modalIsOpen: PropTypes__default['default'].bool.isRequired
};

/**
 * Gallery - displays up to 4 images in a simple responsive grid with a lightbox to view the images.
 * @example ../../docs/Gallery.md
 * @typedef {import('../types').GalleryProps} Props
 * @type React.FC<Props>
 */

var Gallery = function Gallery(_ref) {
  var images = _ref.images;

  var _useState = React.useState(0),
      _useState2 = _slicedToArray__default['default'](_useState, 2),
      index = _useState2[0],
      setIndex = _useState2[1];

  var _useState3 = React.useState(false),
      _useState4 = _slicedToArray__default['default'](_useState3, 2),
      modalOpen = _useState4[0],
      setModalOpen = _useState4[1];

  var _useContext = React.useContext(TranslationContext),
      t = _useContext.t;
  /**
   * @param {number} selectedIndex Index of image clicked
   */


  var toggleModal = function toggleModal(selectedIndex) {
    if (modalOpen) {
      setModalOpen(false);
    } else {
      setIndex(selectedIndex);
      setModalOpen(true);
    }
  };

  var formattedArray = React.useMemo(function () {
    return images.map(function (image) {
      return {
        src: image.image_url || image.thumb_url || '',
        source: image.image_url || image.thumb_url || ''
      };
    });
  }, [images]);
  var renderImages = images.slice(0, 3).map(function (image, i) {
    return /*#__PURE__*/React__default['default'].createElement("div", {
      "data-testid": "gallery-image",
      className: "str-chat__gallery-image",
      key: "gallery-image-".concat(i),
      onClick: function onClick() {
        return toggleModal(i);
      }
    }, /*#__PURE__*/React__default['default'].createElement("img", {
      src: image.image_url || image.thumb_url
    }));
  });
  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__gallery ".concat(images.length > 3 ? 'str-chat__gallery--square' : '')
  }, renderImages, images.length > 3 && /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__gallery-placeholder",
    style: {
      backgroundImage: "url(".concat(images[3].image_url, ")")
    },
    onClick: function onClick() {
      return toggleModal(3);
    }
  }, /*#__PURE__*/React__default['default'].createElement("p", null, t('{{ imageCount }} more', {
    imageCount: images.length - 3
  }))), /*#__PURE__*/React__default['default'].createElement(ModalComponent, {
    images: formattedArray,
    index: index // @ts-ignore
    ,
    toggleModal: toggleModal,
    modalIsOpen: modalOpen
  }));
};

Gallery.propTypes = {
  images:
  /** @type { PropTypes.Validator<import('../types').GalleryProps['images']> } */
  PropTypes__default['default'].arrayOf(PropTypes__default['default'].object.isRequired).isRequired
};
var Gallery$1 = /*#__PURE__*/React__default['default'].memo(Gallery);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
/**
 * Image - Small wrapper around an image tag, supports thumbnails
 *
 * @example ../../docs/Image.md
 * @extends {React.PureComponent<import('type').ImageProps>}
 */

var ImageComponent = /*#__PURE__*/function (_React$PureComponent) {
  _inherits__default['default'](ImageComponent, _React$PureComponent);

  var _super = _createSuper(ImageComponent);

  function ImageComponent() {
    var _this;

    _classCallCheck__default['default'](this, ImageComponent);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "state", {
      modalIsOpen: false,
      currentIndex: 0
    });

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "toggleModal", function () {
      _this.setState(function (state) {
        return {
          modalIsOpen: !state.modalIsOpen
        };
      });
    });

    return _this;
  }

  _createClass__default['default'](ImageComponent, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          image_url = _this$props.image_url,
          thumb_url = _this$props.thumb_url,
          fallback = _this$props.fallback;
      var imageSrc = sanitizeUrl.sanitizeUrl(image_url || thumb_url);
      var formattedArray = [{
        src: imageSrc
      }];
      return /*#__PURE__*/React__default['default'].createElement(React__default['default'].Fragment, null, /*#__PURE__*/React__default['default'].createElement("img", {
        className: "str-chat__message-attachment--img",
        onClick: this.toggleModal,
        src: imageSrc,
        alt: fallback,
        "data-testid": "image-test"
      }), /*#__PURE__*/React__default['default'].createElement(ModalComponent, {
        images: formattedArray,
        toggleModal: this.toggleModal,
        index: this.state.currentIndex,
        modalIsOpen: this.state.modalIsOpen
      }));
    }
  }]);

  return ImageComponent;
}(React__default['default'].PureComponent);

_defineProperty__default['default'](ImageComponent, "propTypes", {
  /** The full size image url */
  image_url: PropTypes__default['default'].string,

  /** The thumb url */
  thumb_url: PropTypes__default['default'].string,

  /** The text fallback for the image */
  fallback: PropTypes__default['default'].string
});

function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var SUPPORTED_VIDEO_FORMATS = ['video/mp4', 'video/ogg', 'video/webm', 'video/quicktime'];
/**
 * @typedef {import('../types').ExtendedAttachment} ExtendedAttachment
 * @typedef {Required<Pick<import('../types').InnerAttachmentUIComponentProps, 'Card' | 'File' | 'Gallery' |'Image' | 'Audio' | 'Media' | 'AttachmentActions'>>} DefaultProps
 * @typedef {Omit<import('../types').InnerAttachmentUIComponentProps, 'Card' | 'File' | 'Image'| 'Gallery' | 'Audio' | 'Media' | 'AttachmentActions'> & DefaultProps} AttachmentProps
 */

/**
 * @param {ExtendedAttachment} a
 */

var isGalleryAttachment = function isGalleryAttachment(a) {
  return a.type === 'gallery';
};
/**
 * @param {ExtendedAttachment} a
 */

var isImageAttachment = function isImageAttachment(a) {
  return a.type === 'image' && !a.title_link && !a.og_scrape_url;
};
/**
 * @param {ExtendedAttachment} a
 */

var isMediaAttachment = function isMediaAttachment(a) {
  return a.mime_type && SUPPORTED_VIDEO_FORMATS.indexOf(a.mime_type) !== -1 || a.type === 'video';
};
/**
 * @param {ExtendedAttachment} a
 */

var isAudioAttachment = function isAudioAttachment(a) {
  return a.type === 'audio';
};
/**
 * @param {ExtendedAttachment} a
 */

var isFileAttachment = function isFileAttachment(a) {
  return a.type === 'file' || a.mime_type && SUPPORTED_VIDEO_FORMATS.indexOf(a.mime_type) === -1 && a.type !== 'video';
};
/**
 * @param {React.ReactNode} children
 * @param {ExtendedAttachment} attachment
 * @param {string} componentType
 */

var renderAttachmentWithinContainer = function renderAttachmentWithinContainer(children, attachment, componentType) {
  var extra = attachment && attachment.actions && attachment.actions.length ? 'actions' : '';

  if (componentType === 'card' && !attachment.image_url && !attachment.thumb_url) {
    extra = 'no-image';
  }

  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__message-attachment str-chat__message-attachment--".concat(componentType, " str-chat__message-attachment--").concat(attachment.type, " str-chat__message-attachment--").concat(componentType, "--").concat(extra),
    key: "".concat(attachment === null || attachment === void 0 ? void 0 : attachment.id, "-").concat(attachment.type || 'none', " ")
  }, children);
};
/**
 * @param {AttachmentProps} props
 */

var renderAttachmentActions = function renderAttachmentActions(props) {
  var a = props.attachment,
      AttachmentActions = props.AttachmentActions,
      actionHandler = props.actionHandler;

  if (!a.actions || !a.actions.length) {
    return null;
  }

  return /*#__PURE__*/React__default['default'].createElement(AttachmentActions, _extends__default['default']({}, a, {
    id: a.id || '',
    actions: a.actions || [],
    text: a.text || '',
    key: "key-actions-".concat(a.id),
    actionHandler: actionHandler
  }));
};
/**
 * @param {AttachmentProps} props
 */

var renderGallery = function renderGallery(props) {
  var a = props.attachment,
      Gallery = props.Gallery;
  return renderAttachmentWithinContainer( /*#__PURE__*/React__default['default'].createElement(Gallery, {
    images: a.images || [],
    key: "gallery"
  }), a, 'gallery');
};
/**
 * @param {AttachmentProps} props
 */

var renderImage = function renderImage(props) {
  var a = props.attachment,
      Image = props.Image;

  if (a.actions && a.actions.length) {
    return renderAttachmentWithinContainer( /*#__PURE__*/React__default['default'].createElement("div", {
      className: "str-chat__attachment",
      key: "key-image-".concat(a.id)
    }, /*#__PURE__*/React__default['default'].createElement(Image, a), renderAttachmentActions(props)), a, 'image');
  }

  return renderAttachmentWithinContainer( /*#__PURE__*/React__default['default'].createElement(Image, _extends__default['default']({}, a, {
    key: "key-image-".concat(a.id)
  })), a, 'image');
};
/**
 * @param {AttachmentProps} props
 */

var renderCard = function renderCard(props) {
  var a = props.attachment,
      Card = props.Card;

  if (a.actions && a.actions.length) {
    return renderAttachmentWithinContainer( /*#__PURE__*/React__default['default'].createElement("div", {
      className: "str-chat__attachment",
      key: "key-image-".concat(a.id)
    }, /*#__PURE__*/React__default['default'].createElement(Card, _extends__default['default']({}, a, {
      key: "key-card-".concat(a.id)
    })), renderAttachmentActions(props)), a, 'card');
  }

  return renderAttachmentWithinContainer( /*#__PURE__*/React__default['default'].createElement(Card, _extends__default['default']({}, a, {
    key: "key-card-".concat(a.id)
  })), a, 'card');
};
/**
 * @param {AttachmentProps} props
 */

var renderFile = function renderFile(props) {
  var a = props.attachment,
      File = props.File;
  if (!a.asset_url) return null;
  return renderAttachmentWithinContainer( /*#__PURE__*/React__default['default'].createElement(File, {
    attachment: a,
    key: "key-file-".concat(a.id)
  }), a, 'file');
};
/**
 * @param {AttachmentProps} props
 */

var renderAudio = function renderAudio(props) {
  var a = props.attachment,
      Audio = props.Audio;
  return renderAttachmentWithinContainer( /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__attachment",
    key: "key-video-".concat(a.id)
  }, /*#__PURE__*/React__default['default'].createElement(Audio, {
    og: a
  })), a, 'audio');
};
/**
 * @param {AttachmentProps} props
 */

var renderMedia = function renderMedia(props) {
  var a = props.attachment,
      Media = props.Media;

  if (a.actions && a.actions.length) {
    return renderAttachmentWithinContainer( /*#__PURE__*/React__default['default'].createElement("div", {
      className: "str-chat__attachment str-chat__attachment-media",
      key: "key-video-".concat(a.id)
    }, /*#__PURE__*/React__default['default'].createElement("div", {
      className: "str-chat__player-wrapper"
    }, /*#__PURE__*/React__default['default'].createElement(Media, {
      className: "react-player",
      url: a.asset_url,
      width: "100%",
      height: "100%",
      controls: true
    })), renderAttachmentActions(props)), a, 'media');
  }

  return renderAttachmentWithinContainer( /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__player-wrapper",
    key: "key-video-".concat(a.id)
  }, /*#__PURE__*/React__default['default'].createElement(Media, {
    className: "react-player",
    url: a.asset_url,
    width: "100%",
    height: "100%",
    controls: true
  })), a, 'media');
};
/**
 * Attachment - The message attachment
 *
 * @example ../../docs/Attachment.md
 * @type { React.FC<import('../types').WrapperAttachmentUIComponentProps> }
 */

var Attachment = function Attachment(_ref) {
  var _gallery$images, _newAttachments;

  var attachments = _ref.attachments,
      _ref$Card = _ref.Card,
      Card = _ref$Card === void 0 ? DefaultCard : _ref$Card,
      _ref$Image = _ref.Image,
      Image = _ref$Image === void 0 ? ImageComponent : _ref$Image,
      _ref$Gallery = _ref.Gallery,
      Gallery = _ref$Gallery === void 0 ? Gallery$1 : _ref$Gallery,
      _ref$Audio = _ref.Audio,
      Audio = _ref$Audio === void 0 ? DefaultAudio : _ref$Audio,
      _ref$File = _ref.File,
      File = _ref$File === void 0 ? DefaultFile : _ref$File,
      _ref$Media = _ref.Media,
      Media = _ref$Media === void 0 ? DefaultMedia__default['default'] : _ref$Media,
      _ref$AttachmentAction = _ref.AttachmentActions,
      AttachmentActions = _ref$AttachmentAction === void 0 ? DefaultAttachmentActions : _ref$AttachmentAction,
      rest = _objectWithoutProperties__default['default'](_ref, ["attachments", "Card", "Image", "Gallery", "Audio", "File", "Media", "AttachmentActions"]);

  var gallery = {
    type: 'gallery',
    images: attachments.filter(
    /** @param {import('../types').ExtendedAttachment} a */
    function (a) {
      return a.type === 'image' && !(a.og_scrape_url || a.title_link);
    })
  };
  var newAttachments;

  if (((_gallery$images = gallery.images) === null || _gallery$images === void 0 ? void 0 : _gallery$images.length) >= 2) {
    newAttachments = [].concat(_toConsumableArray__default['default'](attachments.filter(
    /** @param {import('../types').ExtendedAttachment} a */
    function (a) {
      return !(a.type === 'image' && !(a.og_scrape_url || a.title_link));
    })), [gallery]);
  } else {
    newAttachments = attachments;
  }

  var propsWithDefault = _objectSpread$3({
    Card,
    Image,
    Audio,
    File,
    Media,
    Gallery,
    AttachmentActions,
    attachments: newAttachments
  }, rest);

  return /*#__PURE__*/React__default['default'].createElement(React__default['default'].Fragment, null, (_newAttachments = newAttachments) === null || _newAttachments === void 0 ? void 0 : _newAttachments.map(
  /** @param {any} attachment */
  function (attachment) {
    if (isGalleryAttachment(attachment)) {
      return renderGallery(_objectSpread$3(_objectSpread$3({}, propsWithDefault), {}, {
        attachment
      }));
    }

    if (isImageAttachment(attachment)) {
      return renderImage(_objectSpread$3(_objectSpread$3({}, propsWithDefault), {}, {
        attachment
      }));
    }

    if (isFileAttachment(attachment)) {
      return renderFile(_objectSpread$3(_objectSpread$3({}, propsWithDefault), {}, {
        attachment
      }));
    }

    if (isAudioAttachment(attachment)) {
      return renderAudio(_objectSpread$3(_objectSpread$3({}, propsWithDefault), {}, {
        attachment
      }));
    }

    if (isMediaAttachment(attachment)) {
      return renderMedia(_objectSpread$3(_objectSpread$3({}, propsWithDefault), {}, {
        attachment
      }));
    }

    return renderCard(_objectSpread$3(_objectSpread$3({}, propsWithDefault), {}, {
      attachment
    }));
  }));
};

Attachment.propTypes = {
  /**
   * The attachment to render
   * @see See [Attachment structure](https://getstream.io/chat/docs/#message_format)
   *
   *  */
  attachments:
  /** @type {PropTypes.Validator<ExtendedAttachment[]>} */
  PropTypes__default['default'].array.isRequired,

  /**
   *
   * @param name {string} Name of action
   * @param value {string} Value of action
   * @param event Dom event that triggered this handler
   */
  actionHandler: PropTypes__default['default'].func,

  /**
   * Custom UI component for card type attachment
   * Defaults to [Card](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Attachment/Card.js)
   */
  Card:
  /** @type {PropTypes.Validator<React.ComponentType<import('../types').CardProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * Custom UI component for file type attachment
   * Defaults to [File](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Attachment/File.js)
   */
  File:
  /** @type {PropTypes.Validator<React.ComponentType<import('../types').FileAttachmentProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * Custom UI component for attachment actions
   * Defaults to [AttachmentActions](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Attachment/AttachmentActions.js)
   */
  Gallery:
  /** @type {PropTypes.Validator<React.ComponentType<import('../types').GalleryProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * Custom UI component for image type attachment
   * Defaults to [Image](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Gallery/Image.js)
   */
  Image:
  /** @type {PropTypes.Validator<React.ComponentType<import('../types').ImageProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * Custom UI component for audio type attachment
   * Defaults to [Audio](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Attachment/Audio.js)
   */
  Audio:
  /** @type {PropTypes.Validator<React.ComponentType<import('../types').AudioProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * Custom UI component for media type attachment
   * Defaults to [ReactPlayer](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Attachment/ReactPlayer.js)
   */
  Media:
  /** @type {PropTypes.Validator<React.ComponentType<import('react-player').ReactPlayerProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * Custom UI component for attachment actions
   * Defaults to [AttachmentActions](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Attachment/AttachmentActions.js)
   */
  AttachmentActions:
  /** @type {PropTypes.Validator<React.ComponentType<import('../types').AttachmentActionsProps>>} */
  PropTypes__default['default'].elementType
};

/* eslint-disable */
var KEY_CODES = {
  ESC: 27,
  UP: 38,
  DOWN: 40,
  ENTER: 13,
  TAB: 9,
  SPACE: 32
}; // This is self-made key shortcuts manager, used for caching key strokes

var Listener = function Listener() {
  var _this = this;

  _classCallCheck__default['default'](this, Listener);

  _defineProperty__default['default'](this, "startListen", function () {
    if (!_this.refCount) {
      // prevent multiple listeners in case of multiple TextareaAutocomplete components on page
      document.addEventListener('keydown', _this.f);
    }

    _this.refCount++;
  });

  _defineProperty__default['default'](this, "stopListen", function () {
    _this.refCount--;

    if (!_this.refCount) {
      // prevent disable listening in case of multiple TextareaAutocomplete components on page
      document.removeEventListener('keydown', _this.f);
    }
  });

  _defineProperty__default['default'](this, "add", function (keyCodes, fn) {
    var keyCode = keyCodes;
    if (typeof keyCode !== 'object') keyCode = [keyCode];
    _this.listeners[_this.index] = {
      keyCode,
      fn
    };
    _this.index += 1;
    return _this.index;
  });

  _defineProperty__default['default'](this, "remove", function (id) {
    delete _this.listeners[id];
  });

  _defineProperty__default['default'](this, "removeAll", function () {
    _this.listeners = {};
    _this.index = 0;
  });

  this.index = 0;
  this.listeners = {};
  this.refCount = 0;

  this.f = function (e) {
    var code = e.keyCode || e.which;
    Object.values(_this.listeners).forEach(function (_ref) {
      var keyCode = _ref.keyCode,
          fn = _ref.fn;
      if (keyCode.includes(code)) fn(e);
    });
  };
};

var Listeners = new Listener();

var Item = /*#__PURE__*/React__default['default'].forwardRef(function (props, innerRef) {
  var className = props.className,
      Component = props.component,
      item = props.item,
      onClickHandler = props.onClickHandler,
      onSelectHandler = props.onSelectHandler,
      selected = props.selected,
      style = props.style;

  var selectItem = function selectItem() {
    return onSelectHandler(item);
  };

  return /*#__PURE__*/React__default['default'].createElement("li", {
    className: "rta__item ".concat(className || ''),
    style: style
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "rta__entity ".concat(selected ? 'rta__entity--selected' : ''),
    onClick: onClickHandler,
    onFocus: selectItem,
    onMouseEnter: selectItem,
    ref: innerRef,
    role: "button",
    tabIndex: 0
  }, /*#__PURE__*/React__default['default'].createElement(Component, {
    selected: selected,
    entity: item
  })));
});

var List = function List(props) {
  var className = props.className,
      component = props.component,
      dropdownScroll = props.dropdownScroll,
      getSelectedItem = props.getSelectedItem,
      getTextToReplace = props.getTextToReplace,
      itemClassName = props.itemClassName,
      itemStyle = props.itemStyle,
      onSelect = props.onSelect,
      style = props.style,
      propValue = props.value,
      values = props.values;

  var _useContext = React.useContext(TranslationContext),
      t = _useContext.t;

  var _useState = React.useState(undefined),
      _useState2 = _slicedToArray__default['default'](_useState, 2),
      selectedItem = _useState2[0],
      setSelectedItem = _useState2[1];

  var itemsRef = {};

  var isSelected = function isSelected(item) {
    return selectedItem === values.indexOf(item);
  };

  var getId = function getId(item) {
    var textToReplace = getTextToReplace(item);

    if (textToReplace.key) {
      return textToReplace.key;
    }

    if (typeof item === 'string' || !item.key) {
      return textToReplace.text;
    }

    return item.key;
  };

  var modifyText = function modifyText(value) {
    if (!value) return;
    onSelect(getTextToReplace(value));
    if (getSelectedItem) getSelectedItem(value);
  };

  var handleClick = function handleClick(e) {
    var _e$preventDefault;

    if (e) (_e$preventDefault = e.preventDefault) === null || _e$preventDefault === void 0 ? void 0 : _e$preventDefault.call(e);
    modifyText(values[selectedItem]);
  };

  var selectItem = function selectItem(item) {
    var keyboard = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    setSelectedItem(values.indexOf(item));
    if (keyboard) dropdownScroll(itemsRef[getId(item)]);
  };

  var handleKeyDown = React.useCallback(function (event) {
    if (event.which === KEY_CODES.UP) {
      setSelectedItem(function (prevSelected) {
        if (prevSelected === undefined) return 0;
        return prevSelected === 0 ? values.length - 1 : prevSelected - 1;
      });
    }

    if (event.which === KEY_CODES.DOWN) {
      setSelectedItem(function (prevSelected) {
        if (prevSelected === undefined) return 0;
        return prevSelected === values.length - 1 ? 0 : prevSelected + 1;
      });
    }

    if ((event.which === KEY_CODES.ENTER || event.which === KEY_CODES.TAB) && selectedItem !== undefined) {
      handleClick(event);
      return setSelectedItem(undefined);
    }

    return null;
  }, [selectedItem, values] // eslint-disable-line
  );
  React.useEffect(function () {
    document.addEventListener('keydown', handleKeyDown, false);
    return function () {
      return document.removeEventListener('keydown', handleKeyDown);
    };
  }, [handleKeyDown]);
  React.useEffect(function () {
    if (values !== null && values !== void 0 && values.length) selectItem(values[0]);
  }, [values]); // eslint-disable-line

  var renderHeader = function renderHeader(value) {
    if (value[0] === '/') {
      var html = "<strong>".concat(value.replace('/', ''), "</strong>");
      return "".concat(t('Commands matching'), " ").concat(html);
    }

    if (value[0] === ':') {
      var _html = "<strong>".concat(value.replace(':', ''), "</strong>");

      return "".concat(t('Emoji matching'), " ").concat(_html);
    }

    if (value[0] === '@') {
      var _html2 = "<strong>".concat(value.replace('@', ''), "</strong>");

      return "".concat(t('People matching'), " ").concat(_html2);
    }

    return null;
  };

  return /*#__PURE__*/React__default['default'].createElement("ul", {
    className: "rta__list ".concat(className || ''),
    style: style
  }, /*#__PURE__*/React__default['default'].createElement("li", {
    className: "rta__list-header",
    dangerouslySetInnerHTML: {
      __html: renderHeader(propValue)
    }
  }), values.map(function (item) {
    return /*#__PURE__*/React__default['default'].createElement(Item, {
      className: itemClassName,
      component: component,
      item: item,
      key: getId(item),
      onClickHandler: handleClick,
      onSelectHandler: selectItem,
      ref: function ref(_ref) {
        itemsRef[getId(item)] = _ref;
      },
      selected: isSelected(item),
      style: itemStyle
    });
  }));
};

var DEFAULT_CARET_POSITION = 'next';
function defaultScrollToItem(container, item) {
  if (!item) return;
  var itemHeight = parseInt(getComputedStyle(item).getPropertyValue('height'), 10);
  var containerHight = parseInt(getComputedStyle(container).getPropertyValue('height'), 10) - itemHeight;
  var actualScrollTop = container.scrollTop;
  var itemOffsetTop = item.offsetTop;

  if (itemOffsetTop < actualScrollTop + containerHight && actualScrollTop < itemOffsetTop) {
    return;
  } // eslint-disable-next-line


  container.scrollTop = itemOffsetTop;
}
var errorMessage = function errorMessage(message) {
  return console.error("RTA: dataProvider fails: ".concat(message, "\n    \nCheck the documentation or create issue if you think it's bug. https://github.com/webscopeio/react-textarea-autocomplete/issues"));
};
var triggerPropsCheck = function triggerPropsCheck(_ref) {
  var trigger = _ref.trigger;
  if (!trigger) return Error('Invalid prop trigger. Prop missing.');
  var triggers = Object.entries(trigger);

  for (var i = 0; i < triggers.length; i += 1) {
    var _triggers$i = _slicedToArray__default['default'](triggers[i], 2),
        triggerChar = _triggers$i[0],
        settings = _triggers$i[1];

    if (typeof triggerChar !== 'string' || triggerChar.length !== 1) {
      return Error('Invalid prop trigger. Keys of the object has to be string / one character.');
    } // $FlowFixMe


    var triggerSetting = settings;
    var component = triggerSetting.component,
        dataProvider = triggerSetting.dataProvider,
        output = triggerSetting.output,
        callback = triggerSetting.callback;

    if (!reactIs.isValidElementType(component)) {
      return Error('Invalid prop trigger: component should be defined.');
    }

    if (!dataProvider || typeof dataProvider !== 'function') {
      return Error('Invalid prop trigger: dataProvider should be defined.');
    }

    if (output && typeof output !== 'function') {
      return Error('Invalid prop trigger: output should be a function.');
    }

    if (callback && typeof callback !== 'function') {
      return Error('Invalid prop trigger: callback should be a function.');
    }
  }

  return null;
};

function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var ReactTextareaAutocomplete = /*#__PURE__*/function (_React$Component) {
  _inherits__default['default'](ReactTextareaAutocomplete, _React$Component);

  var _super = _createSuper$1(ReactTextareaAutocomplete);

  function ReactTextareaAutocomplete(_props) {
    var _this;

    _classCallCheck__default['default'](this, ReactTextareaAutocomplete);

    _this = _super.call(this, _props);

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "getSelectionPosition", function () {
      if (!_this.textareaRef) return null;
      return {
        selectionStart: _this.textareaRef.selectionStart,
        selectionEnd: _this.textareaRef.selectionEnd
      };
    });

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "getSelectedText", function () {
      if (!_this.textareaRef) return null;
      var _this$textareaRef = _this.textareaRef,
          selectionStart = _this$textareaRef.selectionStart,
          selectionEnd = _this$textareaRef.selectionEnd;
      if (selectionStart === selectionEnd) return null;
      return _this.state.value.substr(selectionStart, selectionEnd - selectionStart);
    });

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "setCaretPosition", function () {
      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      if (!_this.textareaRef) return;

      _this.textareaRef.focus();

      _this.textareaRef.setSelectionRange(position, position);
    });

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "getCaretPosition", function () {
      if (!_this.textareaRef) return 0;
      return _this.textareaRef.selectionEnd;
    });

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "_onEnter", function (event) {
      if (!_this.textareaRef) return;
      var trigger = _this.state.currentTrigger;

      var hasFocus = _this.textareaRef.matches(':focus'); // don't submit if the element has focus or the shift key is pressed


      if (!hasFocus || event.shiftKey === true) return;

      if (!trigger || !_this.state.data) {
        // trigger a submit
        _this._replaceWord();

        if (_this.textareaRef) {
          _this.textareaRef.selectionEnd = 0;
        }

        _this.props.handleSubmit(event);
      }
    });

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "_onSpace", function () {
      if (!_this.props.replaceWord || !_this.textareaRef) return; // don't change characters if the element doesn't have focus

      var hasFocus = _this.textareaRef.matches(':focus');

      if (!hasFocus) return;

      _this._replaceWord();
    });

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "_replaceWord", function () {
      var value = _this.state.value;
      var lastWordRegex = /([^\s]+)(\s*)$/;
      var match = lastWordRegex.exec(value.slice(0, _this.getCaretPosition()));
      var lastWord = match && match[1];
      if (!lastWord) return;
      var spaces = match[2];

      var newWord = _this.props.replaceWord(lastWord);

      if (newWord == null) return;
      var textBeforeWord = value.slice(0, _this.getCaretPosition() - match[0].length);
      var textAfterCaret = value.slice(_this.getCaretPosition(), -1);
      var newText = textBeforeWord + newWord + spaces + textAfterCaret;

      _this.setState({
        value: newText
      }, function () {
        // fire onChange event after successful selection
        var e = new CustomEvent__default['default']('change', {
          bubbles: true
        });

        _this.textareaRef.dispatchEvent(e);

        if (_this.props.onChange) _this.props.onChange(e);
      });
    });

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "_onSelect", function (newToken) {
      var onChange = _this.props.onChange;
      var _this$state = _this.state,
          currentTrigger = _this$state.currentTrigger,
          selectionEnd = _this$state.selectionEnd,
          textareaValue = _this$state.value;
      if (!currentTrigger) return;

      var computeCaretPosition = function computeCaretPosition(position, token, startToken) {
        switch (position) {
          case 'start':
            return startToken;

          case 'next':
          case 'end':
            return startToken + token.length;

          default:
            if (!Number.isInteger(position)) {
              throw new Error('RTA: caretPosition should be "start", "next", "end" or number.');
            }

            return position;
        }
      };

      var textToModify = textareaValue.slice(0, selectionEnd);
      var startOfTokenPosition = textToModify.search(
      /**
       * It's important to escape the currentTrigger char for chars like [, (,...
       */
      new RegExp("\\".concat(currentTrigger, "[^\\".concat(currentTrigger, '\\s', "]"), "*$"))); // we add space after emoji is selected if a caret position is next

      var newTokenString = newToken.caretPosition === 'next' ? "".concat(newToken.text, " ") : newToken.text;
      var newCaretPosition = computeCaretPosition(newToken.caretPosition, newTokenString, startOfTokenPosition);
      var modifiedText = textToModify.substring(0, startOfTokenPosition) + newTokenString; // set the new textarea value and after that set the caret back to its position

      _this.setState({
        value: textareaValue.replace(textToModify, modifiedText),
        dataLoading: false
      }, function () {
        // fire onChange event after successful selection
        var e = new CustomEvent__default['default']('change', {
          bubbles: true
        });

        _this.textareaRef.dispatchEvent(e);

        if (onChange) onChange(e);

        _this.setCaretPosition(newCaretPosition);
      });

      _this._closeAutocomplete();
    });

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "_getItemOnSelect", function () {
      var currentTrigger = _this.state.currentTrigger;

      var triggerSettings = _this._getCurrentTriggerSettings();

      if (!currentTrigger || !triggerSettings) return null;
      var callback = triggerSettings.callback;
      if (!callback) return null;
      return function (item) {
        if (typeof callback !== 'function') {
          throw new Error('Output functor is not defined! You have to define "output" function. https://github.com/webscopeio/react-textarea-autocomplete#trigger-type');
        }

        if (callback) {
          return callback(item, currentTrigger);
        }

        return null;
      };
    });

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "_getTextToReplace", function () {
      var _this$state2 = _this.state,
          actualToken = _this$state2.actualToken,
          currentTrigger = _this$state2.currentTrigger;

      var triggerSettings = _this._getCurrentTriggerSettings();

      if (!currentTrigger || !triggerSettings) return null;
      var output = triggerSettings.output;
      return function (item) {
        if (typeof item === 'object' && (!output || typeof output !== 'function')) {
          throw new Error('Output functor is not defined! If you are using items as object you have to define "output" function. https://github.com/webscopeio/react-textarea-autocomplete#trigger-type');
        }

        if (output) {
          var textToReplace = output(item, currentTrigger);

          if (!textToReplace || typeof textToReplace === 'number') {
            throw new Error("Output functor should return string or object in shape {text: string, caretPosition: string | number}.\nGot \"".concat(String(textToReplace), "\". Check the implementation for trigger \"").concat(currentTrigger, "\" and its token \"").concat(actualToken, "\"\n\nSee https://github.com/webscopeio/react-textarea-autocomplete#trigger-type for more informations.\n"));
          }

          if (typeof textToReplace === 'string') {
            return {
              text: textToReplace,
              caretPosition: DEFAULT_CARET_POSITION
            };
          }

          if (!textToReplace.text) {
            throw new Error("Output \"text\" is not defined! Object should has shape {text: string, caretPosition: string | number}. Check the implementation for trigger \"".concat(currentTrigger, "\" and its token \"").concat(actualToken, "\"\n"));
          }

          if (!textToReplace.caretPosition) {
            throw new Error("Output \"caretPosition\" is not defined! Object should has shape {text: string, caretPosition: string | number}. Check the implementation for trigger \"".concat(currentTrigger, "\" and its token \"").concat(actualToken, "\"\n"));
          }

          return textToReplace;
        }

        if (typeof item !== 'string') {
          throw new Error('Output item should be string\n');
        }

        return {
          caretPosition: DEFAULT_CARET_POSITION,
          text: "".concat(currentTrigger).concat(item).concat(currentTrigger)
        };
      };
    });

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "_getCurrentTriggerSettings", function () {
      var currentTrigger = _this.state.currentTrigger;
      if (!currentTrigger) return null;
      return _this.props.trigger[currentTrigger];
    });

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "_getValuesFromProvider", function () {
      var _this$state3 = _this.state,
          actualToken = _this$state3.actualToken,
          currentTrigger = _this$state3.currentTrigger;

      var triggerSettings = _this._getCurrentTriggerSettings();

      if (!currentTrigger || !triggerSettings) return;
      var dataProvider = triggerSettings.dataProvider,
          component = triggerSettings.component;

      if (typeof dataProvider !== 'function') {
        throw new Error('Trigger provider has to be a function!');
      }

      _this.setState({
        dataLoading: true
      }); // Modified: send the full text to support / style commands


      dataProvider(actualToken, _this.state.value, function (data, token) {
        // Make sure that the result is still relevant for current query
        if (token !== _this.state.actualToken) return;

        if (!Array.isArray(data)) {
          throw new Error('Trigger provider has to provide an array!');
        }

        if (!reactIs.isValidElementType(component)) {
          throw new Error('Component should be defined!');
        } // throw away if we resolved old trigger


        if (currentTrigger !== _this.state.currentTrigger) return; // if we haven't resolved any data let's close the autocomplete

        if (!data.length) {
          _this._closeAutocomplete();

          return;
        }

        _this.setState({
          component,
          data,
          dataLoading: false
        });
      });
    });

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "_getSuggestions", function () {
      var _this$state4 = _this.state,
          currentTrigger = _this$state4.currentTrigger,
          data = _this$state4.data;
      if (!currentTrigger || !data || data && !data.length) return null;
      return data;
    });

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "_createRegExp", function () {
      var trigger = _this.props.trigger; // negative lookahead to match only the trigger + the actual token = "bladhwd:adawd:word test" => ":word"
      // https://stackoverflow.com/a/8057827/2719917

      _this.tokenRegExp = new RegExp("([".concat(Object.keys(trigger).join(''), "])(?:(?!\\1)[^\\s])*$"));
    });

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "_closeAutocomplete", function () {
      _this.setState({
        currentTrigger: null,
        data: null,
        dataLoading: false,
        left: null,
        top: null
      });
    });

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "_cleanUpProps", function () {
      var props = _objectSpread$4({}, _this.props);

      var notSafe = ['additionalTextareaProps', 'className', 'closeOnClickOutside', 'containerClassName', 'containerStyle', 'disableMentions', 'dropdownClassName', 'dropdownStyle', 'grow', 'handleSubmit', 'innerRef', 'itemClassName', 'itemStyle', 'listClassName', 'listStyle', 'loaderClassName', 'loaderStyle', 'loadingComponent', 'minChar', 'movePopupAsYouType', 'onCaretPositionChange', 'onChange', 'ref', 'replaceWord', 'scrollToItem', 'SuggestionList', 'trigger', 'value']; // eslint-disable-next-line

      for (var prop in props) {
        if (notSafe.includes(prop)) delete props[prop];
      }

      return props;
    });

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "_isCommand", function (text) {
      if (text[0] !== '/') return false;
      var tokens = text.split(' ');
      if (tokens.length > 1) return false;
      return true;
    });

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "_changeHandler", function (e) {
      var _this$props = _this.props,
          minChar = _this$props.minChar,
          movePopupAsYouType = _this$props.movePopupAsYouType,
          onCaretPositionChange = _this$props.onCaretPositionChange,
          onChange = _this$props.onChange,
          trigger = _this$props.trigger;
      var _this$state5 = _this.state,
          left = _this$state5.left,
          top = _this$state5.top;
      var textarea = e.target;
      var selectionEnd = textarea.selectionEnd,
          selectionStart = textarea.selectionStart,
          value = textarea.value;

      if (onChange) {
        e.persist();
        onChange(e);
      }

      if (onCaretPositionChange) onCaretPositionChange(_this.getCaretPosition());

      _this.setState({
        value
      });

      var currentTrigger;
      var lastToken;

      if (_this._isCommand(value)) {
        currentTrigger = '/';
        lastToken = value;
      } else {
        var tokenMatch = value.slice(0, selectionEnd).match(/(?!^|\W)?[:@][^\s]*\s?[^\s]*$/g);
        lastToken = tokenMatch && tokenMatch[tokenMatch.length - 1].trim();
        currentTrigger = lastToken && Object.keys(trigger).find(function (a) {
          return a === lastToken[0];
        }) || null;
      }
      /*
       if we lost the trigger token or there is no following character we want to close
       the autocomplete
      */


      if (!lastToken || lastToken.length <= minChar) {
        _this._closeAutocomplete();

        return;
      }

      var actualToken = lastToken.slice(1); // if trigger is not configured step out from the function, otherwise proceed

      if (!currentTrigger) return;

      if (movePopupAsYouType || top === null && left === null || // if we have single char - trigger it means we want to re-position the autocomplete
      lastToken.length === 1) {
        var _getCaretCoordinates = getCaretCoordinates__default['default'](textarea, selectionEnd),
            newTop = _getCaretCoordinates.top,
            newLeft = _getCaretCoordinates.left;

        _this.setState({
          // make position relative to textarea
          left: newLeft,
          top: newTop - _this.textareaRef.scrollTop || 0
        });
      }

      _this.setState({
        actualToken,
        currentTrigger,
        selectionEnd,
        selectionStart
      }, function () {
        try {
          _this._getValuesFromProvider();
        } catch (err) {
          errorMessage(err.message);
        }
      });
    });

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "_selectHandler", function (e) {
      var _this$props2 = _this.props,
          onCaretPositionChange = _this$props2.onCaretPositionChange,
          onSelect = _this$props2.onSelect;
      if (onCaretPositionChange) onCaretPositionChange(_this.getCaretPosition());

      if (onSelect) {
        e.persist();
        onSelect(e);
      }
    });

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "_onClickAndBlurHandler", function (e) {
      var _this$props3 = _this.props,
          closeOnClickOutside = _this$props3.closeOnClickOutside,
          onBlur = _this$props3.onBlur; // If this is a click: e.target is the textarea, and e.relatedTarget is the thing
      // that was actually clicked. If we clicked inside the auto-select dropdown, then
      // that's not a blur, from the auto-select point of view, so then do nothing.

      var el = e.relatedTarget;

      if (_this.dropdownRef && el instanceof Node && _this.dropdownRef.contains(el)) {
        return;
      }

      if (closeOnClickOutside) _this._closeAutocomplete();

      if (onBlur) {
        e.persist();
        onBlur(e);
      }
    });

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "_onScrollHandler", function () {
      return _this._closeAutocomplete();
    });

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "_dropdownScroll", function (item) {
      var scrollToItem = _this.props.scrollToItem;
      if (!scrollToItem) return;

      if (scrollToItem === true) {
        defaultScrollToItem(_this.dropdownRef, item);
        return;
      }

      if (typeof scrollToItem !== 'function' || scrollToItem.length !== 2) {
        throw new Error('`scrollToItem` has to be boolean (true for default implementation) or function with two parameters: container, item.');
      }

      scrollToItem(_this.dropdownRef, item);
    });

    var _this$props4 = _this.props,
        loadingComponent = _this$props4.loadingComponent,
        _trigger = _this$props4.trigger,
        _value = _this$props4.value; // TODO: it would be better to have the parent control state...
    // if (value) this.state.value = value;

    _this._createRegExp();

    if (!loadingComponent) {
      throw new Error('RTA: loadingComponent is not defined');
    }

    if (!_trigger) {
      throw new Error('RTA: trigger is not defined');
    }

    _this.state = {
      actualToken: '',
      component: null,
      currentTrigger: null,
      data: null,
      dataLoading: false,
      left: null,
      listenerIndex: 0,
      selectionEnd: 0,
      selectionStart: 0,
      value: _value || '',
      top: null
    };
    return _this;
  }

  _createClass__default['default'](ReactTextareaAutocomplete, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      Listeners.add(KEY_CODES.ESC, function () {
        return _this2._closeAutocomplete();
      });
      Listeners.add(KEY_CODES.SPACE, function () {
        return _this2._onSpace();
      });
      var listenerIndex = Listeners.add(KEY_CODES.ENTER, function (e) {
        return _this2._onEnter(e);
      });
      this.setState({
        listenerIndex
      });
      Listeners.startListen();
    }
  }, {
    key: "UNSAFE_componentWillReceiveProps",
    value: function UNSAFE_componentWillReceiveProps(nextProps) {
      this._update(nextProps);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      Listeners.stopListen();
      Listeners.remove(this.state.listenerIndex);
    }
  }, {
    key: "_update",
    // TODO: This is an anti pattern in react, should come up with a better way
    value: function _update(_ref) {
      var value = _ref.value,
          trigger = _ref.trigger;
      var oldValue = this.state.value;
      var oldTrigger = this.props.trigger;
      if (value !== oldValue || !oldValue) this.setState({
        value
      });
      /**
       * check if trigger chars are changed, if so, change the regexp accordingly
       */

      if (Object.keys(trigger).join('') !== Object.keys(oldTrigger).join('')) {
        this._createRegExp();
      }
    }
    /**
     * Close autocomplete, also clean up trigger (to avoid slow promises)
     */

  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      var _this$props5 = this.props,
          className = _this$props5.className,
          containerClassName = _this$props5.containerClassName,
          containerStyle = _this$props5.containerStyle,
          disableMentions = _this$props5.disableMentions,
          dropdownClassName = _this$props5.dropdownClassName,
          dropdownStyle = _this$props5.dropdownStyle,
          itemClassName = _this$props5.itemClassName,
          itemStyle = _this$props5.itemStyle,
          listClassName = _this$props5.listClassName,
          style = _this$props5.style,
          _this$props5$Suggesti = _this$props5.SuggestionList,
          SuggestionList = _this$props5$Suggesti === void 0 ? List : _this$props5$Suggesti;
      var maxRows = this.props.maxRows;
      var _this$state6 = this.state,
          component = _this$state6.component,
          currentTrigger = _this$state6.currentTrigger,
          dataLoading = _this$state6.dataLoading,
          value = _this$state6.value;

      var selectedItem = this._getItemOnSelect();

      var suggestionData = this._getSuggestions();

      var textToReplace = this._getTextToReplace();

      var SuggestionListContainer = function SuggestionListContainer() {
        if ((dataLoading || suggestionData) && currentTrigger && !(disableMentions && currentTrigger === '@')) {
          return /*#__PURE__*/React__default['default'].createElement("div", {
            className: "rta__autocomplete ".concat(dropdownClassName || ''),
            ref: function ref(_ref2) {
              _this3.dropdownRef = _ref2;
            },
            style: dropdownStyle
          }, component && suggestionData && textToReplace && /*#__PURE__*/React__default['default'].createElement(SuggestionList, {
            className: listClassName,
            component: component,
            dropdownScroll: _this3._dropdownScroll,
            getSelectedItem: selectedItem,
            getTextToReplace: textToReplace,
            itemClassName: itemClassName,
            itemStyle: itemStyle,
            onSelect: _this3._onSelect,
            value: value,
            values: suggestionData
          }));
        }

        return null;
      };

      if (!this.props.grow) maxRows = 1;
      return /*#__PURE__*/React__default['default'].createElement("div", {
        className: "rta ".concat(dataLoading === true ? 'rta--loading' : '', " ").concat(containerClassName || ''),
        style: containerStyle
      }, /*#__PURE__*/React__default['default'].createElement(SuggestionListContainer, null), /*#__PURE__*/React__default['default'].createElement(Textarea__default['default'], _extends__default['default']({}, this._cleanUpProps(), {
        className: "rta__textarea ".concat(className || ''),
        maxRows: maxRows,
        onBlur: this._onClickAndBlurHandler,
        onChange: this._changeHandler,
        onClick: this._onClickAndBlurHandler,
        onFocus: this.props.onFocus,
        onScroll: this._onScrollHandler,
        onSelect: this._selectHandler,
        ref: function ref(_ref3) {
          if (_this3.props.innerRef) _this3.props.innerRef(_ref3);
          _this3.textareaRef = _ref3;
        },
        style: style,
        value: value
      }, this.props.additionalTextareaProps)));
    }
  }]);

  return ReactTextareaAutocomplete;
}(React__default['default'].Component);

_defineProperty__default['default'](ReactTextareaAutocomplete, "defaultProps", {
  closeOnClickOutside: true,
  maxRows: 10,
  minChar: 1,
  movePopupAsYouType: false,
  scrollToItem: true,
  value: ''
});

ReactTextareaAutocomplete.propTypes = {
  className: PropTypes__default['default'].string,
  closeOnClickOutside: PropTypes__default['default'].bool,
  containerClassName: PropTypes__default['default'].string,
  containerStyle: PropTypes__default['default'].object,
  disableMentions: PropTypes__default['default'].bool,
  dropdownClassName: PropTypes__default['default'].string,
  dropdownStyle: PropTypes__default['default'].object,
  itemClassName: PropTypes__default['default'].string,
  itemStyle: PropTypes__default['default'].object,
  listClassName: PropTypes__default['default'].string,
  listStyle: PropTypes__default['default'].object,
  loaderClassName: PropTypes__default['default'].string,
  loaderStyle: PropTypes__default['default'].object,
  loadingComponent: PropTypes__default['default'].elementType,
  minChar: PropTypes__default['default'].number,
  onBlur: PropTypes__default['default'].func,
  onCaretPositionChange: PropTypes__default['default'].func,
  onChange: PropTypes__default['default'].func,
  onSelect: PropTypes__default['default'].func,
  style: PropTypes__default['default'].object,
  SuggestionList: PropTypes__default['default'].elementType,
  trigger: triggerPropsCheck,
  value: PropTypes__default['default'].string
};

/**
 * Avatar - A round avatar image with fallback to username's first letter
 *
 * @example ../../docs/Avatar.md
 * @typedef {import('../types').AvatarProps} Props
 * @type { React.FC<Props>}
 */

var Avatar = function Avatar(_ref) {
  var _ref$size = _ref.size,
      size = _ref$size === void 0 ? 32 : _ref$size,
      name = _ref.name,
      _ref$shape = _ref.shape,
      shape = _ref$shape === void 0 ? 'circle' : _ref$shape,
      image = _ref.image,
      _ref$onClick = _ref.onClick,
      onClick = _ref$onClick === void 0 ? function () {} : _ref$onClick,
      _ref$onMouseOver = _ref.onMouseOver,
      onMouseOver = _ref$onMouseOver === void 0 ? function () {} : _ref$onMouseOver;

  var _useState = React.useState(false),
      _useState2 = _slicedToArray__default['default'](_useState, 2),
      loaded = _useState2[0],
      setLoaded = _useState2[1];

  var _useState3 = React.useState(false),
      _useState4 = _slicedToArray__default['default'](_useState3, 2),
      error = _useState4[0],
      setError = _useState4[1];

  React.useEffect(function () {
    setLoaded(false);
    setError(false);
  }, [image]);
  var initials = (name || '').charAt(0);
  return /*#__PURE__*/React__default['default'].createElement("div", {
    "data-testid": "avatar",
    className: "str-chat__avatar str-chat__avatar--".concat(shape),
    title: name,
    style: {
      width: "".concat(size, "px"),
      height: "".concat(size, "px"),
      flexBasis: "".concat(size, "px"),
      lineHeight: "".concat(size, "px"),
      fontSize: "".concat(size / 2, "px")
    },
    onClick: onClick,
    onMouseOver: onMouseOver
  }, image && !error ? /*#__PURE__*/React__default['default'].createElement("img", {
    "data-testid": "avatar-img",
    src: image,
    alt: initials,
    className: "str-chat__avatar-image".concat(loaded ? ' str-chat__avatar-image--loaded' : ''),
    style: {
      width: "".concat(size, "px"),
      height: "".concat(size, "px"),
      flexBasis: "".concat(size, "px"),
      objectFit: 'cover'
    },
    onLoad: function onLoad() {
      return setLoaded(true);
    },
    onError: function onError() {
      return setError(true);
    }
  }) : /*#__PURE__*/React__default['default'].createElement("div", {
    "data-testid": "avatar-fallback",
    className: "str-chat__avatar-fallback"
  }, initials));
};

Avatar.propTypes = {
  /** image url */
  image: PropTypes__default['default'].string,

  /** name of the picture, used for title tag fallback */
  name: PropTypes__default['default'].string,

  /** shape of the avatar, circle, rounded or square */
  shape: PropTypes__default['default'].oneOf(['circle', 'rounded', 'square']),

  /** size in pixels */
  size: PropTypes__default['default'].number,

  /** click event handler */
  onClick: PropTypes__default['default'].func,

  /** mouseOver event handler */
  onMouseOver: PropTypes__default['default'].func
};

/** @type {React.FC<import('../types').ChannelPreviewUIComponentProps>} */

var ChannelPreviewCountOnly = function ChannelPreviewCountOnly(_ref) {
  var channel = _ref.channel,
      setActiveChannel = _ref.setActiveChannel,
      watchers = _ref.watchers,
      unread = _ref.unread,
      displayTitle = _ref.displayTitle;
  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: unread >= 1 ? 'unread' : ''
  }, /*#__PURE__*/React__default['default'].createElement("button", {
    onClick: function onClick() {
      return setActiveChannel(channel, watchers);
    }
  }, ' ', displayTitle, " ", /*#__PURE__*/React__default['default'].createElement("span", null, unread)));
};

ChannelPreviewCountOnly.propTypes = {
  /** **Available from [chat context](https://getstream.github.io/stream-chat-react/#chat)** */
  channel: PropTypes__default['default'].object.isRequired,

  /** @see See [chat context](https://getstream.github.io/stream-chat-react/#chat) for doc */
  setActiveChannel: PropTypes__default['default'].func.isRequired,

  /**
   * Object containing watcher parameters
   * @see See [Pagination documentation](https://getstream.io/chat/docs/#channel_pagination) for a list of available fields for sort.
   * */
  watchers:
  /** @type {PropTypes.Validator<{ limit?: number | undefined; offset?: number | undefined} | null | undefined> | undefined} */
  PropTypes__default['default'].object,

  /** Number of unread messages */
  unread: PropTypes__default['default'].number,

  /** Title of channel to display */
  displayTitle: PropTypes__default['default'].string
};
var ChannelPreviewCountOnly$1 = /*#__PURE__*/React__default['default'].memo(ChannelPreviewCountOnly);

var getLatestMessagePreview = function getLatestMessagePreview(channel, t) {
  var latestMessage = channel.state.messages[channel.state.messages.length - 1];

  if (!latestMessage) {
    return t('Nothing yet...');
  }

  if (latestMessage.deleted_at) {
    return t('Message deleted');
  }

  if (latestMessage.text) {
    return latestMessage.text;
  }

  if (latestMessage.command) {
    return "/".concat(latestMessage.command);
  }

  if (latestMessage.attachments.length) {
    return t('üèô Attachment...');
  }

  return t('Empty message...');
};
var getDisplayTitle = function getDisplayTitle(channel, currentUser) {
  var title = channel.data.name;
  var members = Object.values(channel.state.members);

  if (!title && members.length === 2) {
    var otherMember = members.find(function (m) {
      return m.user.id !== currentUser.id;
    });
    title = otherMember.user.name;
  }

  return title;
};
var getDisplayImage = function getDisplayImage(channel, currentUser) {
  var image = channel.data.image;
  var members = Object.values(channel.state.members);

  if (!image && members.length === 2) {
    var otherMember = members.find(function (m) {
      return m.user.id !== currentUser.id;
    });
    image = otherMember.user.image;
  }

  return image;
};

/**
 * @type {React.FC<import('../types').ChannelPreviewProps>}
 */

var ChannelPreview = function ChannelPreview(props) {
  var channel = props.channel,
      _props$Preview = props.Preview,
      Preview = _props$Preview === void 0 ? ChannelPreviewCountOnly$1 : _props$Preview;

  var _useContext = React.useContext(ChatContext),
      client = _useContext.client,
      activeChannel = _useContext.channel,
      setActiveChannel = _useContext.setActiveChannel;

  var _useContext2 = React.useContext(TranslationContext),
      t = _useContext2.t;

  var _useState = React.useState(
  /** @type {import('stream-chat').MessageResponse | undefined} */
  undefined),
      _useState2 = _slicedToArray__default['default'](_useState, 2),
      lastMessage = _useState2[0],
      setLastMessage = _useState2[1];

  var _useState3 = React.useState(0),
      _useState4 = _slicedToArray__default['default'](_useState3, 2),
      unread = _useState4[0],
      setUnread = _useState4[1];

  var isActive = (activeChannel === null || activeChannel === void 0 ? void 0 : activeChannel.cid) === channel.cid;

  var _channel$muteStatus = channel.muteStatus(),
      muted = _channel$muteStatus.muted;

  React.useEffect(function () {
    if (isActive || muted) {
      setUnread(0);
    } else {
      setUnread(channel.countUnread());
    }
  }, [channel, isActive, muted]);
  React.useEffect(function () {
    /** @type {(event: import('stream-chat').Event) => void} */
    var handleEvent = function handleEvent(event) {
      setLastMessage(event.message);

      if (!isActive && !muted) {
        setUnread(channel.countUnread());
      } else {
        setUnread(0);
      }
    };

    channel.on('message.new', handleEvent);
    channel.on('message.updated', handleEvent);
    channel.on('message.deleted', handleEvent);
    return function () {
      channel.off('message.new', handleEvent);
      channel.off('message.updated', handleEvent);
      channel.off('message.deleted', handleEvent);
    };
  }, [channel, isActive, muted]);
  if (!Preview) return null;
  return /*#__PURE__*/React__default['default'].createElement(Preview, _extends__default['default']({}, props, {
    setActiveChannel: setActiveChannel,
    lastMessage: lastMessage,
    unread: unread,
    latestMessage: getLatestMessagePreview(channel, t),
    displayTitle: getDisplayTitle(channel, client.user),
    displayImage: getDisplayImage(channel, client.user),
    active: isActive
  }));
};

ChannelPreview.propTypes = {
  /** **Available from [chat context](https://getstream.github.io/stream-chat-react/#chat)** */
  channel:
  /** @type {PropTypes.Validator<import('stream-chat').Channel>} */
  PropTypes__default['default'].object.isRequired,

  /** Current selected channel object */
  activeChannel:
  /** @type {PropTypes.Validator<import('stream-chat').Channel | null | undefined>} */
  PropTypes__default['default'].object,

  /**
   * Custom UI component to display user avatar
   *
   * Defaults to and accepts same props as: [Avatar](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Avatar/Avatar.js)
   * */
  Avatar:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').AvatarProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * Available built-in options (also accepts the same props as):
   *
   * 1. [ChannelPreviewCompact](https://getstream.github.io/stream-chat-react/#ChannelPreviewCompact) (default)
   * 2. [ChannelPreviewLastMessage](https://getstream.github.io/stream-chat-react/#ChannelPreviewLastMessage)
   * 3. [ChannelPreviewMessanger](https://getstream.github.io/stream-chat-react/#ChannelPreviewMessanger)
   *
   * The Preview to use, defaults to ChannelPreviewLastMessage
   * */
  Preview:
  /** @type {PropTypes.Validator<React.ComponentType<import('../types').ChannelPreviewUIComponentProps>>} */
  PropTypes__default['default'].elementType
};

// @ts-check
/**
 *
 * @example ../../docs/ChannelPreviewCompact.md
 * @type {import('../types').ChannelPreviewCompact}
 */

var ChannelPreviewCompact = function ChannelPreviewCompact(props) {
  var _props$Avatar = props.Avatar,
      Avatar$1 = _props$Avatar === void 0 ? Avatar : _props$Avatar;
  /**
   * @type {React.MutableRefObject<HTMLButtonElement | null>} Typescript syntax
   */

  var channelPreviewButton = React.useRef(null);
  var unreadClass = props.unread_count >= 1 ? 'str-chat__channel-preview-compact--unread' : '';
  var activeClass = props.active ? 'str-chat__channel-preview-compact--active' : '';

  var onSelectChannel = function onSelectChannel() {
    props.setActiveChannel(props.channel, props.watchers);

    if (channelPreviewButton !== null && channelPreviewButton !== void 0 && channelPreviewButton.current) {
      channelPreviewButton.current.blur();
    }
  };

  return /*#__PURE__*/React__default['default'].createElement("button", {
    "data-testid": "channel-preview-button",
    onClick: onSelectChannel,
    ref: channelPreviewButton,
    className: "str-chat__channel-preview-compact ".concat(unreadClass, " ").concat(activeClass)
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__channel-preview-compact--left"
  }, /*#__PURE__*/React__default['default'].createElement(Avatar$1, {
    image: props.displayImage,
    name: props.displayTitle,
    size: 20
  })), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__channel-preview-compact--right"
  }, props.displayTitle));
};

ChannelPreviewCompact.propTypes = {
  /** **Available from [chat context](https://getstream.github.io/stream-chat-react/#chat)** */
  channel: PropTypes__default['default'].instanceOf(streamChat.Channel).isRequired,

  /** Current selected channel object */
  activeChannel: PropTypes__default['default'].instanceOf(streamChat.Channel),

  /**
   * Custom UI component to display user avatar
   *
   * Defaults to and accepts same props as: [Avatar](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Avatar/Avatar.js)
   * */
  Avatar:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').AvatarProps>>} */
  PropTypes__default['default'].elementType,

  /** Setter for selected channel */
  setActiveChannel: PropTypes__default['default'].func.isRequired,

  /**
   * Object containing watcher parameters
   * @see See [Pagination documentation](https://getstream.io/chat/docs/#channel_pagination) for a list of available fields for sort.
   * */
  watchers:
  /** @type {PropTypes.Validator<{ limit?: number | undefined; offset?: number | undefined} | null | undefined> | undefined} */
  PropTypes__default['default'].object,

  /** Number of unread messages */
  unread: PropTypes__default['default'].number,

  /** If channel of component is active (selected) channel */
  active: PropTypes__default['default'].bool,

  /** Latest message's text. */
  latestMessage: PropTypes__default['default'].string,

  /** Title of channel to display */
  displayTitle: PropTypes__default['default'].string,

  /** Image of channel to display */
  displayImage: PropTypes__default['default'].string
};
var ChannelPreviewCompact$1 = /*#__PURE__*/React__default['default'].memo(ChannelPreviewCompact);

// @ts-check
/**
 * Used as preview component for channel item in [ChannelList](#channellist) component.
 *
 * @example ../../docs/ChannelPreviewLastMessage.md
 * @type {import('../types').ChannelPreviewLastMessage}
 */

var ChannelPreviewLastMessage = function ChannelPreviewLastMessage(props) {
  var _props$Avatar = props.Avatar,
      Avatar$1 = _props$Avatar === void 0 ? Avatar : _props$Avatar;
  /** @type {React.MutableRefObject<HTMLButtonElement | null>} Typescript syntax */

  var channelPreviewButton = React.useRef(null);

  var onSelectChannel = function onSelectChannel() {
    props.setActiveChannel(props.channel, props.watchers);

    if (channelPreviewButton !== null && channelPreviewButton !== void 0 && channelPreviewButton.current) {
      channelPreviewButton.current.blur();
    }
  };

  var unreadClass = props.unread >= 1 ? 'str-chat__channel-preview--unread' : '';
  var activeClass = props.active ? 'str-chat__channel-preview--active' : '';
  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__channel-preview ".concat(unreadClass, " ").concat(activeClass)
  }, /*#__PURE__*/React__default['default'].createElement("button", {
    onClick: onSelectChannel,
    ref: channelPreviewButton,
    "data-testid": "channel-preview-button"
  }, props.unread >= 1 && /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__channel-preview--dot"
  }), /*#__PURE__*/React__default['default'].createElement(Avatar$1, {
    image: props.displayImage,
    name: props.displayTitle
  }), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__channel-preview-info"
  }, /*#__PURE__*/React__default['default'].createElement("span", {
    className: "str-chat__channel-preview-title"
  }, props.displayTitle), /*#__PURE__*/React__default['default'].createElement("span", {
    className: "str-chat__channel-preview-last-message"
  }, truncate(props.latestMessage, props.latestMessageLength)), props.unread >= 1 && /*#__PURE__*/React__default['default'].createElement("span", {
    className: "str-chat__channel-preview-unread-count"
  }, props.unread))));
};

ChannelPreviewLastMessage.propTypes = {
  /** **Available from [chat context](https://getstream.github.io/stream-chat-react/#chat)** */
  channel: PropTypes__default['default'].object.isRequired,

  /** Current selected channel object */
  activeChannel: PropTypes__default['default'].object,

  /**
   * Custom UI component to display user avatar
   *
   * Defaults to and accepts same props as: [Avatar](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Avatar/Avatar.js)
   * */
  Avatar:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').AvatarProps>>} */
  PropTypes__default['default'].elementType,

  /** Setter for selected channel */
  setActiveChannel: PropTypes__default['default'].func.isRequired,

  /**
   * Object containing watcher parameters
   * @see See [Pagination documentation](https://getstream.io/chat/docs/#channel_pagination) for a list of available fields for sort.
   * */
  watchers: PropTypes__default['default'].object,

  /** Number of unread messages */
  unread: PropTypes__default['default'].number,

  /** If channel of component is active (selected) channel */
  active: PropTypes__default['default'].bool,

  /** Latest message's text. */
  latestMessage: PropTypes__default['default'].string,

  /** Length of latest message to truncate at */
  latestMessageLength: PropTypes__default['default'].number,

  /** Title of channel to display */
  displayTitle: PropTypes__default['default'].string,

  /** Image of channel to display */
  displayImage: PropTypes__default['default'].string
};
ChannelPreviewLastMessage.defaultProps = {
  latestMessageLength: 20
};
var ChannelPreviewLastMessage$1 = /*#__PURE__*/React__default['default'].memo(ChannelPreviewLastMessage);

// @ts-check
/**
 * Used as preview component for channel item in [ChannelList](#channellist) component.
 * Its best suited for messenger type chat.
 *
 * @example ../../docs/ChannelPreviewMessenger.md
 * @type {import('../types').ChannelPreviewMessenger}
 */

var ChannelPreviewMessenger = function ChannelPreviewMessenger(props) {
  var _props$Avatar = props.Avatar,
      Avatar$1 = _props$Avatar === void 0 ? Avatar : _props$Avatar;
  /** @type {React.MutableRefObject<HTMLButtonElement | null>} Typescript syntax */

  var channelPreviewButton = React.useRef(null);
  var unreadClass = props.unread >= 1 ? 'str-chat__channel-preview-messenger--unread' : '';
  var activeClass = props.active ? 'str-chat__channel-preview-messenger--active' : '';

  var onSelectChannel = function onSelectChannel() {
    props.setActiveChannel(props.channel, props.watchers);

    if (channelPreviewButton !== null && channelPreviewButton !== void 0 && channelPreviewButton.current) {
      channelPreviewButton.current.blur();
    }
  };

  return /*#__PURE__*/React__default['default'].createElement("button", {
    onClick: onSelectChannel,
    ref: channelPreviewButton,
    className: "str-chat__channel-preview-messenger ".concat(unreadClass, " ").concat(activeClass),
    "data-testid": "channel-preview-button"
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__channel-preview-messenger--left"
  }, /*#__PURE__*/React__default['default'].createElement(Avatar$1, {
    image: props.displayImage,
    name: props.displayTitle,
    size: 40
  })), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__channel-preview-messenger--right"
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__channel-preview-messenger--name"
  }, /*#__PURE__*/React__default['default'].createElement("span", null, props.displayTitle)), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__channel-preview-messenger--last-message"
  }, truncate(props.latestMessage, props.latestMessageLength))));
};

ChannelPreviewMessenger.propTypes = {
  /** **Available from [chat context](https://getstream.github.io/stream-chat-react/#chat)** */
  channel: PropTypes__default['default'].object.isRequired,

  /** Current selected channel object */
  activeChannel: PropTypes__default['default'].object,

  /**
   * Custom UI component to display user avatar
   *
   * Defaults to and accepts same props as: [Avatar](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Avatar/Avatar.js)
   * */
  Avatar:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').AvatarProps>>} */
  PropTypes__default['default'].elementType,

  /** Setter for selected channel */
  setActiveChannel: PropTypes__default['default'].func.isRequired,

  /**
   * Object containing watcher parameters
   * @see See [Pagination documentation](https://getstream.io/chat/docs/#channel_pagination) for a list of available fields for sort.
   * */
  watchers: PropTypes__default['default'].object,

  /** Number of unread messages */
  unread: PropTypes__default['default'].number,

  /** If channel of component is active (selected) channel */
  active: PropTypes__default['default'].bool,

  /** Latest message's text. */
  latestMessage: PropTypes__default['default'].string,

  /** Length of latest message to truncate at */
  latestMessageLength: PropTypes__default['default'].number,

  /** Title of channel to display */
  displayTitle: PropTypes__default['default'].string,

  /** Image of channel to display */
  displayImage: PropTypes__default['default'].string
};
ChannelPreviewMessenger.defaultProps = {
  latestMessageLength: 14
};
var ChannelPreviewMessenger$1 = /*#__PURE__*/React__default['default'].memo(ChannelPreviewMessenger);

// @ts-check
var ReplyIcon = function ReplyIcon() {
  return /*#__PURE__*/React__default['default'].createElement("svg", {
    width: "18",
    height: "15",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React__default['default'].createElement("path", {
    d: "M.56 10.946H.06l-.002-.498L.025.92a.5.5 0 1 1 1-.004l.032 9.029H9.06v-4l9 4.5-9 4.5v-4H.56z",
    fillRule: "nonzero"
  }));
};
var DeliveredCheckIcon = function DeliveredCheckIcon() {
  return /*#__PURE__*/React__default['default'].createElement("svg", {
    width: "16",
    height: "16",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React__default['default'].createElement("path", {
    d: "M8 0a8 8 0 1 1 0 16A8 8 0 0 1 8 0zm3.72 6.633a.955.955 0 1 0-1.352-1.352L6.986 8.663 5.633 7.31A.956.956 0 1 0 4.28 8.663l2.029 2.028a.956.956 0 0 0 1.353 0l4.058-4.058z",
    fill: "#006CFF",
    fillRule: "evenodd"
  }));
};
var ReactionIcon = function ReactionIcon() {
  return /*#__PURE__*/React__default['default'].createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "12",
    height: "12",
    viewBox: "0 0 12 12"
  }, /*#__PURE__*/React__default['default'].createElement("g", {
    fillRule: "evenodd",
    clipRule: "evenodd"
  }, /*#__PURE__*/React__default['default'].createElement("path", {
    d: "M6 1.2C3.3 1.2 1.2 3.3 1.2 6c0 2.7 2.1 4.8 4.8 4.8 2.7 0 4.8-2.1 4.8-4.8 0-2.7-2.1-4.8-4.8-4.8zM0 6c0-3.3 2.7-6 6-6s6 2.7 6 6-2.7 6-6 6-6-2.7-6-6z"
  }), /*#__PURE__*/React__default['default'].createElement("path", {
    d: "M5.4 4.5c0 .5-.4.9-.9.9s-.9-.4-.9-.9.4-.9.9-.9.9.4.9.9zM8.4 4.5c0 .5-.4.9-.9.9s-.9-.4-.9-.9.4-.9.9-.9.9.4.9.9zM3.3 6.7c.3-.2.6-.1.8.1.3.4.8.9 1.5 1 .6.2 1.4.1 2.4-1 .2-.2.6-.3.8 0 .2.2.3.6 0 .8-1.1 1.3-2.4 1.7-3.5 1.5-1-.2-1.8-.9-2.2-1.5-.2-.3-.1-.7.2-.9z"
  })));
};
var ThreadIcon = function ThreadIcon() {
  return /*#__PURE__*/React__default['default'].createElement("svg", {
    width: "14",
    height: "10",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React__default['default'].createElement("path", {
    d: "M8.516 3c4.78 0 4.972 6.5 4.972 6.5-1.6-2.906-2.847-3.184-4.972-3.184v2.872L3.772 4.994 8.516.5V3zM.484 5l4.5-4.237v1.78L2.416 5l2.568 2.125v1.828L.484 5z",
    fillRule: "evenodd"
  }));
};
var ErrorIcon = function ErrorIcon() {
  return /*#__PURE__*/React__default['default'].createElement("svg", {
    width: "14",
    height: "14",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React__default['default'].createElement("path", {
    d: "M7 0a7 7 0 1 0 0 14A7 7 0 0 0 7 0zm.875 10.938a.438.438 0 0 1-.438.437h-.875a.438.438 0 0 1-.437-.438v-.874c0-.242.196-.438.438-.438h.875c.241 0 .437.196.437.438v.874zm0-2.626a.438.438 0 0 1-.438.438h-.875a.438.438 0 0 1-.437-.438v-5.25c0-.241.196-.437.438-.437h.875c.241 0 .437.196.437.438v5.25z",
    fill: "#EA152F",
    fillRule: "evenodd"
  }));
};
var PinIcon = function PinIcon() {
  return /*#__PURE__*/React__default['default'].createElement("svg", {
    width: "14",
    height: "13",
    viewBox: "0 0 14 13",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React__default['default'].createElement("path", {
    d: "M13.3518 6.686L6.75251 0.0866699L5.80984 1.02867L6.75318 1.972V1.97334L3.45318 5.272L3.45251 5.27334L2.50984 4.32934L1.56718 5.27267L4.39584 8.10067L0.624512 11.8713L1.56718 12.814L5.33851 9.04334L8.16718 11.8713L9.10984 10.9293L8.16718 9.986L11.4672 6.686L12.4098 7.62867L13.3518 6.686ZM7.22451 9.04267L7.22385 9.04334L4.39584 6.21467L7.69518 2.91467L10.5232 5.74267L7.22451 9.04267Z",
    fillRule: "evenodd"
  }));
};
/** @type {React.FC<import("types").PinIndicatorProps>} */

var PinIndicator = function PinIndicator(_ref) {
  var _message$pinned_by, _message$pinned_by2;

  var message = _ref.message,
      t = _ref.t;
  if (!message || !t) return null;
  return /*#__PURE__*/React__default['default'].createElement("div", {
    style: {
      display: 'flex',
      alignItems: 'center'
    }
  }, /*#__PURE__*/React__default['default'].createElement(PinIcon, null), /*#__PURE__*/React__default['default'].createElement("div", {
    style: {
      marginBottom: '0',
      marginTop: '0',
      marginLeft: '8px',
      fontSize: '14px'
    }
  }, message.pinned_by ? "".concat(t('Pinned by'), " ").concat(((_message$pinned_by = message.pinned_by) === null || _message$pinned_by === void 0 ? void 0 : _message$pinned_by.name) || ((_message$pinned_by2 = message.pinned_by) === null || _message$pinned_by2 === void 0 ? void 0 : _message$pinned_by2.id)) : t('Message pinned')));
};

// @ts-check
/** @type {React.FC<import("types").MessageRepliesCountButtonProps>} */

var MessageRepliesCountButton = function MessageRepliesCountButton(_ref) {
  var reply_count = _ref.reply_count,
      labelSingle = _ref.labelSingle,
      labelPlural = _ref.labelPlural,
      onClick = _ref.onClick;

  var _useContext = React.useContext(TranslationContext),
      t = _useContext.t;

  var singleReplyText;
  var pluralReplyText;

  if (reply_count === 1) {
    if (labelSingle) {
      singleReplyText = "1 ".concat(labelSingle);
    } else {
      singleReplyText = t('1 reply');
    }
  }

  if (reply_count && reply_count > 1) {
    if (labelPlural) {
      pluralReplyText = "".concat(reply_count, " ").concat(labelPlural);
    } else {
      pluralReplyText = t('{{ replyCount }} replies', {
        replyCount: reply_count
      });
    }
  }

  if (reply_count && reply_count !== 0) {
    return /*#__PURE__*/React__default['default'].createElement("button", {
      "data-testid": "replies-count-button",
      className: "str-chat__message-replies-count-button",
      onClick: onClick
    }, /*#__PURE__*/React__default['default'].createElement(ReplyIcon, null), reply_count === 1 ? singleReplyText : pluralReplyText);
  }

  return null;
};

MessageRepliesCountButton.defaultProps = {
  reply_count: 0
};
MessageRepliesCountButton.propTypes = {
  /** Label for number of replies, when count is 1 */
  labelSingle: PropTypes__default['default'].string,

  /** Label for number of replies, when count is more than 1 */
  labelPlural: PropTypes__default['default'].string,

  /** Number of replies */
  reply_count: PropTypes__default['default'].number,

  /**
   * click handler for button
   * @param event React's MouseEventHandler event
   * @returns void
   * */
  onClick: PropTypes__default['default'].func
};
var MessageRepliesCountButton$1 = /*#__PURE__*/React__default['default'].memo(MessageRepliesCountButton);

// @ts-check
/**
 * MML - A wrapper component around MML-React library
 *
 * @example ../../docs/MML.md
 * @typedef {import('../types').MMLProps} Props
 * @type { React.FC<Props>}
 */

var MML = function MML(_ref) {
  var source = _ref.source,
      actionHandler = _ref.actionHandler,
      _ref$align = _ref.align,
      align = _ref$align === void 0 ? 'right' : _ref$align;

  var _useContext = React.useContext(ChatContext),
      theme = _useContext.theme;

  if (!source) return null;
  return /*#__PURE__*/React__default['default'].createElement(mmlReact.MML, {
    source: source,
    className: "mml-align-".concat(align),
    onSubmit: actionHandler,
    Loading: null,
    Success: null,
    theme: (theme || '').replace(' ', '-')
  });
};

MML.propTypes = {
  /** mml source string */
  source: PropTypes__default['default'].string.isRequired,

  /** submit handler for mml actions */
  actionHandler: PropTypes__default['default'].func,

  /** align mml components to left/right */
  align: PropTypes__default['default'].oneOf(['left', 'right'])
};

// @ts-check
/** @type {React.FC<import("types").ModalProps>} */

var Modal = function Modal(_ref) {
  var children = _ref.children,
      onClose = _ref.onClose,
      open = _ref.open;

  /** @type {React.RefObject<HTMLDivElement>} */
  var innerRef = React.useRef(null);

  var _useContext = React.useContext(TranslationContext),
      t = _useContext.t;
  /** @param {React.MouseEvent} e */


  var handleClick = function handleClick(e) {
    var _innerRef$current;

    if (e.target instanceof Node && !((_innerRef$current = innerRef.current) !== null && _innerRef$current !== void 0 && _innerRef$current.contains(e.target)) && onClose) {
      onClose();
    }
  };

  React.useEffect(function () {
    if (!open) return function () {};
    /** @type {EventListener} */

    var handleEscKey = function handleEscKey(e) {
      if (e instanceof KeyboardEvent && e.keyCode === 27 && onClose) {
        onClose();
      }
    };

    document.addEventListener('keyPress', handleEscKey, false);
    return function () {
      return document.removeEventListener('keyPress', handleEscKey, false);
    };
  }, [onClose, open]);
  var openClasses = open ? 'str-chat__modal--open' : 'str-chat__modal--closed';
  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__modal ".concat(openClasses),
    onClick: handleClick
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__modal__close-button"
  }, t('Close'), /*#__PURE__*/React__default['default'].createElement("svg", {
    width: "10",
    height: "10",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React__default['default'].createElement("path", {
    d: "M9.916 1.027L8.973.084 5 4.058 1.027.084l-.943.943L4.058 5 .084 8.973l.943.943L5 5.942l3.973 3.974.943-.943L5.942 5z",
    fillRule: "evenodd"
  }))), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__modal__inner",
    ref: innerRef
  }, children));
};

Modal.propTypes = {
  /** Callback handler for closing of modal. */
  onClose: PropTypes__default['default'].func.isRequired,

  /** If true, modal is opened or visible. */
  open: PropTypes__default['default'].bool.isRequired
};

// @ts-check

var LoadingItems = function LoadingItems() {
  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__loading-channels-item"
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__loading-channels-avatar"
  }), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__loading-channels-meta"
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__loading-channels-username"
  }), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__loading-channels-status"
  })));
};
/**
 * LoadingChannels - Fancy loading indicator for the channel list
 *
 * @example ../../docs/LoadingChannels.md
 */


var LoadingChannels = function LoadingChannels() {
  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__loading-channels"
  }, /*#__PURE__*/React__default['default'].createElement(LoadingItems, null), /*#__PURE__*/React__default['default'].createElement(LoadingItems, null), /*#__PURE__*/React__default['default'].createElement(LoadingItems, null));
};

var LoadingChannels$1 = /*#__PURE__*/React__default['default'].memo(LoadingChannels);

// @ts-check
/**
 * LoadingErrorIndicator - UI component for error indicator in Channel.
 *
 * @example ../../docs/LoadingErrorIndicator.md
 * @type {React.FC<import('../types').LoadingErrorIndicatorProps>}
 */

var LoadingErrorIndicator = function LoadingErrorIndicator(_ref) {
  var error = _ref.error;

  var _useContext = React.useContext(TranslationContext),
      t = _useContext.t;

  if (!error) return null;
  return (
    /*#__PURE__*/
    // @ts-ignore
    React__default['default'].createElement("div", null, t('Error: {{ errorMessage }}', {
      errorMessage: error.message
    }))
  );
};

LoadingErrorIndicator.defaultProps = {
  error: null
};
LoadingErrorIndicator.propTypes = {
  /** Error object */
  error: PropTypes__default['default'].instanceOf(Error)
};
var DefaultLoadingErrorIndicator = /*#__PURE__*/React__default['default'].memo(LoadingErrorIndicator);

// @ts-check
/**
 * LoadingIndicator - Just a simple loading spinner..
 *
 * @example ../../docs/LoadingIndicator.md
 * @type { React.FC<import('../types').LoadingIndicatorProps>}
 */

var LoadingIndicator = function LoadingIndicator(_ref) {
  var _ref$size = _ref.size,
      size = _ref$size === void 0 ? 15 : _ref$size,
      _ref$color = _ref.color,
      color = _ref$color === void 0 ? '#006CFF' : _ref$color;
  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__loading-indicator ".concat(color),
    "data-testid": "loading-indicator-wrapper",
    style: {
      width: size,
      height: size
    }
  }, /*#__PURE__*/React__default['default'].createElement("svg", {
    width: size,
    height: size,
    viewBox: "0 0 30 30",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React__default['default'].createElement("defs", null, /*#__PURE__*/React__default['default'].createElement("linearGradient", {
    x1: "50%",
    y1: "0%",
    x2: "50%",
    y2: "100%",
    id: "a"
  }, /*#__PURE__*/React__default['default'].createElement("stop", {
    stopColor: "#FFF",
    stopOpacity: "0",
    offset: "0%"
  }), /*#__PURE__*/React__default['default'].createElement("stop", {
    offset: "100%",
    "data-testid": "loading-indicator-circle",
    stopColor: color,
    stopOpacity: "1",
    style: {
      stopColor: color
    }
  }))), /*#__PURE__*/React__default['default'].createElement("path", {
    d: "M2.518 23.321l1.664-1.11A12.988 12.988 0 0 0 15 28c7.18 0 13-5.82 13-13S22.18 2 15 2V0c8.284 0 15 6.716 15 15 0 8.284-6.716 15-15 15-5.206 0-9.792-2.652-12.482-6.679z",
    fill: "url(#a)",
    fillRule: "evenodd"
  })));
};

var DefaultLoadingIndicator = /*#__PURE__*/React__default['default'].memo(LoadingIndicator);

// @ts-check
/** @type {React.FC<import("types").EmoticonItemProps>} */

var EmoticonItem = function EmoticonItem(_ref) {
  var entity = _ref.entity;
  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__emoji-item"
  }, /*#__PURE__*/React__default['default'].createElement("span", {
    className: "str-chat__emoji-item--entity"
  }, entity.native), /*#__PURE__*/React__default['default'].createElement("span", {
    className: "str-chat__emoji-item--name"
  }, entity.name));
};

EmoticonItem.propTypes = {
  entity: PropTypes__default['default'].shape({
    /** Name for emoticon */
    name: PropTypes__default['default'].string.isRequired,

    /** Native value or actual emoticon */
    native: PropTypes__default['default'].string.isRequired
  }).isRequired
};
var EmoticonItem$1 = /*#__PURE__*/React__default['default'].memo(EmoticonItem);

// @ts-check
/**
 * UserItem - Component rendered in commands menu
 * @typedef {import('../types').UserItemProps} Props
 * @type {React.FC<Props>}
 */

var UserItem = function UserItem(_ref) {
  var _ref$Avatar = _ref.Avatar,
      Avatar$1 = _ref$Avatar === void 0 ? Avatar : _ref$Avatar,
      entity = _ref.entity;
  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__user-item"
  }, /*#__PURE__*/React__default['default'].createElement(Avatar$1, {
    size: 20,
    image: entity.image
  }), /*#__PURE__*/React__default['default'].createElement("div", null, /*#__PURE__*/React__default['default'].createElement("strong", null, entity.name), " ", !entity.name ? entity.id : ''));
};

UserItem.propTypes = {
  entity: PropTypes__default['default'].shape({
    /** Name of the user */
    name: PropTypes__default['default'].string,

    /** Id of the user */
    id: PropTypes__default['default'].string,

    /** Image of the user */
    image: PropTypes__default['default'].string
  }).isRequired,

  /**
   * Custom UI component to display user avatar
   *
   * Defaults to and accepts same props as: [Avatar](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Avatar/Avatar.js)
   * */
  Avatar:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').AvatarProps>>} */
  PropTypes__default['default'].elementType
};
var UserItem$1 = /*#__PURE__*/React__default['default'].memo(UserItem);

// @ts-check
/**
 * @type {React.FC<import('../types').CommandItemProps>}
 */

var CommandItem = function CommandItem(_ref) {
  var entity = _ref.entity;
  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__slash-command"
  }, /*#__PURE__*/React__default['default'].createElement("span", {
    className: "str-chat__slash-command-header"
  }, /*#__PURE__*/React__default['default'].createElement("strong", null, entity.name), " ", entity.args), /*#__PURE__*/React__default['default'].createElement("br", null), /*#__PURE__*/React__default['default'].createElement("span", {
    className: "str-chat__slash-command-description"
  }, entity.description));
};

CommandItem.propTypes = {
  entity: PropTypes__default['default'].shape({
    /** Name of the command */
    name: PropTypes__default['default'].string,

    /** Arguments of command */
    args: PropTypes__default['default'].string,

    /** Description of command */
    description: PropTypes__default['default'].string
  }).isRequired
};
var CommandItem$1 = /*#__PURE__*/React__default['default'].memo(CommandItem);

/** @type {React.FC<import("types").ChatAutoCompleteProps>} */

var ChatAutoComplete = function ChatAutoComplete(props) {
  var _channel$state, _channel$state2;

  var commands = props.commands,
      onSelectItem = props.onSelectItem,
      triggers = props.triggers;

  var _useContext = React.useContext(ChannelContext),
      channel = _useContext.channel;

  var _useContext2 = React.useContext(EmojiContext),
      emojiData = _useContext2.emojiData,
      EmojiIndex = _useContext2.EmojiIndex;

  var members = channel === null || channel === void 0 ? void 0 : (_channel$state = channel.state) === null || _channel$state === void 0 ? void 0 : _channel$state.members;
  var watchers = channel === null || channel === void 0 ? void 0 : (_channel$state2 = channel.state) === null || _channel$state2 === void 0 ? void 0 : _channel$state2.watchers; // @ts-ignore

  var emojiIndex = React.useMemo(function () {
    return new EmojiIndex(emojiData);
  }, [emojiData, EmojiIndex]);
  /** @param {string} word */

  var emojiReplace = function emojiReplace(word) {
    var found = emojiIndex.search(word) || [];
    var emoji = found.slice(0, 10).find(
    /** @type {{ ({ emoticons } : import('emoji-mart').EmojiData): boolean }} */
    function (_ref) {
      var emoticons = _ref.emoticons;
      return !!(emoticons !== null && emoticons !== void 0 && emoticons.includes(word));
    });
    if (!emoji || !('native' in emoji)) return null;
    return emoji.native;
  };

  var getMembersAndWatchers = React.useCallback(function () {
    var memberUsers = members ? Object.values(members).map(function (_ref2) {
      var user = _ref2.user;
      return user;
    }) : [];
    var watcherUsers = watchers ? Object.values(watchers) : [];
    var users = [].concat(_toConsumableArray__default['default'](memberUsers), _toConsumableArray__default['default'](watcherUsers)); // make sure we don't list users twice

    /** @type {{ [key: string]: import('seamless-immutable').ImmutableObject<import('stream-chat').UserResponse<import('../types').StreamChatReactUserType>> }} */

    var uniqueUsers = {};
    users.forEach(function (user) {
      if (user && !uniqueUsers[user.id]) {
        uniqueUsers[user.id] = user;
      }
    });
    return Object.values(uniqueUsers);
  }, [members, watchers]); // eslint-disable-next-line react-hooks/exhaustive-deps

  var queryMembersdebounced = React.useCallback(debounce__default['default'](
  /*#__PURE__*/

  /**
   * @param {string} query
   * @param {(data: any[]) => void} onReady
   */
  function () {
    var _ref3 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(query, onReady) {
      var response, users;
      return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (channel !== null && channel !== void 0 && channel.queryMembers) {
                _context.next = 2;
                break;
              }

              return _context.abrupt("return");

            case 2:
              _context.next = 4;
              return channel === null || channel === void 0 ? void 0 : channel.queryMembers({
                name: {
                  $autocomplete: query
                }
              });

            case 4:
              response = _context.sent;
              users = response.members.map(function (m) {
                return m.user;
              });
              if (onReady) onReady(users);

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x, _x2) {
      return _ref3.apply(this, arguments);
    };
  }(), 200), [channel === null || channel === void 0 ? void 0 : channel.queryMembers]);
  /**
   * dataProvider accepts `onReady` function, which will executed once the data is ready.
   * Another approach would have been to simply return the data from dataProvider and let the
   * component await for it and then execute the required logic. We are going for callback instead
   * of async-await since we have debounce function in dataProvider. Which will delay the execution
   * of api call on trailing end of debounce (lets call it a1) but will return with result of
   * previous call without waiting for a1. So in this case, we want to execute onReady, when trailing
   * end of debounce executes.
   * @type {() => import("../AutoCompleteTextarea/types").TriggerMap | object}
   */

  var getTriggers = React.useCallback( // eslint-disable-next-line sonarjs/cognitive-complexity
  function () {
    return triggers || {
      ':': {
        dataProvider: function dataProvider(q, text, onReady) {
          if (q.length === 0 || q.charAt(0).match(/[^a-zA-Z0-9+-]/)) {
            return [];
          }

          var emojis = emojiIndex.search(q) || [];
          var result = emojis.slice(0, 10);
          if (onReady) onReady(result, q);
          return result;
        },
        component: EmoticonItem$1,
        output: function output(entity) {
          return {
            key: entity.id,
            text: "".concat(entity.native),
            caretPosition: 'next'
          };
        }
      },
      '@': {
        dataProvider: function dataProvider(query, text, onReady) {
          // By default, we return maximum 100 members via queryChannels api call.
          // Thus it is safe to assume, that if number of members in channel.state is < 100,
          // then all the members are already available on client side and we don't need to
          // make any api call to queryMembers endpoint.
          if (!query || Object.values(members || {}).length < 100) {
            var users = getMembersAndWatchers();
            var matchingUsers = users.filter(function (user) {
              if (!query) return true;

              if (user.name !== undefined && user.name.toLowerCase().includes(query.toLowerCase())) {
                return true;
              }

              return user.id.toLowerCase().includes(query.toLowerCase());
            });
            var data = matchingUsers.slice(0, 10);
            if (onReady) onReady(data, query);
            return data;
          }

          return queryMembersdebounced(query,
          /** @param {any[]} data */
          function (data) {
            if (onReady) onReady(data, query);
          });
        },
        component: UserItem$1,
        output: function output(entity) {
          return {
            key: entity.id,
            text: "@".concat(entity.name || entity.id),
            caretPosition: 'next'
          };
        },
        callback: function callback(item) {
          return onSelectItem && onSelectItem(item);
        }
      },
      '/': {
        dataProvider: function dataProvider(q, text, onReady) {
          if (text.indexOf('/') !== 0 || !commands) {
            return [];
          }

          var selectedCommands = commands.filter(function (c) {
            var _c$name;

            return ((_c$name = c.name) === null || _c$name === void 0 ? void 0 : _c$name.indexOf(q)) !== -1;
          }); // sort alphabetically unless the you're matching the first char

          selectedCommands.sort(function (a, b) {
            var _a$name, _b$name, _nameA, _nameB;

            var nameA = (_a$name = a.name) === null || _a$name === void 0 ? void 0 : _a$name.toLowerCase();
            var nameB = (_b$name = b.name) === null || _b$name === void 0 ? void 0 : _b$name.toLowerCase();

            if (((_nameA = nameA) === null || _nameA === void 0 ? void 0 : _nameA.indexOf(q)) === 0) {
              nameA = "0".concat(nameA);
            }

            if (((_nameB = nameB) === null || _nameB === void 0 ? void 0 : _nameB.indexOf(q)) === 0) {
              nameB = "0".concat(nameB);
            } // Should confirm possible null / undefined when TS is fully implemented


            if (nameA != null && nameB != null) {
              if (nameA < nameB) {
                return -1;
              }

              if (nameA > nameB) {
                return 1;
              }
            }

            return 0;
          });
          var result = selectedCommands.slice(0, 10);
          if (onReady) onReady(result, q);
          return result;
        },
        component: CommandItem$1,
        output: function output(entity) {
          return {
            key: entity.id,
            text: "/".concat(entity.name),
            caretPosition: 'next'
          };
        }
      }
    };
  }, [commands, getMembersAndWatchers, members, onSelectItem, queryMembersdebounced, triggers, emojiIndex]);
  var innerRef = props.innerRef;
  var updateInnerRef = React.useCallback(function (ref) {
    if (innerRef) innerRef.current = ref;
  }, [innerRef]);
  return /*#__PURE__*/React__default['default'].createElement(ReactTextareaAutocomplete, {
    loadingComponent: DefaultLoadingIndicator,
    trigger: getTriggers(),
    replaceWord: emojiReplace,
    minChar: 0,
    maxRows: props.maxRows,
    innerRef: updateInnerRef,
    onFocus: props.onFocus,
    rows: props.rows,
    className: "str-chat__textarea__textarea",
    containerClassName: "str-chat__textarea",
    dropdownClassName: "str-chat__emojisearch",
    listClassName: "str-chat__emojisearch__list",
    itemClassName: "str-chat__emojisearch__item",
    placeholder: props.placeholder,
    onChange: props.onChange,
    handleSubmit: props.handleSubmit,
    onPaste: props.onPaste,
    value: props.value,
    grow: props.grow,
    disabled: props.disabled,
    disableMentions: props.disableMentions,
    SuggestionList: props.SuggestionList,
    additionalTextareaProps: props.additionalTextareaProps
  });
};

ChatAutoComplete.propTypes = {
  /** The number of rows you want the textarea to have */
  rows: PropTypes__default['default'].number,

  /** Grow the number of rows of the textarea while you're typing */
  grow: PropTypes__default['default'].bool,

  /** Maximum number of rows */
  maxRows: PropTypes__default['default'].number,

  /** Make the textarea disabled */
  disabled: PropTypes__default['default'].bool,

  /** Disable mentions */
  disableMentions: PropTypes__default['default'].bool,

  /** The value of the textarea */
  value: PropTypes__default['default'].string,

  /** Function to run on pasting within the textarea */
  onPaste: PropTypes__default['default'].func,

  /** Function that runs on submit */
  handleSubmit: PropTypes__default['default'].func,

  /** Function that runs on change */
  onChange: PropTypes__default['default'].func,

  /** Placeholder for the textarea */
  placeholder: PropTypes__default['default'].string,

  /** What loading component to use for the auto complete when loading results. */
  LoadingIndicator:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').LoadingIndicatorProps>>} */
  PropTypes__default['default'].elementType,

  /** Minimum number of Character */
  minChar: PropTypes__default['default'].number,

  /**
   * Handler for selecting item from suggestions list
   *
   * @param item Selected item object.
   *  */
  onSelectItem: PropTypes__default['default'].func,

  /** Array of [commands](https://getstream.io/chat/docs/#channel_commands) */
  commands: PropTypes__default['default'].array,

  /** Listener for onfocus event on textarea */
  onFocus: PropTypes__default['default'].func,

  /** Optional UI component prop to override the default List component that displays suggestions */
  SuggestionList:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').SuggestionListProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * Any additional attributes that you may want to add for underlying HTML textarea element.
   */
  additionalTextareaProps: PropTypes__default['default'].object
};
ChatAutoComplete.defaultProps = {
  rows: 3
};
var ChatAutoComplete$1 = /*#__PURE__*/React__default['default'].memo(ChatAutoComplete);

/**
 * @type {React.FC<import('../types').TooltipProps>}
 */

var Tooltip = function Tooltip(props) {
  return /*#__PURE__*/React__default['default'].createElement("div", _extends__default['default']({
    className: "str-chat__tooltip"
  }, props), props.children);
};

var Tooltip$1 = /*#__PURE__*/React__default['default'].memo(Tooltip);

function ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$5(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
/**
 * @typedef {import("types").MessageInputState} State
 * @typedef {import("types").MessageInputProps} Props
 * @typedef {import('stream-chat').Unpacked<ReturnType<import("types").StreamChatReactClient['sendFile']>>} FileUploadAPIResponse
 * @typedef {import('stream-chat').UserResponse} UserResponse
 */

/**
 * Get attachment type from MIME type
 * @param {string} mime
 * @returns {string}
 */

var getAttachmentTypeFromMime = function getAttachmentTypeFromMime(mime) {
  if (mime.includes('video/')) return 'media';
  if (mime.includes('audio/')) return 'audio';
  return 'file';
};
/** @type {{ [id: string]: import('../types').FileUpload }} */


var emptyFileUploads = {};
/** @type {{ [id: string]: import('../types').ImageUpload }} */

var emptyImageUploads = {};
var apiMaxNumberOfFiles = 10;
/**
 * Initializes the state. Empty if the message prop is falsy.
 * @param {import("stream-chat").MessageResponse | undefined} message
 * @returns {State}
 */

function initState(message) {
  var _message$attachments, _message$attachments2, _message$attachments3;

  if (!message) {
    return {
      text: '',
      imageOrder: [],
      imageUploads: Immutable__default['default'](emptyImageUploads),
      fileOrder: [],
      fileUploads: Immutable__default['default'](emptyFileUploads),
      numberOfUploads: 0,
      attachments: [],
      mentioned_users: [],
      emojiPickerIsOpen: false
    };
  } // if message prop is defined, get image uploads, file uploads, text, etc. from it


  var imageUploads = ((_message$attachments = message.attachments) === null || _message$attachments === void 0 ? void 0 : _message$attachments.filter(function (_ref) {
    var type = _ref.type;
    return type === 'image';
  }).reduce(function (acc, attachment) {
    var id = generateRandomId();
    return acc.setIn([id], {
      id,
      url: attachment.image_url,
      state: 'finished',
      file: {
        name: attachment.fallback
      }
    });
  }, Immutable__default['default'](emptyImageUploads))) || Immutable__default['default'](emptyImageUploads);
  var imageOrder = Object.keys(imageUploads);
  var fileUploads = ((_message$attachments2 = message.attachments) === null || _message$attachments2 === void 0 ? void 0 : _message$attachments2.filter(function (_ref2) {
    var type = _ref2.type;
    return type === 'file';
  }).reduce(function (acc, attachment) {
    var id = generateRandomId();
    return acc.setIn([id], {
      id,
      url: attachment.asset_url,
      state: 'finished',
      file: {
        name: attachment.title,
        type: attachment.mime_type,
        size: attachment.file_size
      }
    });
  }, Immutable__default['default'](emptyFileUploads))) || Immutable__default['default'](emptyFileUploads);
  var fileOrder = Object.keys(fileUploads);
  var numberOfUploads = fileOrder.length + imageOrder.length;
  var attachments = ((_message$attachments3 = message.attachments) === null || _message$attachments3 === void 0 ? void 0 : _message$attachments3.filter(function (_ref3) {
    var type = _ref3.type;
    return type !== 'file' && type !== 'image';
  })) || [];
  var mentioned_users = message.mentioned_users || [];
  return {
    text: message.text || '',
    imageOrder,
    imageUploads,
    fileOrder,
    fileUploads,
    numberOfUploads,
    attachments,
    mentioned_users,
    emojiPickerIsOpen: false
  };
}
/**
 * MessageInput state reducer
 * @param {State} state
 * @param {import("./types").MessageInputReducerAction} action
 * @returns {State}
 */


function messageInputReducer(state, action) {
  switch (action.type) {
    case 'setEmojiPickerIsOpen':
      return _objectSpread$5(_objectSpread$5({}, state), {}, {
        emojiPickerIsOpen: action.value
      });

    case 'setText':
      return _objectSpread$5(_objectSpread$5({}, state), {}, {
        text: action.getNewText(state.text)
      });

    case 'clear':
      return _objectSpread$5(_objectSpread$5({}, state), {}, {
        text: '',
        mentioned_users: [],
        imageOrder: [],
        imageUploads: Immutable__default['default'](emptyImageUploads),
        fileOrder: [],
        fileUploads: Immutable__default['default'](emptyFileUploads),
        numberOfUploads: 0
      });

    case 'setImageUpload':
      {
        var imageAlreadyExists = state.imageUploads[action.id];
        if (!imageAlreadyExists && !action.file) return state;
        var imageOrder = imageAlreadyExists ? state.imageOrder : state.imageOrder.concat(action.id);

        var type = action.type,
            newUploadFields = _objectWithoutProperties__default['default'](action, ["type"]);

        return _objectSpread$5(_objectSpread$5({}, state), {}, {
          imageOrder,
          imageUploads: state.imageUploads.setIn([action.id], _objectSpread$5(_objectSpread$5({}, state.imageUploads[action.id]), newUploadFields)),
          numberOfUploads: imageAlreadyExists ? state.numberOfUploads : state.numberOfUploads + 1
        });
      }

    case 'setFileUpload':
      {
        var fileAlreadyExists = state.fileUploads[action.id];
        if (!fileAlreadyExists && !action.file) return state;
        var fileOrder = fileAlreadyExists ? state.fileOrder : state.fileOrder.concat(action.id);

        var _type = action.type,
            _newUploadFields = _objectWithoutProperties__default['default'](action, ["type"]);

        return _objectSpread$5(_objectSpread$5({}, state), {}, {
          fileOrder,
          fileUploads: state.fileUploads.setIn([action.id], _objectSpread$5(_objectSpread$5({}, state.fileUploads[action.id]), _newUploadFields)),
          numberOfUploads: fileAlreadyExists ? state.numberOfUploads : state.numberOfUploads + 1
        });
      }

    case 'removeImageUpload':
      if (!state.imageUploads[action.id]) return state; // cannot remove anything

      return _objectSpread$5(_objectSpread$5({}, state), {}, {
        numberOfUploads: state.numberOfUploads - 1,
        imageOrder: state.imageOrder.filter(function (_id) {
          return _id !== action.id;
        }),
        imageUploads: state.imageUploads.without(action.id)
      });

    case 'removeFileUpload':
      if (!state.fileUploads[action.id]) return state; // cannot remove anything

      return _objectSpread$5(_objectSpread$5({}, state), {}, {
        numberOfUploads: state.numberOfUploads - 1,
        fileOrder: state.fileOrder.filter(function (_id) {
          return _id !== action.id;
        }),
        fileUploads: state.fileUploads.without(action.id)
      });

    case 'reduceNumberOfUploads':
      // TODO: figure out if we can just use uploadOrder instead
      return _objectSpread$5(_objectSpread$5({}, state), {}, {
        numberOfUploads: state.numberOfUploads - 1
      });

    case 'addMentionedUser':
      return _objectSpread$5(_objectSpread$5({}, state), {}, {
        mentioned_users: state.mentioned_users.concat(action.user)
      });

    default:
      return state;
  }
}
/**
 * hook for MessageInput state
 * @type{import('../types').useMessageInput}
 */


function useMessageInput(props) {
  var _channel$getConfig2, _channel$getConfig2$c;

  var additionalTextareaProps = props.additionalTextareaProps,
      clearEditingState = props.clearEditingState,
      doImageUploadRequest = props.doImageUploadRequest,
      doFileUploadRequest = props.doFileUploadRequest,
      errorHandler = props.errorHandler,
      focus = props.focus,
      message = props.message,
      noFiles = props.noFiles,
      overrideSubmitHandler = props.overrideSubmitHandler,
      parent = props.parent,
      publishTypingEvent = props.publishTypingEvent;

  var _useContext = React.useContext(ChannelContext),
      channel = _useContext.channel,
      editMessage = _useContext.editMessage,
      maxNumberOfFiles = _useContext.maxNumberOfFiles,
      multipleUploads = _useContext.multipleUploads,
      sendMessage = _useContext.sendMessage;

  var _useReducer = React.useReducer(messageInputReducer, message, initState),
      _useReducer2 = _slicedToArray__default['default'](_useReducer, 2),
      state = _useReducer2[0],
      dispatch = _useReducer2[1];

  var text = state.text,
      imageOrder = state.imageOrder,
      imageUploads = state.imageUploads,
      fileOrder = state.fileOrder,
      fileUploads = state.fileUploads,
      attachments = state.attachments,
      numberOfUploads = state.numberOfUploads,
      mentioned_users = state.mentioned_users;
  var textareaRef = React.useRef(
  /** @type {HTMLTextAreaElement | undefined} */
  undefined);
  var emojiPickerRef = React.useRef(
  /** @type {HTMLDivElement | null} */
  null); // Focus

  React.useEffect(function () {
    if (focus && textareaRef.current) {
      textareaRef.current.focus();
    }
  }, [focus]); // Text + cursor position

  var newCursorPosition = React.useRef(
  /** @type {number | null} */
  null);
  var insertText = React.useCallback(function (textToInsert) {
    var maxLength = additionalTextareaProps.maxLength;

    if (!textareaRef.current) {
      dispatch({
        type: 'setText',
        getNewText: function getNewText(t) {
          var updatedText = t + textToInsert;

          if (updatedText.length > maxLength) {
            return updatedText.slice(0, maxLength);
          }

          return updatedText;
        }
      });
      return;
    }

    var _textareaRef$current = textareaRef.current,
        selectionStart = _textareaRef$current.selectionStart,
        selectionEnd = _textareaRef$current.selectionEnd;
    newCursorPosition.current = selectionStart + textToInsert.length;
    dispatch({
      type: 'setText',
      getNewText: function getNewText(prevText) {
        var updatedText = prevText.slice(0, selectionStart) + textToInsert + prevText.slice(selectionEnd);

        if (updatedText.length > maxLength) {
          return updatedText.slice(0, maxLength);
        }

        return updatedText;
      }
    });
  }, [additionalTextareaProps, newCursorPosition, textareaRef]);
  React.useEffect(function () {
    var textareaElement = textareaRef.current;

    if (textareaElement && newCursorPosition.current !== null) {
      textareaElement.selectionStart = newCursorPosition.current;
      textareaElement.selectionEnd = newCursorPosition.current;
      newCursorPosition.current = null;
    }
  }, [text, newCursorPosition]);
  var handleChange = React.useCallback(function (event) {
    event.preventDefault();

    if (!event || !event.target) {
      return;
    }

    var newText = event.target.value;
    dispatch({
      type: 'setText',
      getNewText: function getNewText() {
        return newText;
      }
    });

    if (publishTypingEvent && newText && channel) {
      streamChat.logChatPromiseExecution(channel.keystroke(parent === null || parent === void 0 ? void 0 : parent.id), 'start typing event');
    }
  }, [channel, parent, publishTypingEvent]); // Emoji

  var closeEmojiPicker = React.useCallback(function (e) {
    if (emojiPickerRef.current && !emojiPickerRef.current.contains(e.target)) {
      dispatch({
        type: 'setEmojiPickerIsOpen',
        value: false
      });
    }
  }, [emojiPickerRef]);
  var openEmojiPicker = React.useCallback(function (event) {
    dispatch({
      type: 'setEmojiPickerIsOpen',
      value: true
    }); // Prevent event from bubbling to document, so the close handler is never called for this event

    event.stopPropagation();
  }, []);
  React.useEffect(function () {
    if (state.emojiPickerIsOpen) {
      document.addEventListener('click', closeEmojiPicker, false);
    }

    return function () {
      return document.removeEventListener('click', closeEmojiPicker, false);
    };
  }, [closeEmojiPicker, state.emojiPickerIsOpen]);
  var onSelectEmoji = React.useCallback(function (emoji) {
    return insertText(emoji.native);
  }, [insertText]); // Commands / mentions

  var getCommands = React.useCallback(function () {
    var _channel$getConfig;

    return channel === null || channel === void 0 ? void 0 : (_channel$getConfig = channel.getConfig()) === null || _channel$getConfig === void 0 ? void 0 : _channel$getConfig.commands;
  }, [channel]);
  var getUsers = React.useCallback(function () {
    if (!channel) return [];
    return [].concat(_toConsumableArray__default['default'](Object.values(channel.state.members).map(function (_ref4) {
      var user = _ref4.user;
      return user;
    })), _toConsumableArray__default['default'](Object.values(channel.state.watchers))).filter(function (_user, index, self) {
      return self.findIndex(function (user) {
        return (user === null || user === void 0 ? void 0 : user.id) === (_user === null || _user === void 0 ? void 0 : _user.id);
      }) === index;
    } // filter out non-unique ids
    );
  }, [channel]);
  var onSelectItem = React.useCallback(
  /** @param {UserResponse} item */
  function (item) {
    dispatch({
      type: 'addMentionedUser',
      user: item
    });
  }, []); // Submitting

  var getAttachmentsFromUploads = React.useCallback(function () {
    var imageAttachments = imageOrder.map(function (id) {
      return imageUploads[id];
    }).filter(function (upload) {
      return upload.state !== 'failed';
    }).filter(function (_ref5, index, self) {
      var id = _ref5.id,
          url = _ref5.url;
      return (// filter out duplicates based on url
        self.every(function (upload) {
          return upload.id === id || upload.url !== url;
        })
      );
    }).map(function (upload) {
      return {
        type: 'image',
        image_url: upload.url,
        fallback: upload.file.name
      };
    });
    var fileAttachments = fileOrder.map(function (id) {
      return fileUploads[id];
    }).filter(function (upload) {
      return upload.state !== 'failed';
    }).map(function (upload) {
      return {
        type: getAttachmentTypeFromMime(upload.file.type),
        asset_url: upload.url,
        title: upload.file.name,
        mime_type: upload.file.type,
        file_size: upload.file.size
      };
    });
    return [].concat(_toConsumableArray__default['default'](attachments), _toConsumableArray__default['default'](imageAttachments), _toConsumableArray__default['default'](fileAttachments));
  }, [imageOrder, imageUploads, fileOrder, fileUploads, attachments]);
  /**
   * @param {React.FormEvent | React.MouseEvent} event
   */

  var handleSubmit = function handleSubmit(event) {
    event.preventDefault();
    var trimmedMessage = text.trim();
    var isEmptyMessage = trimmedMessage === '' || trimmedMessage === '>' || trimmedMessage === '``````' || trimmedMessage === '``' || trimmedMessage === '**' || trimmedMessage === '____' || trimmedMessage === '__' || trimmedMessage === '****';

    if (isEmptyMessage && numberOfUploads === 0) {
      return;
    } // the channel component handles the actual sending of the message


    var someAttachmentsUploading = Object.values(imageUploads).some(function (upload) {
      return upload.state === 'uploading';
    }) || Object.values(fileUploads).some(function (upload) {
      return upload.state === 'uploading';
    });

    if (someAttachmentsUploading) {
      // TODO: show error to user that they should wait until image is uploaded
      return;
    }

    var newAttachments = getAttachmentsFromUploads(); // Instead of checking if a user is still mentioned every time the text changes,
    // just filter out non-mentioned users before submit, which is cheaper
    // and allows users to easily undo any accidental deletion

    var actualMentionedUsers = Array.from(new Set(mentioned_users.filter(function (_ref6) {
      var name = _ref6.name,
          id = _ref6.id;
      return text.includes("@".concat(id)) || text.includes("@".concat(name));
    }).map(function (_ref7) {
      var id = _ref7.id;
      return id;
    })));
    var updatedMessage = {
      text,
      attachments: newAttachments,
      mentioned_users: actualMentionedUsers
    };

    if (!!message && editMessage) {
      // TODO: Remove this line and show an error when submit fails
      if (clearEditingState) clearEditingState();
      var updateMessagePromise = editMessage(_objectSpread$5(_objectSpread$5({}, updatedMessage), {}, {
        id: message.id
      })).then(clearEditingState);
      streamChat.logChatPromiseExecution(updateMessagePromise, 'update message');
    } else if (overrideSubmitHandler && typeof overrideSubmitHandler === 'function' && channel) {
      overrideSubmitHandler(_objectSpread$5(_objectSpread$5({}, updatedMessage), {}, {
        parent
      }), channel.cid);
      dispatch({
        type: 'clear'
      });
    } else if (sendMessage) {
      var sendMessagePromise = sendMessage(_objectSpread$5(_objectSpread$5({}, updatedMessage), {}, {
        parent
      }));
      streamChat.logChatPromiseExecution(sendMessagePromise, 'send message');
      dispatch({
        type: 'clear'
      });
    }

    if (channel && publishTypingEvent) streamChat.logChatPromiseExecution(channel.stopTyping(), 'stop typing');
  }; // Attachments
  // Files


  var uploadFile = React.useCallback(function (id) {
    dispatch({
      type: 'setFileUpload',
      id,
      state: 'uploading'
    });
  }, []);
  var removeFile = React.useCallback(function (id) {
    // TODO: cancel upload if still uploading
    dispatch({
      type: 'removeFileUpload',
      id
    });
  }, []);
  React.useEffect(function () {
    _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {
      var upload, id, file, response, alreadyRemoved;
      return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (channel) {
                _context.next = 2;
                break;
              }

              return _context.abrupt("return");

            case 2:
              upload = Object.values(fileUploads).find(function (fileUpload) {
                return fileUpload.state === 'uploading' && fileUpload.file;
              });

              if (upload) {
                _context.next = 5;
                break;
              }

              return _context.abrupt("return");

            case 5:
              id = upload.id, file = upload.file;
              /** @type FileUploadAPIResponse */

              _context.prev = 6;

              if (!doFileUploadRequest) {
                _context.next = 13;
                break;
              }

              _context.next = 10;
              return doFileUploadRequest(file, channel);

            case 10:
              response = _context.sent;
              _context.next = 16;
              break;

            case 13:
              _context.next = 15;
              return channel.sendFile(file);

            case 15:
              response = _context.sent;

            case 16:
              _context.next = 26;
              break;

            case 18:
              _context.prev = 18;
              _context.t0 = _context["catch"](6);
              console.warn(_context.t0);
              alreadyRemoved = false;
              dispatch({
                type: 'reduceNumberOfUploads'
              });

              if (!fileUploads[id]) {
                alreadyRemoved = true;
              } else {
                dispatch({
                  type: 'setFileUpload',
                  id,
                  state: 'failed'
                });
              }

              if (!alreadyRemoved && errorHandler) {
                // TODO: verify if the parameters passed to the error handler actually make sense
                errorHandler(_context.t0, 'upload-file', file);
              }

              return _context.abrupt("return");

            case 26:
              if (response) {
                _context.next = 29;
                break;
              }

              removeFile(id);
              return _context.abrupt("return");

            case 29:
              dispatch({
                type: 'setFileUpload',
                id,
                state: 'finished',
                url: response.file
              });

            case 30:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[6, 18]]);
    }))();
  }, [fileUploads, channel, doFileUploadRequest, errorHandler, removeFile]); // Images

  var removeImage = React.useCallback(function (id) {
    dispatch({
      type: 'removeImageUpload',
      id
    }); // TODO: cancel upload if still uploading
  }, []);
  var uploadImage = React.useCallback( /*#__PURE__*/function () {
    var _ref9 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2(id) {
      var img, file, response, alreadyRemoved;
      return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              img = imageUploads[id];

              if (!(!img || !channel)) {
                _context2.next = 3;
                break;
              }

              return _context2.abrupt("return");

            case 3:
              file = img.file;

              if (img.state !== 'uploading') {
                dispatch({
                  type: 'setImageUpload',
                  id,
                  state: 'uploading'
                });
              }
              /** @type FileUploadAPIResponse */


              _context2.prev = 5;

              if (!doImageUploadRequest) {
                _context2.next = 12;
                break;
              }

              _context2.next = 9;
              return doImageUploadRequest(file, channel);

            case 9:
              response = _context2.sent;
              _context2.next = 15;
              break;

            case 12:
              _context2.next = 14;
              return channel.sendImage(file);

            case 14:
              response = _context2.sent;

            case 15:
              _context2.next = 25;
              break;

            case 17:
              _context2.prev = 17;
              _context2.t0 = _context2["catch"](5);
              console.warn(_context2.t0);
              alreadyRemoved = false;
              dispatch({
                type: 'reduceNumberOfUploads'
              });

              if (!imageUploads[id]) {
                alreadyRemoved = true;
              } else {
                dispatch({
                  type: 'setImageUpload',
                  id,
                  state: 'failed'
                });
              }

              if (!alreadyRemoved && errorHandler) {
                // TODO: verify if the parameters passed to the error handler actually make sense
                errorHandler(_context2.t0, 'upload-image', {
                  id,
                  file
                });
              }

              return _context2.abrupt("return");

            case 25:
              if (response) {
                _context2.next = 28;
                break;
              }

              removeImage(id);
              return _context2.abrupt("return");

            case 28:
              dispatch({
                type: 'setImageUpload',
                id,
                state: 'finished',
                url: response.file
              });

            case 29:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[5, 17]]);
    }));

    return function (_x) {
      return _ref9.apply(this, arguments);
    };
  }(), [imageUploads, channel, doImageUploadRequest, errorHandler, removeImage]);
  React.useEffect(function () {
    if (FileReader) {
      var upload = Object.values(imageUploads).find(function (imageUpload) {
        return imageUpload.state === 'uploading' && !!imageUpload.file && !imageUpload.previewUri;
      });

      if (upload) {
        var id = upload.id,
            file = upload.file; // TODO: Possibly use URL.createObjectURL instead. However, then we need
        // to release the previews when not used anymore though.

        var reader = new FileReader();

        reader.onload = function (event) {
          var _event$target;

          if (typeof ((_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result) !== 'string') return;
          dispatch({
            type: 'setImageUpload',
            id,
            previewUri: event.target.result
          });
        };

        reader.readAsDataURL(file);
        uploadImage(id);
        return function () {
          reader.onload = null;
        };
      }
    }

    return function () {};
  }, [imageUploads, uploadImage]); // Number of files that the user can still add. Should never be more than the amount allowed by the API.
  // If multipleUploads is false, we only want to allow a single upload.

  var maxFilesAllowed = React.useMemo(function () {
    if (!multipleUploads) return 1;

    if (maxNumberOfFiles === undefined) {
      return apiMaxNumberOfFiles;
    }

    return maxNumberOfFiles;
  }, [maxNumberOfFiles, multipleUploads]);
  var maxFilesLeft = maxFilesAllowed - numberOfUploads;
  var uploadNewFiles = React.useCallback(
  /**
   * @param {FileList} files
   */
  function (files) {
    Array.from(files).slice(0, maxFilesLeft).forEach(function (file) {
      var id = generateRandomId();

      if (file.type.startsWith('image/') && !file.type.endsWith('.photoshop') // photoshop files begin with 'image/'
      ) {
          dispatch({
            type: 'setImageUpload',
            id,
            file,
            state: 'uploading'
          });
        } else if (file instanceof File && !noFiles) {
        dispatch({
          type: 'setFileUpload',
          id,
          file,
          state: 'uploading'
        });
      }
    });
  }, [maxFilesLeft, noFiles]);
  var onPaste = React.useCallback(
  /** (e: React.ClipboardEvent) */
  function (e) {
    (function () {
      var _ref10 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(event) {
        var items, plainTextPromise, plainTextItem, fileLikes, pastedText;
        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                // TODO: Move this handler to package with ImageDropzone
                items = event.clipboardData.items;

                if (reactFileUtils.dataTransferItemsHaveFiles(items)) {
                  _context3.next = 3;
                  break;
                }

                return _context3.abrupt("return");

              case 3:
                event.preventDefault(); // Get a promise for the plain text in case no files are
                // found. This needs to be done here because chrome cleans
                // up the DataTransferItems after resolving of a promise.

                /** @type {DataTransferItem} */
                plainTextItem = _toConsumableArray__default['default'](items).find(function (_ref11) {
                  var kind = _ref11.kind,
                      type = _ref11.type;
                  return kind === 'string' && type === 'text/plain';
                });

                if (plainTextItem) {
                  plainTextPromise = new Promise(function (resolve) {
                    plainTextItem.getAsString(function (s) {
                      resolve(s);
                    });
                  });
                }

                _context3.next = 8;
                return reactFileUtils.dataTransferItemsToFiles(items);

              case 8:
                fileLikes = _context3.sent;

                if (!fileLikes.length) {
                  _context3.next = 12;
                  break;
                }

                uploadNewFiles(fileLikes);
                return _context3.abrupt("return");

              case 12:
                if (!plainTextPromise) {
                  _context3.next = 17;
                  break;
                }

                _context3.next = 15;
                return plainTextPromise;

              case 15:
                pastedText = _context3.sent;
                insertText(pastedText);

              case 17:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      return function (_x2) {
        return _ref10.apply(this, arguments);
      };
    })()(e);
  }, [insertText, uploadNewFiles]);
  var isUploadEnabled = (channel === null || channel === void 0 ? void 0 : (_channel$getConfig2 = channel.getConfig) === null || _channel$getConfig2 === void 0 ? void 0 : (_channel$getConfig2$c = _channel$getConfig2.call(channel)) === null || _channel$getConfig2$c === void 0 ? void 0 : _channel$getConfig2$c.uploads) !== false;
  return _objectSpread$5(_objectSpread$5({}, state), {}, {
    isUploadEnabled,
    maxFilesLeft,
    // refs
    textareaRef,
    emojiPickerRef,
    // handlers
    uploadNewFiles,
    removeImage,
    uploadImage,
    removeFile,
    uploadFile,
    onSelectEmoji,
    getUsers,
    getCommands,
    handleSubmit,
    handleChange,
    onPaste,
    onSelectItem,
    openEmojiPicker
  });
}

// @ts-check
/** @type { (emoji: import('emoji-mart').EmojiData) => boolean } */

var filterEmoji = function filterEmoji(emoji) {
  if (emoji.name === 'White Smiling Face' || emoji.name === 'White Frowning Face') {
    return false;
  }

  return true;
};
/** @type {React.FC<import("types").MessageInputEmojiPickerProps>} */


var EmojiPicker = function EmojiPicker(_ref) {
  var emojiPickerIsOpen = _ref.emojiPickerIsOpen,
      emojiPickerRef = _ref.emojiPickerRef,
      onSelectEmoji = _ref.onSelectEmoji,
      small = _ref.small;

  var _useContext = React.useContext(TranslationContext),
      t = _useContext.t;

  var _useContext2 = React.useContext(EmojiContext),
      Picker = _useContext2.EmojiPicker,
      emojiData = _useContext2.emojiData;

  if (emojiPickerIsOpen) {
    var className = small ? 'str-chat__small-message-input-emojipicker' : 'str-chat__input--emojipicker';
    return /*#__PURE__*/React__default['default'].createElement("div", {
      className: className,
      ref: emojiPickerRef
    }, Picker && /*#__PURE__*/React__default['default'].createElement(Picker, {
      native: true,
      data: emojiData,
      set: 'facebook',
      emoji: "point_up",
      title: t('Pick your emoji'),
      onSelect: onSelectEmoji,
      color: "#006CFF",
      showPreview: false,
      useButton: true,
      emojisToShowFilter: filterEmoji,
      showSkinTones: false
    }));
  }

  return null;
};

// @ts-check
/** @type {React.FC<import("types").MessageInputUploadsProps>} */

var UploadsPreview = function UploadsPreview(_ref) {
  var imageOrder = _ref.imageOrder,
      imageUploads = _ref.imageUploads,
      removeImage = _ref.removeImage,
      uploadImage = _ref.uploadImage,
      uploadNewFiles = _ref.uploadNewFiles,
      numberOfUploads = _ref.numberOfUploads,
      fileOrder = _ref.fileOrder,
      fileUploads = _ref.fileUploads,
      removeFile = _ref.removeFile,
      uploadFile = _ref.uploadFile;
  var channelContext = React.useContext(ChannelContext);
  return /*#__PURE__*/React__default['default'].createElement(React__default['default'].Fragment, null, imageOrder.length > 0 && /*#__PURE__*/React__default['default'].createElement(reactFileUtils.ImagePreviewer, {
    imageUploads: imageOrder.map(function (id) {
      return imageUploads[id];
    }),
    handleRemove: removeImage,
    handleRetry: uploadImage,
    handleFiles: uploadNewFiles,
    multiple: channelContext.multipleUploads,
    disabled: channelContext.maxNumberOfFiles !== undefined && numberOfUploads >= channelContext.maxNumberOfFiles
  }), fileOrder.length > 0 && /*#__PURE__*/React__default['default'].createElement(reactFileUtils.FilePreviewer, {
    uploads: fileOrder.map(function (id) {
      return fileUploads[id];
    }),
    handleRemove: removeFile,
    handleRetry: uploadFile,
    handleFiles: uploadNewFiles
  }));
};

/**
 * @type { React.FC }
 */

var EmojiIconLarge = function EmojiIconLarge() {
  var _useContext = React.useContext(TranslationContext),
      t = _useContext.t;

  return /*#__PURE__*/React__default['default'].createElement("svg", {
    width: "28",
    height: "28",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React__default['default'].createElement("title", null, t('Open emoji picker')), /*#__PURE__*/React__default['default'].createElement("path", {
    d: "M22.217 16.1c.483.25.674.849.423 1.334C21.163 20.294 17.771 22 14 22c-3.867 0-7.347-1.765-8.66-4.605a.994.994 0 0 1 .9-1.407c.385 0 .739.225.9.575C8.135 18.715 10.892 20 14 20c3.038 0 5.738-1.267 6.879-3.476a.99.99 0 0 1 1.338-.424zm1.583-3.652c.341.443.235 1.064-.237 1.384a1.082 1.082 0 0 1-.62.168c-.338 0-.659-.132-.858-.389-.212-.276-.476-.611-1.076-.611-.598 0-.864.337-1.08.614-.197.254-.517.386-.854.386-.224 0-.438-.045-.62-.167-.517-.349-.578-.947-.235-1.388.66-.847 1.483-1.445 2.789-1.445 1.305 0 2.136.6 2.79 1.448zm-14 0c.341.443.235 1.064-.237 1.384a1.082 1.082 0 0 1-.62.168c-.339 0-.659-.132-.858-.389C7.873 13.335 7.61 13 7.01 13c-.598 0-.864.337-1.08.614-.197.254-.517.386-.854.386-.224 0-.438-.045-.62-.167-.518-.349-.579-.947-.235-1.388C4.88 11.598 5.703 11 7.01 11c1.305 0 2.136.6 2.79 1.448zM14 0c7.732 0 14 6.268 14 14s-6.268 14-14 14S0 21.732 0 14 6.268 0 14 0zm8.485 22.485A11.922 11.922 0 0 0 26 14c0-3.205-1.248-6.219-3.515-8.485A11.922 11.922 0 0 0 14 2a11.922 11.922 0 0 0-8.485 3.515A11.922 11.922 0 0 0 2 14c0 3.205 1.248 6.219 3.515 8.485A11.922 11.922 0 0 0 14 26c3.205 0 6.219-1.248 8.485-3.515z",
    fillRule: "evenodd"
  }));
};
/**
 * @type { React.FC }
 */

var EmojiIconSmall = function EmojiIconSmall() {
  var _useContext2 = React.useContext(TranslationContext),
      t = _useContext2.t;

  return /*#__PURE__*/React__default['default'].createElement("svg", {
    width: "14",
    height: "14",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React__default['default'].createElement("title", null, t('Open emoji picker')), /*#__PURE__*/React__default['default'].createElement("path", {
    d: "M11.108 8.05a.496.496 0 0 1 .212.667C10.581 10.147 8.886 11 7 11c-1.933 0-3.673-.882-4.33-2.302a.497.497 0 0 1 .9-.417C4.068 9.357 5.446 10 7 10c1.519 0 2.869-.633 3.44-1.738a.495.495 0 0 1 .668-.212zm.792-1.826a.477.477 0 0 1-.119.692.541.541 0 0 1-.31.084.534.534 0 0 1-.428-.194c-.106-.138-.238-.306-.539-.306-.298 0-.431.168-.54.307A.534.534 0 0 1 9.538 7a.544.544 0 0 1-.31-.084.463.463 0 0 1-.117-.694c.33-.423.742-.722 1.394-.722.653 0 1.068.3 1.396.724zm-7 0a.477.477 0 0 1-.119.692.541.541 0 0 1-.31.084.534.534 0 0 1-.428-.194c-.106-.138-.238-.306-.539-.306-.299 0-.432.168-.54.307A.533.533 0 0 1 2.538 7a.544.544 0 0 1-.31-.084.463.463 0 0 1-.117-.694c.33-.423.742-.722 1.394-.722.653 0 1.068.3 1.396.724zM7 0a7 7 0 1 1 0 14A7 7 0 0 1 7 0zm4.243 11.243A5.96 5.96 0 0 0 13 7a5.96 5.96 0 0 0-1.757-4.243A5.96 5.96 0 0 0 7 1a5.96 5.96 0 0 0-4.243 1.757A5.96 5.96 0 0 0 1 7a5.96 5.96 0 0 0 1.757 4.243A5.96 5.96 0 0 0 7 13a5.96 5.96 0 0 0 4.243-1.757z",
    fillRule: "evenodd"
  }));
};
/**
 * @type { React.FC }
 */

var FileUploadIcon = function FileUploadIcon() {
  var _useContext3 = React.useContext(TranslationContext),
      t = _useContext3.t;

  return /*#__PURE__*/React__default['default'].createElement("svg", {
    width: "14",
    height: "14",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React__default['default'].createElement("title", null, t('Attach files')), /*#__PURE__*/React__default['default'].createElement("path", {
    d: "M7 .5c3.59 0 6.5 2.91 6.5 6.5s-2.91 6.5-6.5 6.5S.5 10.59.5 7 3.41.5 7 .5zm0 12c3.031 0 5.5-2.469 5.5-5.5S10.031 1.5 7 1.5A5.506 5.506 0 0 0 1.5 7c0 3.034 2.469 5.5 5.5 5.5zM7.506 3v3.494H11v1.05H7.506V11h-1.05V7.544H3v-1.05h3.456V3h1.05z",
    fillRule: "nonzero"
  }));
};
/**
 * @type { React.FC }
 */

var FileUploadIconFlat = function FileUploadIconFlat() {
  var _useContext4 = React.useContext(TranslationContext),
      t = _useContext4.t;

  return /*#__PURE__*/React__default['default'].createElement("svg", {
    width: "14",
    height: "14",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React__default['default'].createElement("title", null, t('Attach files')), /*#__PURE__*/React__default['default'].createElement("path", {
    d: "M1.667.333h10.666c.737 0 1.334.597 1.334 1.334v10.666c0 .737-.597 1.334-1.334 1.334H1.667a1.333 1.333 0 0 1-1.334-1.334V1.667C.333.93.93.333 1.667.333zm2 1.334a1.667 1.667 0 1 0 0 3.333 1.667 1.667 0 0 0 0-3.333zm-2 9.333v1.333h10.666v-4l-2-2-4 4-2-2L1.667 11z",
    fillRule: "nonzero"
  }));
};
/**
 * @type { React.FC<import('../types').SendButtonProps> }
 */

function SendButton(_ref) {
  var sendMessage = _ref.sendMessage;

  var _useContext5 = React.useContext(TranslationContext),
      t = _useContext5.t;

  return /*#__PURE__*/React__default['default'].createElement("button", {
    className: "str-chat__send-button",
    onClick: sendMessage
  }, /*#__PURE__*/React__default['default'].createElement("svg", {
    width: "18",
    height: "17",
    viewBox: "0 0 18 17",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React__default['default'].createElement("title", null, t('Send')), /*#__PURE__*/React__default['default'].createElement("path", {
    d: "M0 17.015l17.333-8.508L0 0v6.617l12.417 1.89L0 10.397z",
    fillRule: "evenodd",
    fill: "#006cff"
  })));
}

// @ts-check
/** @type {React.FC<import("types").MessageInputProps>} */

var MessageInputLarge = function MessageInputLarge(props) {
  var _props$EmojiIcon = props.EmojiIcon,
      EmojiIcon = _props$EmojiIcon === void 0 ? EmojiIconSmall : _props$EmojiIcon,
      _props$FileUploadIcon = props.FileUploadIcon,
      FileUploadIcon$1 = _props$FileUploadIcon === void 0 ? FileUploadIcon : _props$FileUploadIcon,
      _props$SendButton = props.SendButton,
      SendButton$1 = _props$SendButton === void 0 ? SendButton : _props$SendButton;
  var channelContext = React.useContext(ChannelContext);

  var _useContext = React.useContext(TranslationContext),
      t = _useContext.t;

  var messageInput = useMessageInput(props);
  /**
   * @typedef {import("stream-chat").Event} ClientEvent
   * @param {{ [userid: string]: ClientEvent } | {}} typingUsers
   */

  var constructTypingString = function constructTypingString(typingUsers) {
    var otherTypingUsers = Object.values(typingUsers).filter(function (_ref) {
      var _channelContext$clien, _channelContext$clien2;

      var user = _ref.user;
      return ((_channelContext$clien = channelContext.client) === null || _channelContext$clien === void 0 ? void 0 : (_channelContext$clien2 = _channelContext$clien.user) === null || _channelContext$clien2 === void 0 ? void 0 : _channelContext$clien2.id) !== (user === null || user === void 0 ? void 0 : user.id);
    }).map(function (_ref2) {
      var user = _ref2.user;
      return (user === null || user === void 0 ? void 0 : user.name) || (user === null || user === void 0 ? void 0 : user.id);
    });
    if (otherTypingUsers.length === 0) return '';

    if (otherTypingUsers.length === 1) {
      return t('{{ user }} is typing...', {
        user: otherTypingUsers[0]
      });
    }

    if (otherTypingUsers.length === 2) {
      // joins all with "and" but =no commas
      // example: "bob and sam"
      return t('{{ firstUser }} and {{ secondUser }} are typing...', {
        firstUser: otherTypingUsers[0],
        secondUser: otherTypingUsers[1]
      });
    } // joins all with commas, but last one gets ", and" (oxford comma!)
    // example: "bob, joe, and sam"


    return t('{{ commaSeparatedUsers }} and {{ lastUser }} are typing...', {
      commaSeparatedUsers: otherTypingUsers.slice(0, -1).join(', '),
      lastUser: otherTypingUsers[otherTypingUsers.length - 1]
    });
  };

  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__input-large"
  }, /*#__PURE__*/React__default['default'].createElement(reactFileUtils.ImageDropzone, {
    accept: channelContext.acceptedFiles,
    multiple: channelContext.multipleUploads,
    disabled: !messageInput.isUploadEnabled || messageInput.maxFilesLeft === 0,
    maxNumberOfFiles: messageInput.maxFilesLeft,
    handleFiles: messageInput.uploadNewFiles
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__input"
  }, /*#__PURE__*/React__default['default'].createElement(EmojiPicker, messageInput), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__input--textarea-wrapper"
  }, messageInput.isUploadEnabled && /*#__PURE__*/React__default['default'].createElement(UploadsPreview, messageInput), /*#__PURE__*/React__default['default'].createElement(ChatAutoComplete$1, {
    commands: messageInput.getCommands(),
    innerRef: messageInput.textareaRef,
    handleSubmit: messageInput.handleSubmit,
    onChange: messageInput.handleChange,
    onSelectItem: messageInput.onSelectItem,
    value: messageInput.text,
    rows: 1,
    maxRows: props.maxRows,
    placeholder: t('Type your message'),
    onPaste: messageInput.onPaste,
    triggers: props.autocompleteTriggers,
    grow: props.grow,
    disabled: props.disabled,
    disableMentions: props.disableMentions,
    SuggestionList: props.SuggestionList,
    additionalTextareaProps: props.additionalTextareaProps
  }), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__emojiselect-wrapper"
  }, /*#__PURE__*/React__default['default'].createElement(Tooltip$1, null, t('Open emoji picker')), /*#__PURE__*/React__default['default'].createElement("span", {
    className: "str-chat__input-emojiselect",
    onClick: messageInput.openEmojiPicker,
    ref: messageInput.emojiPickerRef
  }, /*#__PURE__*/React__default['default'].createElement(EmojiIcon, null))), messageInput.isUploadEnabled && /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__fileupload-wrapper",
    "data-testid": "fileinput"
  }, /*#__PURE__*/React__default['default'].createElement(Tooltip$1, null, messageInput.maxFilesLeft ? t('Attach files') : t("You've reached the maximum number of files")), /*#__PURE__*/React__default['default'].createElement(reactFileUtils.FileUploadButton, {
    multiple: channelContext.multipleUploads,
    disabled: messageInput.maxFilesLeft === 0,
    accepts: channelContext.acceptedFiles,
    handleFiles: messageInput.uploadNewFiles
  }, /*#__PURE__*/React__default['default'].createElement("span", {
    className: "str-chat__input-fileupload"
  }, /*#__PURE__*/React__default['default'].createElement(FileUploadIcon$1, null))))), SendButton$1 && /*#__PURE__*/React__default['default'].createElement(SendButton$1, {
    sendMessage: messageInput.handleSubmit
  })), /*#__PURE__*/React__default['default'].createElement("div", null, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__input-footer"
  }, /*#__PURE__*/React__default['default'].createElement("span", {
    className: "str-chat__input-footer--count ".concat(!channelContext.watcher_count ? 'str-chat__input-footer--count--hidden' : '')
  }, t('{{ watcherCount }} online', {
    watcherCount: channelContext.watcher_count
  })), /*#__PURE__*/React__default['default'].createElement("span", {
    className: "str-chat__input-footer--typing"
  }, constructTypingString(channelContext.typing || {}))))));
};

MessageInputLarge.propTypes = {
  /** Set focus to the text input if this is enabled */
  focus: PropTypes__default['default'].bool.isRequired,

  /** Grow the textarea while you're typing */
  grow: PropTypes__default['default'].bool.isRequired,

  /** Specify the max amount of rows the textarea is able to grow */
  maxRows: PropTypes__default['default'].number.isRequired,

  /** Make the textarea disabled */
  disabled: PropTypes__default['default'].bool,

  /** Disable mentions in textarea */
  disableMentions: PropTypes__default['default'].bool,

  /** enable/disable firing the typing event */
  publishTypingEvent: PropTypes__default['default'].bool,

  /**
   * Any additional attributes that you may want to add for underlying HTML textarea element.
   */
  additionalTextareaProps:
  /** @type {PropTypes.Validator<React.TextareaHTMLAttributes<import('../types').AnyType>>} */
  PropTypes__default['default'].object,

  /**
   * Override the default triggers of the ChatAutoComplete component
   */
  autocompleteTriggers: PropTypes__default['default'].object,

  /**
   * @param message: the Message object to be sent
   * @param cid: the channel id
   */
  overrideSubmitHandler: PropTypes__default['default'].func,

  /** Override image upload request */
  doImageUploadRequest: PropTypes__default['default'].func,

  /** Override file upload request */
  doFileUploadRequest: PropTypes__default['default'].func,

  /**
   * Custom UI component for emoji button in input.
   *
   * Defaults to and accepts same props as: [EmojiIconSmall](https://github.com/GetStream/stream-chat-react/blob/master/src/components/MessageInput/icons.js)
   * */
  EmojiIcon:
  /** @type {PropTypes.Validator<React.FC>} */
  PropTypes__default['default'].elementType,

  /**
   * Custom UI component for file upload button in input.
   *
   * Defaults to and accepts same props as: [FileUploadIcon](https://github.com/GetStream/stream-chat-react/blob/master/src/components/MessageInput/icons.js)
   * */
  FileUploadIcon:
  /** @type {PropTypes.Validator<React.FC>} */
  PropTypes__default['default'].elementType,

  /**
   * Custom UI component for send button.
   *
   * Defaults to and accepts same props as: [SendButton](https://getstream.github.io/stream-chat-react/#sendbutton)
   * */
  SendButton:
  /** @type {PropTypes.Validator<React.FC<import('../types').SendButtonProps>>} */
  PropTypes__default['default'].elementType,

  /** Optional UI component prop to override the default List component that displays suggestions */
  SuggestionList:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').SuggestionListProps>>} */
  PropTypes__default['default'].elementType
};
MessageInputLarge.defaultProps = {
  focus: false,
  disabled: false,
  publishTypingEvent: true,
  grow: true,
  maxRows: 10,
  Input: MessageInputLarge,
  additionalTextareaProps: {}
};

var MessageInput = function MessageInput(props) {
  var Input = props.Input;
  return /*#__PURE__*/React__default['default'].createElement(Input, props);
};

MessageInput.defaultProps = {
  focus: false,
  disabled: false,
  publishTypingEvent: true,
  grow: true,
  maxRows: 10,
  Input: MessageInputLarge,
  additionalTextareaProps: {}
};
var MessageInput$1 = /*#__PURE__*/React__default['default'].memo(MessageInput);

// @ts-check
/** @type {React.FC<import("types").MessageInputProps>} */

var MessageInputFlat = function MessageInputFlat(props) {
  var _props$EmojiIcon = props.EmojiIcon,
      EmojiIcon = _props$EmojiIcon === void 0 ? EmojiIconLarge : _props$EmojiIcon,
      _props$FileUploadIcon = props.FileUploadIcon,
      FileUploadIcon = _props$FileUploadIcon === void 0 ? FileUploadIconFlat : _props$FileUploadIcon,
      _props$SendButton = props.SendButton,
      SendButton$1 = _props$SendButton === void 0 ? SendButton : _props$SendButton;
  var channelContext = React.useContext(ChannelContext);

  var _useContext = React.useContext(TranslationContext),
      t = _useContext.t;

  var messageInput = useMessageInput(props);
  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__input-flat ".concat(SendButton$1 ? 'str-chat__input-flat--send-button-active' : null)
  }, /*#__PURE__*/React__default['default'].createElement(reactFileUtils.ImageDropzone, {
    accept: channelContext.acceptedFiles,
    multiple: channelContext.multipleUploads,
    disabled: !messageInput.isUploadEnabled || messageInput.maxFilesLeft === 0,
    maxNumberOfFiles: messageInput.maxFilesLeft,
    handleFiles: messageInput.uploadNewFiles
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__input-flat-wrapper"
  }, /*#__PURE__*/React__default['default'].createElement(EmojiPicker, messageInput), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__input-flat--textarea-wrapper"
  }, messageInput.isUploadEnabled && /*#__PURE__*/React__default['default'].createElement(UploadsPreview, messageInput), /*#__PURE__*/React__default['default'].createElement(ChatAutoComplete$1, {
    commands: messageInput.getCommands(),
    innerRef: messageInput.textareaRef,
    handleSubmit: messageInput.handleSubmit,
    onSelectItem: messageInput.onSelectItem,
    onChange: messageInput.handleChange,
    value: messageInput.text,
    rows: 1,
    maxRows: props.maxRows,
    placeholder: t('Type your message'),
    onPaste: messageInput.onPaste,
    triggers: props.autocompleteTriggers,
    grow: props.grow,
    disabled: props.disabled,
    disableMentions: props.disableMentions,
    SuggestionList: props.SuggestionList,
    additionalTextareaProps: props.additionalTextareaProps
  }), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__emojiselect-wrapper"
  }, /*#__PURE__*/React__default['default'].createElement(Tooltip$1, null, t('Open emoji picker')), /*#__PURE__*/React__default['default'].createElement("span", {
    className: "str-chat__input-flat-emojiselect",
    onClick: messageInput.openEmojiPicker
  }, /*#__PURE__*/React__default['default'].createElement(EmojiIcon, null))), messageInput.isUploadEnabled && /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__fileupload-wrapper",
    "data-testid": "fileinput"
  }, /*#__PURE__*/React__default['default'].createElement(Tooltip$1, null, messageInput.maxFilesLeft ? t('Attach files') : t("You've reached the maximum number of files")), /*#__PURE__*/React__default['default'].createElement(reactFileUtils.FileUploadButton, {
    multiple: channelContext.multipleUploads,
    disabled: messageInput.maxFilesLeft === 0,
    accepts: channelContext.acceptedFiles,
    handleFiles: messageInput.uploadNewFiles
  }, /*#__PURE__*/React__default['default'].createElement("span", {
    className: "str-chat__input-flat-fileupload"
  }, /*#__PURE__*/React__default['default'].createElement(FileUploadIcon, null))))), SendButton$1 && /*#__PURE__*/React__default['default'].createElement(SendButton$1, {
    sendMessage: messageInput.handleSubmit
  }))));
};

MessageInputFlat.propTypes = {
  /** Set focus to the text input if this is enabled */
  focus: PropTypes__default['default'].bool.isRequired,

  /** Grow the textarea while you're typing */
  grow: PropTypes__default['default'].bool.isRequired,

  /** Specify the max amount of rows the textarea is able to grow */
  maxRows: PropTypes__default['default'].number.isRequired,

  /** Make the textarea disabled */
  disabled: PropTypes__default['default'].bool,

  /** Disable mentions in textarea */
  disableMentions: PropTypes__default['default'].bool,

  /** enable/disable firing the typing event */
  publishTypingEvent: PropTypes__default['default'].bool,

  /**
   * Any additional attributes that you may want to add for underlying HTML textarea element.
   */
  additionalTextareaProps:
  /** @type {PropTypes.Validator<React.TextareaHTMLAttributes<import('../types').AnyType>>} */
  PropTypes__default['default'].object,

  /**
   * Override the default triggers of the ChatAutoComplete component
   */
  autocompleteTriggers: PropTypes__default['default'].object,

  /**
   * @param message: the Message object to be sent
   * @param cid: the channel id
   */
  overrideSubmitHandler: PropTypes__default['default'].func,

  /** Override image upload request */
  doImageUploadRequest: PropTypes__default['default'].func,

  /** Override file upload request */
  doFileUploadRequest: PropTypes__default['default'].func,

  /**
   * Custom UI component for emoji button in input.
   *
   * Defaults to and accepts same props as: [EmojiIconLarge](https://github.com/GetStream/stream-chat-react/blob/master/src/components/MessageInput/icons.js)
   * */
  EmojiIcon:
  /** @type {PropTypes.Validator<React.FC>} */
  PropTypes__default['default'].elementType,

  /**
   * Custom UI component for file upload button in input.
   *
   * Defaults to and accepts same props as: [FileUploadIconFlat](https://github.com/GetStream/stream-chat-react/blob/master/src/components/MessageInput/icons.js)
   * */
  FileUploadIcon:
  /** @type {PropTypes.Validator<React.FC>} */
  PropTypes__default['default'].elementType,

  /**
   * Custom UI component for send button.
   *
   * Defaults to and accepts same props as: [SendButton](https://getstream.github.io/stream-chat-react/#sendbutton)
   * */
  SendButton:
  /** @type {PropTypes.Validator<React.FC<import('../types').SendButtonProps>>} */
  PropTypes__default['default'].elementType,

  /** Optional UI component prop to override the default List component that displays suggestions */
  SuggestionList:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').SuggestionListProps>>} */
  PropTypes__default['default'].elementType
};
MessageInputFlat.defaultProps = {
  focus: false,
  disabled: false,
  publishTypingEvent: true,
  grow: true,
  maxRows: 10,
  additionalTextareaProps: {}
};

/** @type {React.FC<import("types").MessageInputProps>} */

var MessageInputSmall = function MessageInputSmall(props) {
  var _props$EmojiIcon = props.EmojiIcon,
      EmojiIcon = _props$EmojiIcon === void 0 ? EmojiIconSmall : _props$EmojiIcon,
      _props$FileUploadIcon = props.FileUploadIcon,
      FileUploadIcon$1 = _props$FileUploadIcon === void 0 ? FileUploadIcon : _props$FileUploadIcon,
      _props$SendButton = props.SendButton,
      SendButton$1 = _props$SendButton === void 0 ? SendButton : _props$SendButton;
  var channelContext = React.useContext(ChannelContext);

  var _useContext = React.useContext(TranslationContext),
      t = _useContext.t;

  var messageInput = useMessageInput(props);
  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__small-message-input__wrapper"
  }, /*#__PURE__*/React__default['default'].createElement(reactFileUtils.ImageDropzone, {
    accept: channelContext.acceptedFiles,
    multiple: channelContext.multipleUploads,
    disabled: !messageInput.isUploadEnabled || messageInput.maxFilesLeft === 0,
    maxNumberOfFiles: messageInput.maxFilesLeft,
    handleFiles: messageInput.uploadNewFiles
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__small-message-input ".concat(SendButton$1 ? 'str-chat__small-message-input--send-button-active' : null)
  }, /*#__PURE__*/React__default['default'].createElement(EmojiPicker, _extends__default['default']({}, messageInput, {
    small: true
  })), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__small-message-input--textarea-wrapper"
  }, messageInput.isUploadEnabled && /*#__PURE__*/React__default['default'].createElement(UploadsPreview, messageInput), /*#__PURE__*/React__default['default'].createElement(ChatAutoComplete$1, {
    commands: messageInput.getCommands(),
    innerRef: messageInput.textareaRef,
    handleSubmit: messageInput.handleSubmit,
    onChange: messageInput.handleChange,
    value: messageInput.text,
    rows: 1,
    maxRows: props.maxRows,
    onSelectItem: messageInput.onSelectItem,
    placeholder: t('Type your message'),
    onPaste: messageInput.onPaste,
    triggers: props.autocompleteTriggers,
    grow: props.grow,
    disabled: props.disabled,
    disableMentions: props.disableMentions,
    SuggestionList: props.SuggestionList,
    additionalTextareaProps: props.additionalTextareaProps
  }), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__emojiselect-wrapper"
  }, /*#__PURE__*/React__default['default'].createElement(Tooltip$1, null, t('Open emoji picker')), /*#__PURE__*/React__default['default'].createElement("span", {
    className: "str-chat__small-message-input-emojiselect",
    onClick: messageInput.openEmojiPicker
  }, /*#__PURE__*/React__default['default'].createElement(EmojiIcon, null))), messageInput.isUploadEnabled && /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__fileupload-wrapper",
    "data-testid": "fileinput"
  }, /*#__PURE__*/React__default['default'].createElement(Tooltip$1, null, messageInput.maxFilesLeft ? t('Attach files') : t("You've reached the maximum number of files")), /*#__PURE__*/React__default['default'].createElement(reactFileUtils.FileUploadButton, {
    multiple: channelContext.multipleUploads,
    disabled: messageInput.maxFilesLeft === 0,
    accepts: channelContext.acceptedFiles,
    handleFiles: messageInput.uploadNewFiles
  }, /*#__PURE__*/React__default['default'].createElement("span", {
    className: "str-chat__small-message-input-fileupload"
  }, /*#__PURE__*/React__default['default'].createElement(FileUploadIcon$1, null))))), SendButton$1 && /*#__PURE__*/React__default['default'].createElement(SendButton$1, {
    sendMessage: messageInput.handleSubmit
  }))));
};

MessageInputSmall.propTypes = {
  /** Set focus to the text input if this is enabled */
  focus: PropTypes__default['default'].bool.isRequired,

  /** Grow the textarea while you're typing */
  grow: PropTypes__default['default'].bool.isRequired,

  /** Specify the max amount of rows the textarea is able to grow */
  maxRows: PropTypes__default['default'].number.isRequired,

  /** Make the textarea disabled */
  disabled: PropTypes__default['default'].bool,

  /** Disable mentions in textarea */
  disableMentions: PropTypes__default['default'].bool,

  /** enable/disable firing the typing event */
  publishTypingEvent: PropTypes__default['default'].bool,

  /**
   * Any additional attributes that you may want to add for underlying HTML textarea element.
   */
  additionalTextareaProps:
  /** @type {PropTypes.Validator<React.TextareaHTMLAttributes<import('../types').AnyType>>} */
  PropTypes__default['default'].object,

  /**
   * Override the default triggers of the ChatAutoComplete component
   */
  autocompleteTriggers: PropTypes__default['default'].object,

  /**
   * @param message: the Message object to be sent
   * @param cid: the channel id
   */
  overrideSubmitHandler: PropTypes__default['default'].func,

  /** Override image upload request */
  doImageUploadRequest: PropTypes__default['default'].func,

  /** Override file upload request */
  doFileUploadRequest: PropTypes__default['default'].func,

  /**
   * Custom UI component for emoji button in input.
   *
   * Defaults to and accepts same props as: [EmojiIconSmall](https://github.com/GetStream/stream-chat-react/blob/master/src/components/MessageInput/icons.js)
   * */
  EmojiIcon:
  /** @type {PropTypes.Validator<React.FC>} */
  PropTypes__default['default'].elementType,

  /**
   * Custom UI component for file upload button in input.
   *
   * Defaults to and accepts same props as: [FileUploadIcon](https://github.com/GetStream/stream-chat-react/blob/master/src/components/MessageInput/icons.js)
   * */
  FileUploadIcon:
  /** @type {PropTypes.Validator<React.FC>} */
  PropTypes__default['default'].elementType,

  /**
   * Custom UI component for send button.
   *
   * Defaults to and accepts same props as: [SendButton](https://getstream.github.io/stream-chat-react/#sendbutton)
   * */
  SendButton:
  /** @type {PropTypes.Validator<React.FC<import('../types').SendButtonProps>>} */
  PropTypes__default['default'].elementType,

  /** Optional UI component prop to override the default List component that displays suggestions */
  SuggestionList:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').SuggestionListProps>>} */
  PropTypes__default['default'].elementType
};
MessageInputSmall.defaultProps = {
  focus: false,
  disabled: false,
  publishTypingEvent: true,
  grow: true,
  maxRows: 10,
  additionalTextareaProps: {}
};

// @ts-check
/** @type {React.FC<import("types").MessageInputProps>} */

var MessageInputSimple = function MessageInputSimple(props) {
  var _props$EmojiIcon = props.EmojiIcon,
      EmojiIcon = _props$EmojiIcon === void 0 ? EmojiIconLarge : _props$EmojiIcon,
      _props$SendButton = props.SendButton,
      SendButton$1 = _props$SendButton === void 0 ? SendButton : _props$SendButton;

  var _useContext = React.useContext(TranslationContext),
      t = _useContext.t;

  var messageInput = useMessageInput(props);
  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__input-flat ".concat(SendButton$1 ? 'str-chat__input-flat--send-button-active' : null)
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__input-flat-wrapper"
  }, /*#__PURE__*/React__default['default'].createElement(EmojiPicker, messageInput), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__input-flat--textarea-wrapper"
  }, /*#__PURE__*/React__default['default'].createElement(ChatAutoComplete$1, {
    commands: messageInput.getCommands(),
    innerRef: messageInput.textareaRef,
    handleSubmit: messageInput.handleSubmit,
    onSelectItem: messageInput.onSelectItem,
    onChange: messageInput.handleChange,
    value: messageInput.text,
    rows: 1,
    maxRows: props.maxRows,
    placeholder: t('Type your message'),
    onPaste: messageInput.onPaste,
    triggers: props.autocompleteTriggers,
    grow: props.grow,
    disabled: props.disabled,
    disableMentions: props.disableMentions,
    SuggestionList: props.SuggestionList,
    additionalTextareaProps: props.additionalTextareaProps
  }), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__emojiselect-wrapper"
  }, /*#__PURE__*/React__default['default'].createElement(Tooltip$1, null, t('Open emoji picker')), /*#__PURE__*/React__default['default'].createElement("span", {
    className: "str-chat__input-flat-emojiselect",
    onClick: messageInput.openEmojiPicker
  }, /*#__PURE__*/React__default['default'].createElement(EmojiIcon, null)))), SendButton$1 && /*#__PURE__*/React__default['default'].createElement(SendButton$1, {
    sendMessage: messageInput.handleSubmit
  })));
};

MessageInputSimple.propTypes = {
  /** Set focus to the text input if this is enabled */
  focus: PropTypes__default['default'].bool.isRequired,

  /** Grow the textarea while you're typing */
  grow: PropTypes__default['default'].bool.isRequired,

  /** Specify the max amount of rows the textarea is able to grow */
  maxRows: PropTypes__default['default'].number.isRequired,

  /** Make the textarea disabled */
  disabled: PropTypes__default['default'].bool,

  /** Disable mentions in textarea */
  disableMentions: PropTypes__default['default'].bool,

  /** enable/disable firing the typing event */
  publishTypingEvent: PropTypes__default['default'].bool,

  /**
   * Any additional attributes that you may want to add for underlying HTML textarea element.
   */
  additionalTextareaProps:
  /** @type {PropTypes.Validator<React.TextareaHTMLAttributes<import('../types').AnyType>>} */
  PropTypes__default['default'].object,

  /**
   * Override the default triggers of the ChatAutoComplete component
   */
  autocompleteTriggers: PropTypes__default['default'].object,

  /**
   * @param message: the Message object to be sent
   * @param cid: the channel id
   */
  overrideSubmitHandler: PropTypes__default['default'].func,

  /** Override image upload request */
  doImageUploadRequest: PropTypes__default['default'].func,

  /** Override file upload request */
  doFileUploadRequest: PropTypes__default['default'].func,

  /**
   * Custom UI component for emoji button in input.
   *
   * Defaults to and accepts same props as: [EmojiIconLarge](https://github.com/GetStream/stream-chat-react/blob/master/src/components/MessageInput/icons.js)
   * */
  EmojiIcon:
  /** @type {PropTypes.Validator<React.FC>} */
  PropTypes__default['default'].elementType,

  /**
   * Custom UI component for send button.
   *
   * Defaults to and accepts same props as: [SendButton](https://getstream.github.io/stream-chat-react/#sendbutton)
   * */
  SendButton:
  /** @type {PropTypes.Validator<React.FC<import('../types').SendButtonProps>>} */
  PropTypes__default['default'].elementType,

  /** Optional UI component prop to override the default List component that displays suggestions */
  SuggestionList:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').SuggestionListProps>>} */
  PropTypes__default['default'].elementType
};
MessageInputSimple.defaultProps = {
  focus: false,
  disabled: false,
  publishTypingEvent: true,
  grow: true,
  maxRows: 10,
  additionalTextareaProps: {}
};

/** @type {React.FC<import("types").MessageInputProps>} */

var EditMessageForm = function EditMessageForm(props) {
  var clearEditingState = props.clearEditingState,
      _props$EmojiIcon = props.EmojiIcon,
      EmojiIcon = _props$EmojiIcon === void 0 ? EmojiIconSmall : _props$EmojiIcon,
      _props$FileUploadIcon = props.FileUploadIcon,
      FileUploadIcon$1 = _props$FileUploadIcon === void 0 ? FileUploadIcon : _props$FileUploadIcon;
  var channelContext = React.useContext(ChannelContext);

  var _useContext = React.useContext(TranslationContext),
      t = _useContext.t;

  var messageInput = useMessageInput(props);
  React.useEffect(function () {
    /** @type {(event: KeyboardEvent) => void} Typescript syntax */
    var onKeyDown = function onKeyDown(event) {
      if (event.keyCode === KEY_CODES.ESC && clearEditingState) clearEditingState();
    };

    document.addEventListener('keydown', onKeyDown);
    return function () {
      return document.removeEventListener('keydown', onKeyDown);
    };
  }, [clearEditingState]);
  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__edit-message-form"
  }, /*#__PURE__*/React__default['default'].createElement(reactFileUtils.ImageDropzone, {
    accept: channelContext.acceptedFiles,
    multiple: channelContext.multipleUploads,
    disabled: !messageInput.isUploadEnabled || messageInput.maxFilesLeft === 0,
    maxNumberOfFiles: messageInput.maxFilesLeft,
    handleFiles: messageInput.uploadNewFiles
  }, /*#__PURE__*/React__default['default'].createElement("form", {
    onSubmit: messageInput.handleSubmit
  }, messageInput.isUploadEnabled && /*#__PURE__*/React__default['default'].createElement(UploadsPreview, messageInput), /*#__PURE__*/React__default['default'].createElement(EmojiPicker, _extends__default['default']({}, messageInput, {
    small: true
  })), /*#__PURE__*/React__default['default'].createElement(ChatAutoComplete$1, {
    commands: messageInput.getCommands(),
    innerRef: messageInput.textareaRef,
    handleSubmit: messageInput.handleSubmit,
    onChange: messageInput.handleChange,
    onSelectItem: messageInput.onSelectItem,
    placeholder: t('Type your message'),
    value: messageInput.text,
    rows: 1,
    maxRows: props.maxRows,
    onPaste: messageInput.onPaste,
    grow: props.grow,
    additionalTextareaProps: props.additionalTextareaProps
  }), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__message-team-form-footer"
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__edit-message-form-options"
  }, /*#__PURE__*/React__default['default'].createElement("span", {
    className: "str-chat__input-emojiselect",
    onClick: messageInput.openEmojiPicker
  }, /*#__PURE__*/React__default['default'].createElement(EmojiIcon, null)), messageInput.isUploadEnabled && /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__fileupload-wrapper",
    "data-testid": "fileinput"
  }, /*#__PURE__*/React__default['default'].createElement(Tooltip$1, null, messageInput.maxFilesLeft ? t('Attach files') : t("You've reached the maximum number of files")), /*#__PURE__*/React__default['default'].createElement(reactFileUtils.FileUploadButton, {
    multiple: channelContext.multipleUploads,
    disabled: messageInput.maxFilesLeft === 0,
    accepts: channelContext.acceptedFiles,
    handleFiles: messageInput.uploadNewFiles
  }, /*#__PURE__*/React__default['default'].createElement("span", {
    className: "str-chat__input-fileupload"
  }, /*#__PURE__*/React__default['default'].createElement(FileUploadIcon$1, null))))), /*#__PURE__*/React__default['default'].createElement("div", null, /*#__PURE__*/React__default['default'].createElement("button", {
    onClick: props.clearEditingState
  }, t('Cancel')), /*#__PURE__*/React__default['default'].createElement("button", {
    type: "submit"
  }, t('Send')))))));
};

EditMessageForm.propTypes = {
  /** Set focus to the text input if this is enabled */
  focus: PropTypes__default['default'].bool.isRequired,

  /** Grow the textarea while you're typing */
  grow: PropTypes__default['default'].bool.isRequired,

  /** Specify the max amount of rows the textarea is able to grow */
  maxRows: PropTypes__default['default'].number.isRequired,

  /** Make the textarea disabled */
  disabled: PropTypes__default['default'].bool,

  /** enable/disable firing the typing event */
  publishTypingEvent: PropTypes__default['default'].bool,

  /**
   * Any additional attrubutes that you may want to add for underlying HTML textarea element.
   */
  additionalTextareaProps: PropTypes__default['default'].object,

  /**
   * @param message: the Message object to be sent
   * @param cid: the channel id
   */
  overrideSubmitHandler: PropTypes__default['default'].func,

  /** Override image upload request */
  doImageUploadRequest: PropTypes__default['default'].func,

  /** Override file upload request */
  doFileUploadRequest: PropTypes__default['default'].func,

  /**
   * Custom UI component for emoji button in input.
   *
   * Defaults to and accepts same props as: [EmojiIconSmall](https://github.com/GetStream/stream-chat-react/blob/master/src/components/MessageInput/icons.js)
   * */
  EmojiIcon:
  /** @type {PropTypes.Validator<React.FC>} */
  PropTypes__default['default'].elementType,

  /**
   * Custom UI component for file upload button in input.
   *
   * Defaults to and accepts same props as: [FileUploadIcon](https://github.com/GetStream/stream-chat-react/blob/master/src/components/MessageInput/icons.js)
   * */
  FileUploadIcon:
  /** @type {PropTypes.Validator<React.FC>} */
  PropTypes__default['default'].elementType,

  /**
   * Custom UI component for send button.
   *
   * Defaults to and accepts same props as: [SendButton](https://getstream.github.io/stream-chat-react/#sendbutton)
   * */
  SendButton:
  /** @type {PropTypes.Validator<React.FC<import('../types').SendButtonProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * Clears edit state for current message (passed down from message component)
   */
  clearEditingState: PropTypes__default['default'].func
};
EditMessageForm.defaultProps = {
  focus: false,
  disabled: false,
  publishTypingEvent: true,
  grow: true,
  maxRows: 10,
  additionalTextareaProps: {}
};

/** @type {React.ForwardRefRenderFunction<HTMLDivElement | null, import("types").ReactionSelectorProps>} */

var ReactionSelectorWithRef = function ReactionSelectorWithRef(_ref, ref) {
  var _getUsersPerReactionT;

  var _ref$Avatar = _ref.Avatar,
      Avatar$1 = _ref$Avatar === void 0 ? Avatar : _ref$Avatar,
      latest_reactions = _ref.latest_reactions,
      reaction_counts = _ref.reaction_counts,
      reactionOptionsProp = _ref.reactionOptions,
      _ref$reverse = _ref.reverse,
      reverse = _ref$reverse === void 0 ? false : _ref$reverse,
      handleReaction = _ref.handleReaction,
      _ref$detailedView = _ref.detailedView,
      detailedView = _ref$detailedView === void 0 ? true : _ref$detailedView;

  var _useContext = React.useContext(EmojiContext),
      Emoji = _useContext.Emoji,
      defaultMinimalEmojis = _useContext.defaultMinimalEmojis,
      fullEmojiData = _useContext.emojiData,
      emojiSetDef = _useContext.emojiSetDef;

  var emojiData = getStrippedEmojiData(fullEmojiData);
  var reactionOptions = reactionOptionsProp || defaultMinimalEmojis;

  var _useState = React.useState(null),
      _useState2 = _slicedToArray__default['default'](_useState, 2),
      tooltipReactionType = _useState2[0],
      setTooltipReactionType = _useState2[1];

  var _useState3 = React.useState(
  /** @type {{ tooltip: number, arrow: number } | null} */
  null),
      _useState4 = _slicedToArray__default['default'](_useState3, 2),
      tooltipPositions = _useState4[0],
      setTooltipPositions = _useState4[1];

  var containerRef = React.useRef(
  /** @type {HTMLDivElement | null} */
  null);
  var tooltipRef = React.useRef(
  /** @type {HTMLDivElement | null} */
  null);
  var targetRef = React.useRef(
  /** @type {HTMLDivElement | null} */
  null); // @ts-ignore because it's okay for our ref to be null in the parent component.

  React.useImperativeHandle(ref, function () {
    return containerRef.current;
  });
  var showTooltip = React.useCallback(function (e, reactionType) {
    targetRef.current = e.target;
    setTooltipReactionType(reactionType);
  }, []);
  var hideTooltip = React.useCallback(function () {
    setTooltipReactionType(null);
    setTooltipPositions(null);
  }, []);
  React.useEffect(function () {
    if (tooltipReactionType) {
      var _tooltipRef$current, _targetRef$current, _containerRef$current;

      var tooltip = (_tooltipRef$current = tooltipRef.current) === null || _tooltipRef$current === void 0 ? void 0 : _tooltipRef$current.getBoundingClientRect();
      var target = (_targetRef$current = targetRef.current) === null || _targetRef$current === void 0 ? void 0 : _targetRef$current.getBoundingClientRect();
      var container = (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.getBoundingClientRect();
      if (!tooltip || !target || !container) return;
      var tooltipPosition = tooltip.width === container.width || tooltip.x < container.x ? 0 : target.left + target.width / 2 - container.left - tooltip.width / 2;
      var arrowPosition = target.x - tooltip.x + target.width / 2 - tooltipPosition;
      setTooltipPositions({
        tooltip: tooltipPosition,
        arrow: arrowPosition
      });
    }
  }, [tooltipReactionType, containerRef]);
  /**
   * @param {string | null} type
   * @returns {string[] | undefined}
   * */

  var getUsersPerReactionType = function getUsersPerReactionType(type) {
    return (
      /** @type {string[] | undefined} */
      latest_reactions === null || latest_reactions === void 0 ? void 0 : latest_reactions.map(function (reaction) {
        if (reaction.type === type) {
          var _reaction$user, _reaction$user2;

          return ((_reaction$user = reaction.user) === null || _reaction$user === void 0 ? void 0 : _reaction$user.name) || ((_reaction$user2 = reaction.user) === null || _reaction$user2 === void 0 ? void 0 : _reaction$user2.id);
        }

        return null;
      }).filter(Boolean)
    );
  };
  /**
   * @param {string | null} type
   * @returns {import("types").StreamChatReactClient['user'] | undefined}
   * */


  var getLatestUserForReactionType = function getLatestUserForReactionType(type) {
    var _latest_reactions$fin;

    return (latest_reactions === null || latest_reactions === void 0 ? void 0 : (_latest_reactions$fin = latest_reactions.find(function (reaction) {
      return reaction.type === type && !!reaction.user;
    })) === null || _latest_reactions$fin === void 0 ? void 0 : _latest_reactions$fin.user) || undefined;
  };

  return /*#__PURE__*/React__default['default'].createElement("div", {
    "data-testid": "reaction-selector",
    className: "str-chat__reaction-selector ".concat(reverse ? 'str-chat__reaction-selector--reverse' : ''),
    ref: containerRef
  }, !!tooltipReactionType && detailedView && /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__reaction-selector-tooltip",
    ref: tooltipRef,
    style: {
      left: tooltipPositions === null || tooltipPositions === void 0 ? void 0 : tooltipPositions.tooltip,
      visibility: tooltipPositions ? 'visible' : 'hidden'
    }
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "arrow",
    style: {
      left: tooltipPositions === null || tooltipPositions === void 0 ? void 0 : tooltipPositions.arrow
    }
  }), (_getUsersPerReactionT = getUsersPerReactionType(tooltipReactionType)) === null || _getUsersPerReactionT === void 0 ? void 0 : _getUsersPerReactionT.map(function (user, i, users) {
    return /*#__PURE__*/React__default['default'].createElement("span", {
      className: "latest-user-username",
      key: "key-".concat(i, "-").concat(user)
    }, "".concat(user).concat(i < users.length - 1 ? ', ' : ''));
  })), /*#__PURE__*/React__default['default'].createElement("ul", {
    className: "str-chat__message-reactions-list"
  }, reactionOptions.map(function (reactionOption) {
    var latestUser = getLatestUserForReactionType(reactionOption.id);
    var count = reaction_counts && reaction_counts[reactionOption.id];
    return /*#__PURE__*/React__default['default'].createElement("li", {
      key: "item-".concat(reactionOption.id),
      className: "str-chat__message-reactions-list-item",
      "data-text": reactionOption.id,
      onClick: function onClick() {
        return handleReaction && handleReaction(reactionOption.id);
      }
    }, !!count && detailedView && /*#__PURE__*/React__default['default'].createElement(React__default['default'].Fragment, null, /*#__PURE__*/React__default['default'].createElement("div", {
      className: "latest-user",
      onMouseEnter: function onMouseEnter(e) {
        return showTooltip(e, reactionOption.id);
      },
      onMouseLeave: hideTooltip
    }, latestUser ? /*#__PURE__*/React__default['default'].createElement(Avatar$1, {
      image: latestUser.image,
      size: 20,
      name: latestUser.name
    }) : /*#__PURE__*/React__default['default'].createElement("div", {
      className: "latest-user-not-found"
    }))), Emoji && /*#__PURE__*/React__default['default'].createElement(Emoji // @ts-ignore because emoji-mart types don't support specifying
    // spriteUrl instead of imageUrl, while the implementation does
    , _extends__default['default']({
      emoji: reactionOption
    }, emojiSetDef, {
      data: emojiData
    })), Boolean(count) && detailedView && /*#__PURE__*/React__default['default'].createElement("span", {
      className: "str-chat__message-reactions-list-item__count"
    }, count || ''));
  })));
};

var ReactionSelector = /*#__PURE__*/React__default['default'].forwardRef(ReactionSelectorWithRef);
ReactionSelector.propTypes = {
  /**
   * Custom UI component to display user avatar
   *
   * Defaults to and accepts same props as: [Avatar](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Avatar/Avatar.js)
   * */
  Avatar:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').AvatarProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * Array of latest reactions.
   * Reaction object has following structure:
   *
   * ```json
   * {
   *  "type": "love",
   *  "user_id": "demo_user_id",
   *  "user": {
   *    ...userObject
   *  },
   *  "created_at": "datetime";
   * }
   * ```
   * */
  latest_reactions: PropTypes__default['default'].array,

  /** Object/map of reaction id/type (e.g. 'like' | 'love' | 'haha' | 'wow' | 'sad' | 'angry') vs count */
  reaction_counts: PropTypes__default['default'].objectOf(PropTypes__default['default'].number.isRequired),

  /** Provide a list of reaction options [{id: 'angry', emoji: 'angry'}] */
  reactionOptions: PropTypes__default['default'].array,
  reverse: PropTypes__default['default'].bool,

  /**
   * Handler to set/unset reaction on message.
   *
   * @param type e.g. 'like' | 'love' | 'haha' | 'wow' | 'sad' | 'angry'
   * */
  handleReaction: PropTypes__default['default'].func.isRequired,

  /** Enable the avatar display */
  detailedView: PropTypes__default['default'].bool
};
var DefaultReactionSelector = /*#__PURE__*/React__default['default'].memo(ReactionSelector);

/** @type {React.FC<import("types").ReactionsListProps>} */

var ReactionsList = function ReactionsList(_ref) {
  var reactions = _ref.reactions,
      reaction_counts = _ref.reaction_counts,
      reactionOptionsProp = _ref.reactionOptions,
      _ref$reverse = _ref.reverse,
      reverse = _ref$reverse === void 0 ? false : _ref$reverse,
      onClick = _ref.onClick;

  var _useContext = React.useContext(EmojiContext),
      fullEmojiData = _useContext.emojiData,
      emojiSetDef = _useContext.emojiSetDef,
      defaultMinimalEmojis = _useContext.defaultMinimalEmojis,
      Emoji = _useContext.Emoji;

  var emojiData = React.useMemo(function () {
    return getStrippedEmojiData(fullEmojiData);
  }, [fullEmojiData]);
  var reactionOptions = reactionOptionsProp || defaultMinimalEmojis;

  var getTotalReactionCount = function getTotalReactionCount() {
    return Object.values(reaction_counts || {}).reduce(function (total, count) {
      return total + count;
    }, 0);
  };
  /** @param {string} type */


  var getOptionForType = function getOptionForType(type) {
    return reactionOptions.find(function (option) {
      return option.id === type;
    });
  };

  var getReactionTypes = function getReactionTypes() {
    if (!reactions) return [];
    var allTypes = new Set();
    reactions.forEach(function (_ref2) {
      var type = _ref2.type;
      allTypes.add(type);
    });
    return Array.from(allTypes);
  };

  return /*#__PURE__*/React__default['default'].createElement("div", {
    "data-testid": "reaction-list",
    className: "str-chat__reaction-list ".concat(reverse ? 'str-chat__reaction-list--reverse' : ''),
    onClick: onClick
  }, /*#__PURE__*/React__default['default'].createElement("ul", null, getReactionTypes().map(function (reactionType) {
    var emojiDefinition = getOptionForType(reactionType);
    return emojiDefinition ? /*#__PURE__*/React__default['default'].createElement("li", {
      key: emojiDefinition.id
    }, Emoji && /*#__PURE__*/React__default['default'].createElement(Emoji // emoji-mart type defs don't support spriteSheet use case
    // (but implementation does)
    // @ts-ignore
    , _extends__default['default']({
      emoji: emojiDefinition
    }, emojiSetDef, {
      size: 16,
      data: emojiData
    })), "$", ' ') : null;
  }), /*#__PURE__*/React__default['default'].createElement("li", null, /*#__PURE__*/React__default['default'].createElement("span", {
    className: "str-chat__reaction-list--counter"
  }, getTotalReactionCount()))));
};

ReactionsList.propTypes = {
  reactions: PropTypes__default['default'].array,

  /** Object/map of reaction id/type (e.g. 'like' | 'love' | 'haha' | 'wow' | 'sad' | 'angry') vs count */
  reaction_counts: PropTypes__default['default'].objectOf(PropTypes__default['default'].number.isRequired),

  /** Provide a list of reaction options [{id: 'angry', emoji: 'angry'}] */
  reactionOptions: PropTypes__default['default'].array,
  reverse: PropTypes__default['default'].bool,
  onClick: PropTypes__default['default'].func
};
var DefaultReactionsList = /*#__PURE__*/React__default['default'].memo(ReactionsList);

/** @type {React.FC<import("types").SimpleReactionsListProps>} */

var SimpleReactionsList = function SimpleReactionsList(_ref) {
  var reactions = _ref.reactions,
      reaction_counts = _ref.reaction_counts,
      reactionOptionsProp = _ref.reactionOptions,
      handleReaction = _ref.handleReaction;

  var _useContext = React.useContext(EmojiContext),
      defaultMinimalEmojis = _useContext.defaultMinimalEmojis,
      Emoji = _useContext.Emoji,
      emojiSetDef = _useContext.emojiSetDef,
      defaultEmojiData = _useContext.emojiData;

  var emojiData = getStrippedEmojiData(defaultEmojiData);

  var _useState = React.useState(null),
      _useState2 = _slicedToArray__default['default'](_useState, 2),
      tooltipReactionType = _useState2[0],
      setTooltipReactionType = _useState2[1];
  /** @type{import('../types').MinimalEmojiInterface[]} */


  var reactionOptions = reactionOptionsProp || defaultMinimalEmojis;

  if (!reactions || reactions.length === 0) {
    return null;
  }
  /** @param {string | null} type */


  var getUsersPerReactionType = function getUsersPerReactionType(type) {
    return reactions === null || reactions === void 0 ? void 0 : reactions.map(function (reaction) {
      if (reaction.type === type) {
        var _reaction$user, _reaction$user2;

        return ((_reaction$user = reaction.user) === null || _reaction$user === void 0 ? void 0 : _reaction$user.name) || ((_reaction$user2 = reaction.user) === null || _reaction$user2 === void 0 ? void 0 : _reaction$user2.id);
      }

      return null;
    }).filter(Boolean);
  };

  var getTotalReactionCount = function getTotalReactionCount() {
    return Object.values(reaction_counts || {}).reduce(function (total, count) {
      return total + count;
    }, 0);
  };

  var getReactionTypes = function getReactionTypes() {
    if (!reactions) return [];
    var allTypes = new Set();
    reactions.forEach(function (_ref2) {
      var type = _ref2.type;
      allTypes.add(type);
    });
    return Array.from(allTypes);
  };
  /** @param {string} type */


  var getOptionForType = function getOptionForType(type) {
    return reactionOptions.find(function (option) {
      return option.id === type;
    });
  };

  return /*#__PURE__*/React__default['default'].createElement("ul", {
    "data-testid": "simple-reaction-list",
    className: "str-chat__simple-reactions-list",
    onMouseLeave: function onMouseLeave() {
      return setTooltipReactionType(null);
    }
  }, getReactionTypes().map(function (reactionType, i) {
    var _getOptionForType, _getUsersPerReactionT;

    var emojiDefinition = getOptionForType(reactionType);
    return emojiDefinition ? /*#__PURE__*/React__default['default'].createElement("li", {
      className: "str-chat__simple-reactions-list-item",
      key: "".concat(emojiDefinition === null || emojiDefinition === void 0 ? void 0 : emojiDefinition.id, "-").concat(i),
      onClick: function onClick() {
        return handleReaction && handleReaction(reactionType);
      }
    }, /*#__PURE__*/React__default['default'].createElement("span", {
      onMouseEnter: function onMouseEnter() {
        return setTooltipReactionType(reactionType);
      }
    }, Emoji && /*#__PURE__*/React__default['default'].createElement(Emoji // emoji-mart type defs don't support spriteSheet use case
    // (but implementation does)
    // @ts-ignore
    , _extends__default['default']({
      emoji: emojiDefinition
    }, emojiSetDef, {
      size: 13,
      data: emojiData
    })), "\xA0"), tooltipReactionType === ((_getOptionForType = getOptionForType(reactionType)) === null || _getOptionForType === void 0 ? void 0 : _getOptionForType.id) && /*#__PURE__*/React__default['default'].createElement("div", {
      className: "str-chat__simple-reactions-list-tooltip"
    }, /*#__PURE__*/React__default['default'].createElement("div", {
      className: "arrow"
    }), (_getUsersPerReactionT = getUsersPerReactionType(tooltipReactionType)) === null || _getUsersPerReactionT === void 0 ? void 0 : _getUsersPerReactionT.join(', '))) : null;
  }), (reactions === null || reactions === void 0 ? void 0 : reactions.length) !== 0 && /*#__PURE__*/React__default['default'].createElement("li", {
    className: "str-chat__simple-reactions-list-item--last-number"
  }, getTotalReactionCount()));
};

SimpleReactionsList.propTypes = {
  reactions: PropTypes__default['default'].array,

  /** Object/map of reaction id/type (e.g. 'like' | 'love' | 'haha' | 'wow' | 'sad' | 'angry') vs count */
  reaction_counts: PropTypes__default['default'].objectOf(PropTypes__default['default'].number.isRequired),

  /** Provide a list of reaction options [{id: 'angry', emoji: 'angry'}] */
  reactionOptions: PropTypes__default['default'].array,

  /**
   * Handler to set/unset reaction on message.
   *
   * @param type e.g. 'like' | 'love' | 'haha' | 'wow' | 'sad' | 'angry'
   * */
  handleReaction: PropTypes__default['default'].func
};
var DefaultReactionsList$1 = /*#__PURE__*/React__default['default'].memo(SimpleReactionsList);

function ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$6(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var handleActionWarning = "Action handler was called, but it is missing one of its required arguments.\n      Make sure the ChannelContext was properly set and that this hook was initialized with a valid message.";
/**
 * @type {import('../types').useActionHandler}
 */

var useActionHandler = function useActionHandler(message) {
  var _useContext = React.useContext(ChannelContext),
      channel = _useContext.channel,
      updateMessage = _useContext.updateMessage,
      removeMessage = _useContext.removeMessage;

  return /*#__PURE__*/function () {
    var _ref = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(dataOrName, value, event) {
      var messageID, formData, data;
      return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (event) event.preventDefault();

              if (!(!message || !updateMessage || !removeMessage || !channel)) {
                _context.next = 4;
                break;
              }

              console.warn(handleActionWarning);
              return _context.abrupt("return");

            case 4:
              messageID = message.id; // deprecated: value&name should be removed in favor of data obj

              /** @type {Record<string, any>} */

              formData = {};
              if (typeof dataOrName === 'string') formData[dataOrName] = value;else formData = _objectSpread$6({}, dataOrName);

              if (!messageID) {
                _context.next = 12;
                break;
              }

              _context.next = 10;
              return channel.sendAction(messageID, formData);

            case 10:
              data = _context.sent;

              if (data !== null && data !== void 0 && data.message) {
                updateMessage(data.message);
              } else {
                removeMessage(message);
              }

            case 12:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x, _x2, _x3) {
      return _ref.apply(this, arguments);
    };
  }();
};

/**
 * @type {import('../types').useDeleteHandler}
 */

var useDeleteHandler = function useDeleteHandler(message) {
  var _useContext = React.useContext(ChannelContext),
      updateMessage = _useContext.updateMessage,
      client = _useContext.client;

  return /*#__PURE__*/function () {
    var _ref = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(event) {
      var data;
      return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              event.preventDefault();

              if (!(!(message !== null && message !== void 0 && message.id) || !client || !updateMessage)) {
                _context.next = 3;
                break;
              }

              return _context.abrupt("return");

            case 3:
              _context.next = 5;
              return client.deleteMessage(message.id);

            case 5:
              data = _context.sent;
              updateMessage(data.message);

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }();
};

/**
 * @type {(
 *   customInitialState?: boolean,
 *   customSetEditing?: (event?: React.MouseEvent<HTMLElement>) => void,
 *   customClearEditingHandler?: (event?: React.MouseEvent<HTMLElement>) => void
 * ) => {
 *   editing: boolean,
 *   setEdit: (event?: React.MouseEvent<HTMLElement>) => void,
 *   clearEdit: (event?: React.MouseEvent<HTMLElement>) => void
 * }}
 */

var useEditHandler = function useEditHandler() {
  var customInitialState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var customSetEditing = arguments.length > 1 ? arguments[1] : undefined;
  var customClearEditingHandler = arguments.length > 2 ? arguments[2] : undefined;

  var _useState = React.useState(customInitialState),
      _useState2 = _slicedToArray__default['default'](_useState, 2),
      editing = _useState2[0],
      setEditing = _useState2[1];

  var setEdit = customSetEditing || function (event) {
    if (event) {
      event.preventDefault();
    }

    setEditing(true);
  };

  var clearEdit = customClearEditingHandler || function (event) {
    if (event) {
      event.preventDefault();
    }

    setEditing(false);
  };

  return {
    editing,
    setEdit,
    clearEdit
  };
};

/**
 * Following function validates a function which returns notification message.
 * It validates if the first parameter is function and also if return value of function is string or no.
 *
 * @type {(func: Function, args: any) => null | string}
 */

var validateAndGetMessage = function validateAndGetMessage(func, args) {
  if (!func || typeof func !== 'function') return null;
  var returnValue = func.apply(void 0, _toConsumableArray__default['default'](args));
  if (typeof returnValue !== 'string') return null;
  return returnValue;
};
/**
 * Tell if the owner of the current message is muted
 *
 * @type {(message?: import('stream-chat').MessageResponse, mutes?: import('stream-chat').Mute[]) => boolean}
 */

var isUserMuted = function isUserMuted(message, mutes) {
  if (!mutes || !message) {
    return false;
  }

  var userMuted = mutes.filter(
  /** @type {(el: import('stream-chat').Mute) => boolean} Typescript syntax */
  function (el) {
    var _message$user;

    return el.target.id === ((_message$user = message.user) === null || _message$user === void 0 ? void 0 : _message$user.id);
  });
  return !!userMuted.length;
};
var MESSAGE_ACTIONS = {
  edit: 'edit',
  delete: 'delete',
  flag: 'flag',
  mute: 'mute',
  pin: 'pin',
  react: 'react',
  reply: 'reply'
};
var defaultPinPermissions = {
  commerce: {
    admin: true,
    anonymous: false,
    channel_member: false,
    channel_moderator: true,
    guest: false,
    member: false,
    moderator: true,
    owner: false,
    user: false
  },
  gaming: {
    admin: true,
    anonymous: false,
    channel_member: false,
    channel_moderator: true,
    guest: false,
    member: false,
    moderator: true,
    owner: false,
    user: false
  },
  livestream: {
    admin: true,
    anonymous: false,
    channel_member: false,
    channel_moderator: true,
    guest: false,
    member: false,
    moderator: true,
    owner: true,
    user: false
  },
  messaging: {
    admin: true,
    anonymous: false,
    channel_member: true,
    channel_moderator: true,
    guest: false,
    member: true,
    moderator: true,
    owner: true,
    user: false
  },
  team: {
    admin: true,
    anonymous: false,
    channel_member: true,
    channel_moderator: true,
    guest: false,
    member: true,
    moderator: true,
    owner: true,
    user: false
  }
};
/**
 * @typedef {{
 *   canEdit?: boolean;
 *   canDelete?: boolean;
 *   canMute?: boolean;
 *   canFlag?: boolean;
 *   canPin?: boolean;
 *   canReact?: boolean;
 *   canReply?: boolean;
 * }} Capabilities
 * @type {(actions: string[] | boolean, capabilities: Capabilities) => string[]} Typescript syntax
 */

var getMessageActions = function getMessageActions(actions, _ref) {
  var canDelete = _ref.canDelete,
      canFlag = _ref.canFlag,
      canEdit = _ref.canEdit,
      canMute = _ref.canMute,
      canPin = _ref.canPin,
      canReact = _ref.canReact,
      canReply = _ref.canReply;
  var messageActionsAfterPermission = [];
  var messageActions = [];

  if (actions && typeof actions === 'boolean') {
    // If value of actions is true, then populate all the possible values
    messageActions = Object.keys(MESSAGE_ACTIONS);
  } else if (actions && actions.length > 0) {
    messageActions = _toConsumableArray__default['default'](actions);
  } else {
    return [];
  }

  if (canEdit && messageActions.indexOf(MESSAGE_ACTIONS.edit) > -1) {
    messageActionsAfterPermission.push(MESSAGE_ACTIONS.edit);
  }

  if (canDelete && messageActions.indexOf(MESSAGE_ACTIONS.delete) > -1) {
    messageActionsAfterPermission.push(MESSAGE_ACTIONS.delete);
  }

  if (canFlag && messageActions.indexOf(MESSAGE_ACTIONS.flag) > -1) {
    messageActionsAfterPermission.push(MESSAGE_ACTIONS.flag);
  }

  if (canMute && messageActions.indexOf(MESSAGE_ACTIONS.mute) > -1) {
    messageActionsAfterPermission.push(MESSAGE_ACTIONS.mute);
  }

  if (canPin && messageActions.indexOf(MESSAGE_ACTIONS.pin) > -1) {
    messageActionsAfterPermission.push(MESSAGE_ACTIONS.pin);
  }

  if (canReact && messageActions.indexOf(MESSAGE_ACTIONS.react) > -1) {
    messageActionsAfterPermission.push(MESSAGE_ACTIONS.react);
  }

  if (canReply && messageActions.indexOf(MESSAGE_ACTIONS.reply) > -1) {
    messageActionsAfterPermission.push(MESSAGE_ACTIONS.reply);
  }

  return messageActionsAfterPermission;
};
/**
 * @typedef {Pick<import('../types').MessageComponentProps, 'message' | 'readBy' | 'groupStyles' | 'lastReceivedId' | 'messageListRect'>} MessageEqualProps
 * @type {(props: MessageEqualProps, nextProps: MessageEqualProps) => boolean} Typescript syntax
 */

var areMessagePropsEqual = function areMessagePropsEqual(props, nextProps) {
  return (// Message content is equal
    nextProps.message === props.message && // Message was read by someone
    deepequal__default['default'](nextProps.readBy, props.readBy) && // Group style changes (it often happens that the last 3 messages of a channel have different group styles)
    deepequal__default['default'](nextProps.groupStyles, props.groupStyles) && // @ts-ignore
    deepequal__default['default'](nextProps.mutes, props.mutes) && // Last message received in the channel changes
    deepequal__default['default'](nextProps.lastReceivedId, props.lastReceivedId) && // User toggles edit state
    // @ts-ignore // TODO: fix
    nextProps.editing === props.editing && // Message wrapper layout changes
    nextProps.messageListRect === props.messageListRect
  );
};
/**
 * @type {(nextProps: import('../types').MessageComponentProps, props: import('../types').MessageComponentProps ) => boolean} Typescript syntax
 */

var shouldMessageComponentUpdate = function shouldMessageComponentUpdate(props, nextProps) {
  // Component should only update if:
  return !areMessagePropsEqual(props, nextProps);
};
/** @type {(message: import('stream-chat').MessageResponse | undefined) => boolean} */

var messageHasReactions = function messageHasReactions(message) {
  return !!(message !== null && message !== void 0 && message.latest_reactions) && !!message.latest_reactions.length;
};
/** @type {(message: import('stream-chat').MessageResponse | undefined) => boolean} */

var messageHasAttachments = function messageHasAttachments(message) {
  return !!(message !== null && message !== void 0 && message.attachments) && !!message.attachments.length;
};
/**
 * @type {(message: import('stream-chat').MessageResponse | undefined) => import('stream-chat').Attachment[] }
 */

var getImages = function getImages(message) {
  if (!(message !== null && message !== void 0 && message.attachments)) {
    return [];
  }

  return message.attachments.filter(
  /** @type {(item: import('stream-chat').Attachment) => boolean} Typescript syntax */
  function (item) {
    return item.type === 'image';
  });
};
/**
 * @type {(message: import('stream-chat').MessageResponse | undefined) => import('stream-chat').Attachment[] }
 */

var getNonImageAttachments = function getNonImageAttachments(message) {
  if (!(message !== null && message !== void 0 && message.attachments)) {
    return [];
  }

  return message.attachments.filter(
  /** @type {(item: import('stream-chat').Attachment) => boolean} Typescript syntax */
  function (item) {
    return item.type !== 'image';
  });
};
/**
 * @typedef {Array<import('stream-chat').UserResponse<import('../types').StreamChatReactUserType>>} ReadByUsers
 * @type {(
 *   users: ReadByUsers,
 *   t: import('../types').TranslationContextValue['t'],
 *   client: import('../types').ChannelContextValue['client']
 * ) => string}
 */

var getReadByTooltipText = function getReadByTooltipText(users, t, client) {
  var outStr = '';

  if (!t) {
    throw new Error('`getReadByTooltipText was called, but translation function is not available`');
  } // first filter out client user, so restLength won't count it


  var otherUsers = users.filter(function (item) {
    return item && (client === null || client === void 0 ? void 0 : client.user) && item.id !== client.user.id;
  }).map(function (item) {
    return item.name || item.id;
  });
  var slicedArr = otherUsers.slice(0, 5);
  var restLength = otherUsers.length - slicedArr.length;

  if (slicedArr.length === 1) {
    outStr = "".concat(slicedArr[0], " ");
  } else if (slicedArr.length === 2) {
    // joins all with "and" but =no commas
    // example: "bob and sam"
    outStr = t('{{ firstUser }} and {{ secondUser }}', {
      firstUser: slicedArr[0],
      secondUser: slicedArr[1]
    });
  } else if (slicedArr.length > 2) {
    // joins all with commas, but last one gets ", and" (oxford comma!)
    // example: "bob, joe, sam and 4 more"
    if (restLength === 0) {
      // mutate slicedArr to remove last user to display it separately
      var lastUser = slicedArr.splice(slicedArr.length - 2, 1);
      outStr = t('{{ commaSeparatedUsers }}, and {{ lastUser }}', {
        commaSeparatedUsers: slicedArr.join(', '),
        lastUser
      });
    } else {
      outStr = t('{{ commaSeparatedUsers }} and {{ moreCount }} more', {
        commaSeparatedUsers: slicedArr.join(', '),
        moreCount: restLength
      });
    }
  }

  return outStr;
};
var MessagePropTypes = PropTypes__default['default'].shape({
  id: PropTypes__default['default'].string.isRequired,
  type: PropTypes__default['default'].string.isRequired,
  text: PropTypes__default['default'].string.isRequired,
  html: PropTypes__default['default'].string.isRequired,
  created_at: PropTypes__default['default'].instanceOf(Date).isRequired,
  updated_at: PropTypes__default['default'].instanceOf(Date).isRequired
}).isRequired;

var missingUseFlagHandlerParameterWarning = 'useFlagHandler was called but it is missing one or more necessary parameters.';
/**
 * @type {import('../types').useFlagHandler}
 */

var useFlagHandler = function useFlagHandler(message) {
  var notifications = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var _useContext = React.useContext(ChannelContext),
      client = _useContext.client;

  var _useContext2 = React.useContext(TranslationContext),
      t = _useContext2.t;
  /** @type {(event: React.MouseEvent<HTMLElement>) => Promise<void>} Typescript syntax */


  return /*#__PURE__*/function () {
    var _ref = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(event) {
      var notify, getSuccessNotification, getErrorNotification, successMessage, errorMessage;
      return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              event.preventDefault();
              notify = notifications.notify, getSuccessNotification = notifications.getSuccessNotification, getErrorNotification = notifications.getErrorNotification;

              if (!(!client || !t || !notify || !(message !== null && message !== void 0 && message.id))) {
                _context.next = 5;
                break;
              }

              console.warn(missingUseFlagHandlerParameterWarning);
              return _context.abrupt("return");

            case 5:
              _context.prev = 5;
              _context.next = 8;
              return client.flagMessage(message.id);

            case 8:
              successMessage = getSuccessNotification && validateAndGetMessage(getSuccessNotification, [message]);
              notify(successMessage || t('Message has been successfully flagged'), 'success');
              _context.next = 16;
              break;

            case 12:
              _context.prev = 12;
              _context.t0 = _context["catch"](5);
              errorMessage = getErrorNotification && validateAndGetMessage(getErrorNotification, [message]);
              notify(errorMessage || t('Error adding flag: Either the flag already exist or there is issue with network connection ...'), 'error');

            case 16:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[5, 12]]);
    }));

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }();
};

// @ts-check
/** @type {(fn: Function | undefined, message: import('stream-chat').MessageResponse | undefined) => React.EventHandler<React.SyntheticEvent>} * */

function createEventHandler(fn, message) {
  return function (e) {
    if (typeof fn !== 'function' || !(message !== null && message !== void 0 && message.mentioned_users)) {
      return;
    }

    fn(e, message.mentioned_users);
  };
}
/**
 * @type {import('../types').useMentionsHandler}
 */


var useMentionsHandler = function useMentionsHandler(message, customMentionHandler) {
  /**
   * @type{import('../types').ChannelContextValue}
   */
  var _useContext = React.useContext(ChannelContext),
      channelOnMentionsClick = _useContext.onMentionsClick,
      channelOnMentionsHover = _useContext.onMentionsHover;

  var onMentionsClick = (customMentionHandler === null || customMentionHandler === void 0 ? void 0 : customMentionHandler.onMentionsClick) || channelOnMentionsClick || function () {};

  var onMentionsHover = (customMentionHandler === null || customMentionHandler === void 0 ? void 0 : customMentionHandler.onMentionsHover) || channelOnMentionsHover || function () {};

  return {
    /** @type {(e: React.MouseEvent<HTMLElement>) => void} Typescript syntax */
    onMentionsClick: createEventHandler(onMentionsClick, message),

    /** @type {(e: React.MouseEvent<HTMLElement>) => void} Typescript syntax */
    onMentionsHover: createEventHandler(onMentionsHover, message)
  };
};
/**
 * @type {import('../types').useMentionsUIHandler}
 */

var useMentionsUIHandler = function useMentionsUIHandler(message, eventHandlers) {
  /**
   * @type{import('../types').ChannelContextValue}
   */
  var _useContext2 = React.useContext(ChannelContext),
      onMentionsClick = _useContext2.onMentionsClick,
      onMentionsHover = _useContext2.onMentionsHover;

  return {
    /** @type {(e: React.MouseEvent<HTMLElement>) => void} Typescript syntax */
    onMentionsClick: (eventHandlers === null || eventHandlers === void 0 ? void 0 : eventHandlers.onMentionsClick) || createEventHandler(onMentionsClick, message),

    /** @type {(e: React.MouseEvent<HTMLElement>) => void} Typescript syntax */
    onMentionsHover: (eventHandlers === null || eventHandlers === void 0 ? void 0 : eventHandlers.onMentionsHover) || createEventHandler(onMentionsHover, message)
  };
};

var missingUseMuteHandlerParamsWarning = 'useMuteHandler was called but it is missing one or more necessary parameter.';
/**
 * @type {import('../types').useMuteHandler}
 */

var useMuteHandler = function useMuteHandler(message) {
  var notifications = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var _useContext = React.useContext(ChannelContext),
      client = _useContext.client,
      mutes = _useContext.mutes;

  var _useContext2 = React.useContext(TranslationContext),
      t = _useContext2.t;
  /** @type {(event: React.MouseEvent<HTMLElement>) => Promise<void>} Typescript syntax */


  return /*#__PURE__*/function () {
    var _ref = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(event) {
      var notify, getSuccessNotification, getErrorNotification, successMessage, errorMessage, fallbackMessage, _successMessage, _errorMessage;

      return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              event.preventDefault();
              notify = notifications.notify, getSuccessNotification = notifications.getSuccessNotification, getErrorNotification = notifications.getErrorNotification;

              if (!(!t || !(message !== null && message !== void 0 && message.user) || !notify || !client)) {
                _context.next = 5;
                break;
              }

              console.warn(missingUseMuteHandlerParamsWarning);
              return _context.abrupt("return");

            case 5:
              if (isUserMuted(message, mutes)) {
                _context.next = 19;
                break;
              }

              _context.prev = 6;
              _context.next = 9;
              return client.muteUser(message.user.id);

            case 9:
              successMessage = getSuccessNotification && validateAndGetMessage(getSuccessNotification, [message.user]);
              notify(successMessage || t("{{ user }} has been muted", {
                user: message.user.name || message.user.id
              }), 'success');
              _context.next = 17;
              break;

            case 13:
              _context.prev = 13;
              _context.t0 = _context["catch"](6);
              errorMessage = getErrorNotification && validateAndGetMessage(getErrorNotification, [message.user]);
              notify(errorMessage || t('Error muting a user ...'), 'error');

            case 17:
              _context.next = 31;
              break;

            case 19:
              _context.prev = 19;
              _context.next = 22;
              return client.unmuteUser(message.user.id);

            case 22:
              fallbackMessage = t("{{ user }} has been unmuted", {
                user: message.user.name || message.user.id
              });
              _successMessage = getSuccessNotification && validateAndGetMessage(getSuccessNotification, [message.user]) || fallbackMessage;

              if (typeof _successMessage === 'string') {
                notify(_successMessage, 'success');
              }

              _context.next = 31;
              break;

            case 27:
              _context.prev = 27;
              _context.t1 = _context["catch"](19);
              _errorMessage = getErrorNotification && validateAndGetMessage(getErrorNotification, [message.user]) || t('Error unmuting a user ...');

              if (typeof _errorMessage === 'string') {
                notify(_errorMessage, 'error');
              }

            case 31:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[6, 13], [19, 27]]);
    }));

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }();
};

// @ts-check
/**
 * @type {import('../types').useOpenThreadHandler}
 */

var useOpenThreadHandler = function useOpenThreadHandler(message, customOpenThread) {
  /**
   * @type{import('../types').ChannelContextValue}
   */
  var _useContext = React.useContext(ChannelContext),
      channelOpenThread = _useContext.openThread;

  var openThread = customOpenThread || channelOpenThread;
  return function (event) {
    if (!openThread || !message) {
      console.warn('Open thread handler was called but it is missing one of its parameters');
      return;
    }

    openThread(message, event);
  };
};

/**
 * @type {import('../types').usePinHandler}
 */

var usePinHandler = function usePinHandler(message, permissions, notifications) {
  var notify = notifications.notify,
      getErrorNotification = notifications.getErrorNotification;

  var _useContext = React.useContext(ChannelContext),
      client = _useContext.client,
      channel = _useContext.channel;

  var _useContext2 = React.useContext(TranslationContext),
      t = _useContext2.t;

  var canPin = function canPin() {
    var _client$user;

    if (!client || !(channel !== null && channel !== void 0 && channel.state) || !permissions) return false;
    var currentChannelPermissions = permissions[channel.type];
    var currentChannelMember = channel.state.members[client.userID];
    var currentChannelWatcher = channel.state.watchers[client.userID];

    if (currentChannelPermissions && currentChannelPermissions[(_client$user = client.user) === null || _client$user === void 0 ? void 0 : _client$user.role]) {
      return true;
    }

    if (currentChannelMember && currentChannelPermissions[currentChannelMember.role]) {
      return true;
    }

    if (currentChannelWatcher && currentChannelPermissions[currentChannelWatcher.role]) {
      return true;
    }

    return false;
  };

  var handlePin = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(event) {
      var errorMessage, _errorMessage;

      return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              event.preventDefault();

              if (message) {
                _context.next = 3;
                break;
              }

              return _context.abrupt("return");

            case 3:
              if (message.pinned) {
                _context.next = 15;
                break;
              }

              _context.prev = 4;
              _context.next = 7;
              return client.pinMessage(message);

            case 7:
              _context.next = 13;
              break;

            case 9:
              _context.prev = 9;
              _context.t0 = _context["catch"](4);
              errorMessage = getErrorNotification && validateAndGetMessage(getErrorNotification, [message.user]);
              notify(errorMessage || t('Error pinning message'), 'error');

            case 13:
              _context.next = 24;
              break;

            case 15:
              _context.prev = 15;
              _context.next = 18;
              return client.unpinMessage(message);

            case 18:
              _context.next = 24;
              break;

            case 20:
              _context.prev = 20;
              _context.t1 = _context["catch"](15);
              _errorMessage = getErrorNotification && validateAndGetMessage(getErrorNotification, [message.user]);
              notify(_errorMessage || t('Error removing message pin'), 'error');

            case 24:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[4, 9], [15, 20]]);
    }));

    return function handlePin(_x) {
      return _ref.apply(this, arguments);
    };
  }();

  return {
    canPin: canPin(),
    handlePin
  };
};

var reactionHandlerWarning = "Reaction handler was called, but it is missing one of its required arguments.\n      Make sure the ChannelContext was properly set and that this hook was initialized with a valid message.";
/**
 * @type {import('../types').useReactionHandler}
 */

var useReactionHandler = function useReactionHandler(message) {
  var _useContext = React.useContext(ChannelContext),
      client = _useContext.client,
      channel = _useContext.channel,
      updateMessage = _useContext.updateMessage;

  return /*#__PURE__*/function () {
    var _ref = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(reactionType, event) {
      var userExistingReaction, currentUser, originalMessage, reactionChangePromise, messageID, reaction;
      return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (event && event.preventDefault) {
                event.preventDefault();
              }

              if (!(!updateMessage || !message || !channel || !client)) {
                _context.next = 4;
                break;
              }

              console.warn(reactionHandlerWarning);
              return _context.abrupt("return");

            case 4:
              userExistingReaction =
              /** @type { import('stream-chat').ReactionResponse<Record<String, unknown>, import('../types').StreamChatReactUserType> | null } */
              null;
              currentUser = client.userID;

              if (message.own_reactions) {
                message.own_reactions.forEach(function (reaction) {
                  // own user should only ever contain the current user id
                  // just in case we check to prevent bugs with message updates from breaking reactions
                  if (reaction.user && currentUser === reaction.user.id && reaction.type === reactionType) {
                    userExistingReaction = reaction;
                  } else if (reaction.user && currentUser !== reaction.user.id) {
                    console.warn("message.own_reactions contained reactions from a different user, this indicates a bug");
                  }
                });
              }

              originalMessage = message;

              if (!message.id) {
                _context.next = 18;
                break;
              }

              if (userExistingReaction) {
                reactionChangePromise = channel.deleteReaction(message.id, userExistingReaction.type);
              } else {
                // add the reaction
                messageID = message.id;
                reaction = {
                  type: reactionType
                }; // this.props.channel.state.addReaction(tmpReaction, this.props.message);

                reactionChangePromise = channel.sendReaction(messageID, reaction);
              }

              _context.prev = 10;
              _context.next = 13;
              return reactionChangePromise;

            case 13:
              _context.next = 18;
              break;

            case 15:
              _context.prev = 15;
              _context.t0 = _context["catch"](10);
              // revert to the original message if the API call fails
              updateMessage(originalMessage);

            case 18:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[10, 15]]);
    }));

    return function (_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();
};
/**
 * @type {import('../types').useReactionClick}
 */

var useReactionClick = function useReactionClick(message, reactionSelectorRef, messageWrapperRef) {
  var _channel$getConfig, _channel$getConfig$ca;

  var _useContext2 = React.useContext(ChannelContext),
      channel = _useContext2.channel;

  var _useState = React.useState(false),
      _useState2 = _slicedToArray__default['default'](_useState, 2),
      showDetailedReactions = _useState2[0],
      setShowDetailedReactions = _useState2[1];

  var isReactionEnabled = (channel === null || channel === void 0 ? void 0 : (_channel$getConfig = channel.getConfig) === null || _channel$getConfig === void 0 ? void 0 : (_channel$getConfig$ca = _channel$getConfig.call(channel)) === null || _channel$getConfig$ca === void 0 ? void 0 : _channel$getConfig$ca.reactions) !== false;
  var messageDeleted = !!(message !== null && message !== void 0 && message.deleted_at);
  var hasListener = React.useRef(false);
  /** @type {EventListener} */

  var closeDetailedReactions = React.useCallback(function (event) {
    var _reactionSelectorRef$;

    if (event.target && // @ts-ignore
    reactionSelectorRef !== null && reactionSelectorRef !== void 0 && (_reactionSelectorRef$ = reactionSelectorRef.current) !== null && _reactionSelectorRef$ !== void 0 && _reactionSelectorRef$.contains(event.target)) {
      return;
    }

    setShowDetailedReactions(false);
  }, [setShowDetailedReactions, reactionSelectorRef]);
  React.useEffect(function () {
    var messageWrapper = messageWrapperRef === null || messageWrapperRef === void 0 ? void 0 : messageWrapperRef.current;

    if (showDetailedReactions && !hasListener.current) {
      hasListener.current = true;
      document.addEventListener('click', closeDetailedReactions);
      document.addEventListener('touchend', closeDetailedReactions);

      if (messageWrapper) {
        messageWrapper.addEventListener('mouseleave', closeDetailedReactions);
      }
    }

    if (!showDetailedReactions && hasListener.current) {
      document.removeEventListener('click', closeDetailedReactions);
      document.removeEventListener('touchend', closeDetailedReactions);

      if (messageWrapper) {
        messageWrapper.removeEventListener('mouseleave', closeDetailedReactions);
      }

      hasListener.current = false;
    }

    return function () {
      if (hasListener.current) {
        document.removeEventListener('click', closeDetailedReactions);
        document.removeEventListener('touchend', closeDetailedReactions);

        if (messageWrapper) {
          messageWrapper.removeEventListener('mouseleave', closeDetailedReactions);
        }

        hasListener.current = false;
      }
    };
  }, [showDetailedReactions, closeDetailedReactions, messageWrapperRef]);
  React.useEffect(function () {
    var messageWrapper = messageWrapperRef === null || messageWrapperRef === void 0 ? void 0 : messageWrapperRef.current;

    if (messageDeleted && hasListener.current) {
      document.removeEventListener('click', closeDetailedReactions);
      document.removeEventListener('touchend', closeDetailedReactions);

      if (messageWrapper) {
        messageWrapper.removeEventListener('mouseleave', closeDetailedReactions);
      }

      hasListener.current = false;
    }
  }, [messageDeleted, closeDetailedReactions, messageWrapperRef]);
  /** @type {() => void} Typescript syntax */

  var onReactionListClick = function onReactionListClick() {
    setShowDetailedReactions(true);
  };

  return {
    onReactionListClick,
    showDetailedReactions,
    isReactionEnabled
  };
};

/**
 * @type {import('../types').useRetryHandler}
 */

var useRetryHandler = function useRetryHandler(customRetrySendMessage) {
  /**
   *@type {import('../types').ChannelContextValue}
   */
  var _useContext = React.useContext(ChannelContext),
      contextRetrySendMessage = _useContext.retrySendMessage;

  var retrySendMessage = customRetrySendMessage || contextRetrySendMessage;
  return /*#__PURE__*/function () {
    var _ref = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(message) {
      return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(retrySendMessage && message)) {
                _context.next = 3;
                break;
              }

              _context.next = 3;
              return retrySendMessage(message);

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }();
};

// @ts-check

/**
 * @type {import('../types').useUserHandler}
 */
var useUserHandler = function useUserHandler(message, eventHandlers) {
  return {
    /** @type {(e: React.MouseEvent<HTMLElement>) => void} Typescript syntax */
    onUserClick: function onUserClick(e) {
      if (typeof (eventHandlers === null || eventHandlers === void 0 ? void 0 : eventHandlers.onUserClickHandler) !== 'function' || !(message !== null && message !== void 0 && message.user)) {
        return;
      }

      eventHandlers.onUserClickHandler(e, message.user);
    },

    /** @type {(e: React.MouseEvent<HTMLElement>) => void} Typescript syntax */
    onUserHover: function onUserHover(e) {
      if (typeof (eventHandlers === null || eventHandlers === void 0 ? void 0 : eventHandlers.onUserHoverHandler) !== 'function' || !(message !== null && message !== void 0 && message.user)) {
        return;
      }

      eventHandlers.onUserHoverHandler(e, message.user);
    }
  };
};

// @ts-check
/**
 * @type {import('../types').useUserRole}
 */

var useUserRole = function useUserRole(message) {
  var _client$user, _channel$state, _channel$state$member, _channel$state2, _channel$state2$membe, _client$user2, _channel$state3, _channel$state3$membe, _channel$state4, _channel$state4$membe;

  var _useContext = React.useContext(ChannelContext),
      client = _useContext.client,
      channel = _useContext.channel;

  var isMyMessage = !!(message !== null && message !== void 0 && message.user) && !!(client !== null && client !== void 0 && client.user) && client.user.id === message.user.id;
  var isAdmin = (client === null || client === void 0 ? void 0 : (_client$user = client.user) === null || _client$user === void 0 ? void 0 : _client$user.role) === 'admin' || (channel === null || channel === void 0 ? void 0 : (_channel$state = channel.state) === null || _channel$state === void 0 ? void 0 : (_channel$state$member = _channel$state.membership) === null || _channel$state$member === void 0 ? void 0 : _channel$state$member.role) === 'admin';
  var isOwner = (channel === null || channel === void 0 ? void 0 : (_channel$state2 = channel.state) === null || _channel$state2 === void 0 ? void 0 : (_channel$state2$membe = _channel$state2.membership) === null || _channel$state2$membe === void 0 ? void 0 : _channel$state2$membe.role) === 'owner';
  var isModerator = (client === null || client === void 0 ? void 0 : (_client$user2 = client.user) === null || _client$user2 === void 0 ? void 0 : _client$user2.role) === 'channel_moderator' || (channel === null || channel === void 0 ? void 0 : (_channel$state3 = channel.state) === null || _channel$state3 === void 0 ? void 0 : (_channel$state3$membe = _channel$state3.membership) === null || _channel$state3$membe === void 0 ? void 0 : _channel$state3$membe.role) === 'channel_moderator' || (channel === null || channel === void 0 ? void 0 : (_channel$state4 = channel.state) === null || _channel$state4 === void 0 ? void 0 : (_channel$state4$membe = _channel$state4.membership) === null || _channel$state4$membe === void 0 ? void 0 : _channel$state4$membe.role) === 'moderator';
  var canEditMessage = isMyMessage || isModerator || isOwner || isAdmin;
  var canDeleteMessage = canEditMessage;
  return {
    isMyMessage,
    isAdmin,
    isOwner,
    isModerator,
    canEditMessage,
    canDeleteMessage
  };
};

/** @type {React.FC<import("types").MessageActionsBoxProps>} */

var MessageActionsBox = function MessageActionsBox(_ref) {
  var getMessageActions = _ref.getMessageActions,
      handleDelete = _ref.handleDelete,
      handleEdit = _ref.handleEdit,
      handleFlag = _ref.handleFlag,
      handleMute = _ref.handleMute,
      handlePin = _ref.handlePin,
      isUserMuted = _ref.isUserMuted,
      message = _ref.message,
      messageListRect = _ref.messageListRect,
      mine = _ref.mine,
      _ref$open = _ref.open,
      open = _ref$open === void 0 ? false : _ref$open;

  var _useContext = React.useContext(TranslationContext),
      t = _useContext.t;

  var _useState = React.useState(false),
      _useState2 = _slicedToArray__default['default'](_useState, 2),
      reverse = _useState2[0],
      setReverse = _useState2[1];

  var messageActions = getMessageActions();
  var checkIfReverse = React.useCallback(function (containerElement) {
    if (!containerElement) {
      setReverse(false);
      return;
    }

    if (open) {
      var containerRect = containerElement.getBoundingClientRect();

      if (mine) {
        setReverse(!!messageListRect && containerRect.left < messageListRect.left);
      } else {
        setReverse(!!messageListRect && containerRect.right + 5 > messageListRect.right);
      }
    }
  }, [messageListRect, mine, open]);
  return /*#__PURE__*/React__default['default'].createElement("div", {
    "data-testid": "message-actions-box",
    className: "str-chat__message-actions-box\n        ".concat(open ? 'str-chat__message-actions-box--open' : '', "\n        ").concat(mine ? 'str-chat__message-actions-box--mine' : '', "\n        ").concat(reverse ? 'str-chat__message-actions-box--reverse' : '', "\n      "),
    ref: checkIfReverse
  }, /*#__PURE__*/React__default['default'].createElement("ul", {
    className: "str-chat__message-actions-list"
  }, messageActions.indexOf(MESSAGE_ACTIONS.pin) > -1 && !(message !== null && message !== void 0 && message.parent_id) && /*#__PURE__*/React__default['default'].createElement("button", {
    onClick: handlePin
  }, /*#__PURE__*/React__default['default'].createElement("li", {
    className: "str-chat__message-actions-list-item"
  }, !(message !== null && message !== void 0 && message.pinned) ? t('Pin') : t('Unpin'))), messageActions.indexOf(MESSAGE_ACTIONS.flag) > -1 && /*#__PURE__*/React__default['default'].createElement("button", {
    onClick: handleFlag
  }, /*#__PURE__*/React__default['default'].createElement("li", {
    className: "str-chat__message-actions-list-item"
  }, t('Flag'))), messageActions.indexOf(MESSAGE_ACTIONS.mute) > -1 && /*#__PURE__*/React__default['default'].createElement("button", {
    onClick: handleMute
  }, /*#__PURE__*/React__default['default'].createElement("li", {
    className: "str-chat__message-actions-list-item"
  }, isUserMuted && isUserMuted() ? t('Unmute') : t('Mute'))), messageActions.indexOf(MESSAGE_ACTIONS.edit) > -1 && /*#__PURE__*/React__default['default'].createElement("button", {
    onClick: handleEdit
  }, /*#__PURE__*/React__default['default'].createElement("li", {
    className: "str-chat__message-actions-list-item"
  }, t('Edit Message'))), messageActions.indexOf(MESSAGE_ACTIONS.delete) > -1 && /*#__PURE__*/React__default['default'].createElement("button", {
    onClick: handleDelete
  }, /*#__PURE__*/React__default['default'].createElement("li", {
    className: "str-chat__message-actions-list-item"
  }, t('Delete')))));
};

MessageActionsBox.propTypes = {
  /** The [message object](https://getstream.io/chat/docs/#message_format) */
  message:
  /** @type {PropTypes.Validator<import('stream-chat').MessageResponse>} */
  PropTypes__default['default'].object,

  /** If the message actions box should be open or not */
  open: PropTypes__default['default'].bool,

  /** If message belongs to current user. */
  mine: PropTypes__default['default'].bool,

  /** DOMRect object for parent MessageList component */
  messageListRect:
  /** @type {PropTypes.Validator<DOMRect>} */
  PropTypes__default['default'].object,

  /**
   * Handler for flagging a current message
   *
   * @param event React's MouseEventHandler event
   * @returns void
   * */
  handleFlag: PropTypes__default['default'].func,

  /**
   * Handler for muting a current message
   *
   * @param event React's MouseEventHandler event
   * @returns void
   * */
  handleMute: PropTypes__default['default'].func,

  /**
   * Handler for editing a current message
   *
   * @param event React's MouseEventHandler event
   * @returns void
   * */
  handleEdit: PropTypes__default['default'].func,

  /**
   * Handler for deleting a current message
   *
   * @param event React's MouseEventHandler event
   * @returns void
   * */
  handleDelete: PropTypes__default['default'].func,

  /**
   * Handler for pinning a current message
   *
   * @param event React's MouseEventHandler event
   * @returns void
   * */
  handlePin: PropTypes__default['default'].func,

  /**
   * Returns array of available message actions for current message.
   * Please check [Message](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Message.js) component for default implementation.
   */
  getMessageActions: PropTypes__default['default'].func.isRequired
};
var MessageActionsBox$1 = /*#__PURE__*/React__default['default'].memo(MessageActionsBox);

/**
 * @type { React.FC<import('../types').MessageActionsProps> }
 */

var MessageActions = function MessageActions(props) {
  var addNotification = props.addNotification,
      customWrapperClass = props.customWrapperClass,
      getMessageActions = props.getMessageActions,
      getFlagMessageErrorNotification = props.getFlagMessageErrorNotification,
      getFlagMessageSuccessNotification = props.getFlagMessageSuccessNotification,
      getMuteUserErrorNotification = props.getMuteUserErrorNotification,
      getMuteUserSuccessNotification = props.getMuteUserSuccessNotification,
      getPinMessageErrorNotification = props.getPinMessageErrorNotification,
      propHandleDelete = props.handleDelete,
      propHandleFlag = props.handleFlag,
      propHandleMute = props.handleMute,
      propHandlePin = props.handlePin,
      inline = props.inline,
      message = props.message,
      messageListRect = props.messageListRect,
      messageWrapperRef = props.messageWrapperRef,
      _props$pinPermissions = props.pinPermissions,
      pinPermissions = _props$pinPermissions === void 0 ? defaultPinPermissions : _props$pinPermissions,
      setEditingState = props.setEditingState;

  var _useContext = React.useContext(ChatContext),
      mutes = _useContext.mutes;

  var _useState = React.useState(false),
      _useState2 = _slicedToArray__default['default'](_useState, 2),
      actionsBoxOpen = _useState2[0],
      setActionsBoxOpen = _useState2[1];

  var _useUserRole = useUserRole(message),
      isMyMessage = _useUserRole.isMyMessage;

  var handleDelete = useDeleteHandler(message);
  var handleFlag = useFlagHandler(message, {
    notify: addNotification,
    getSuccessNotification: getFlagMessageErrorNotification,
    getErrorNotification: getFlagMessageSuccessNotification
  });
  var handleMute = useMuteHandler(message, {
    notify: addNotification,
    getErrorNotification: getMuteUserSuccessNotification,
    getSuccessNotification: getMuteUserErrorNotification
  });

  var _usePinHandler = usePinHandler(message, pinPermissions, {
    notify: addNotification,
    getErrorNotification: getPinMessageErrorNotification
  }),
      handlePin = _usePinHandler.handlePin;

  var isMuted = React.useCallback(function () {
    return isUserMuted(message, mutes);
  }, [message, mutes]);
  var hideOptions = React.useCallback(function () {
    return setActionsBoxOpen(false);
  }, []);
  var messageActions = getMessageActions();
  var messageDeletedAt = !!(message !== null && message !== void 0 && message.deleted_at);
  React.useEffect(function () {
    if (messageWrapperRef !== null && messageWrapperRef !== void 0 && messageWrapperRef.current) {
      messageWrapperRef.current.addEventListener('onMouseLeave', hideOptions);
    }
  }, [messageWrapperRef, hideOptions]);
  React.useEffect(function () {
    if (messageDeletedAt) {
      document.removeEventListener('click', hideOptions);
    }
  }, [messageDeletedAt, hideOptions]);
  React.useEffect(function () {
    if (actionsBoxOpen) {
      document.addEventListener('click', hideOptions);
    } else {
      document.removeEventListener('click', hideOptions);
    }

    return function () {
      return document.removeEventListener('click', hideOptions);
    };
  }, [actionsBoxOpen, hideOptions]);
  if (messageActions.length === 0) return null;
  return /*#__PURE__*/React__default['default'].createElement(MessageActionsWrapper, {
    customWrapperClass: customWrapperClass,
    inline: inline,
    setActionsBoxOpen: setActionsBoxOpen
  }, /*#__PURE__*/React__default['default'].createElement(MessageActionsBox$1, {
    getMessageActions: getMessageActions,
    handleDelete: propHandleDelete || handleDelete,
    handleEdit: setEditingState,
    handleFlag: propHandleFlag || handleFlag,
    handleMute: propHandleMute || handleMute,
    handlePin: propHandlePin || handlePin,
    isUserMuted: isMuted,
    message: message,
    messageListRect: messageListRect,
    mine: isMyMessage,
    open: actionsBoxOpen
  }), /*#__PURE__*/React__default['default'].createElement("svg", {
    width: "11",
    height: "4",
    viewBox: "0 0 11 4",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React__default['default'].createElement("path", {
    d: "M1.5 3a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm4 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm4 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3z",
    fillRule: "nonzero"
  })));
};
/**
 * This is a workaround to encompass the different styles message actions can have at the moment
 * while allowing for sharing the component's stateful logic.
 * @type { React.FC<import('../types').MessageActionsWrapperProps> }
 */

var MessageActionsWrapper = function MessageActionsWrapper(props) {
  var children = props.children,
      customWrapperClass = props.customWrapperClass,
      inline = props.inline,
      setActionsBoxOpen = props.setActionsBoxOpen;
  var defaultWrapperClass = 'str-chat__message-simple__actions__action str-chat__message-simple__actions__action--options';
  var wrapperClass = typeof customWrapperClass === 'string' ? customWrapperClass : defaultWrapperClass;
  /** @type {(e: React.MouseEvent) => void} Typescript syntax */

  var onClickOptionsAction = function onClickOptionsAction(e) {
    e.stopPropagation();
    setActionsBoxOpen(true);
  };

  var wrapperProps = {
    'data-testid': 'message-actions',
    onClick: onClickOptionsAction,
    className: wrapperClass
  };
  if (inline) return /*#__PURE__*/React__default['default'].createElement("span", wrapperProps, children);
  return /*#__PURE__*/React__default['default'].createElement("div", wrapperProps, children);
};

/**
 * @type { React.FC<import('../types').MessageOptionsProps> }
 */

var MessageOptionsComponent = function MessageOptionsComponent(props) {
  var _props$displayActions = props.displayActions,
      displayActions = _props$displayActions === void 0 ? true : _props$displayActions,
      _props$displayLeft = props.displayLeft,
      displayLeft = _props$displayLeft === void 0 ? true : _props$displayLeft,
      _props$displayReplies = props.displayReplies,
      displayReplies = _props$displayReplies === void 0 ? true : _props$displayReplies,
      propHandleOpenThread = props.handleOpenThread,
      initialMessage = props.initialMessage,
      message = props.message,
      messageWrapperRef = props.messageWrapperRef,
      onReactionListClick = props.onReactionListClick,
      _props$theme = props.theme,
      theme = _props$theme === void 0 ? 'simple' : _props$theme,
      threadList = props.threadList;

  var _useUserRole = useUserRole(message),
      isMyMessage = _useUserRole.isMyMessage;

  var handleOpenThread = useOpenThreadHandler(message);
  /**
   * @type {import('../types').ChannelContextValue}
   */

  var _useContext = React.useContext(ChannelContext),
      channel = _useContext.channel;

  var channelConfig = channel === null || channel === void 0 ? void 0 : channel.getConfig();
  var messageActions = props.getMessageActions();
  var shouldShowReactions = messageActions.indexOf(MESSAGE_ACTIONS.react) > -1 && channelConfig && channelConfig.reactions;
  var shouldShowReplies = messageActions.indexOf(MESSAGE_ACTIONS.reply) > -1 && displayReplies && !threadList && channelConfig && channelConfig.replies;

  if (!message || message.type === 'error' || message.type === 'system' || message.type === 'ephemeral' || message.status === 'failed' || message.status === 'sending' || initialMessage) {
    return null;
  }

  if (isMyMessage && displayLeft) {
    return /*#__PURE__*/React__default['default'].createElement("div", {
      "data-testid": "message-options-left",
      className: "str-chat__message-".concat(theme, "__actions")
    }, displayActions && /*#__PURE__*/React__default['default'].createElement(MessageActions, _extends__default['default']({}, props, {
      messageWrapperRef: messageWrapperRef
    })), shouldShowReplies && /*#__PURE__*/React__default['default'].createElement("div", {
      "data-testid": "thread-action",
      onClick: propHandleOpenThread || handleOpenThread,
      className: "str-chat__message-".concat(theme, "__actions__action str-chat__message-").concat(theme, "__actions__action--thread")
    }, /*#__PURE__*/React__default['default'].createElement(ThreadIcon, null)), shouldShowReactions && /*#__PURE__*/React__default['default'].createElement("div", {
      "data-testid": "message-reaction-action",
      className: "str-chat__message-".concat(theme, "__actions__action str-chat__message-").concat(theme, "__actions__action--reactions"),
      onClick: onReactionListClick
    }, /*#__PURE__*/React__default['default'].createElement(ReactionIcon, null)));
  }

  return /*#__PURE__*/React__default['default'].createElement("div", {
    "data-testid": "message-options",
    className: "str-chat__message-".concat(theme, "__actions")
  }, shouldShowReactions && /*#__PURE__*/React__default['default'].createElement("div", {
    "data-testid": "message-reaction-action",
    className: "str-chat__message-".concat(theme, "__actions__action str-chat__message-").concat(theme, "__actions__action--reactions"),
    onClick: onReactionListClick
  }, /*#__PURE__*/React__default['default'].createElement(ReactionIcon, null)), shouldShowReplies && /*#__PURE__*/React__default['default'].createElement("div", {
    onClick: propHandleOpenThread || handleOpenThread,
    "data-testid": "thread-action",
    className: "str-chat__message-".concat(theme, "__actions__action str-chat__message-").concat(theme, "__actions__action--thread")
  }, /*#__PURE__*/React__default['default'].createElement(ThreadIcon, null)), displayActions && /*#__PURE__*/React__default['default'].createElement(MessageActions, _extends__default['default']({}, props, {
    messageWrapperRef: messageWrapperRef
  })));
};

var MessageOptions = /*#__PURE__*/React__default['default'].memo(MessageOptionsComponent);

/**
 * @type { React.FC<import('../types').MessageTextProps> }
 */

var MessageTextComponent = function MessageTextComponent(props) {
  var _message$i18n;

  var _props$ReactionsList = props.ReactionsList,
      ReactionsList = _props$ReactionsList === void 0 ? DefaultReactionsList : _props$ReactionsList,
      _props$ReactionSelect = props.ReactionSelector,
      ReactionSelector = _props$ReactionSelect === void 0 ? DefaultReactionSelector : _props$ReactionSelect,
      propOnMentionsClick = props.onMentionsClickMessage,
      propOnMentionsHover = props.onMentionsHoverMessage,
      customWrapperClass = props.customWrapperClass,
      customInnerClass = props.customInnerClass,
      _props$theme = props.theme,
      theme = _props$theme === void 0 ? 'simple' : _props$theme,
      message = props.message,
      unsafeHTML = props.unsafeHTML,
      customOptionProps = props.customOptionProps;
  var reactionSelectorRef = React.useRef(
  /** @type {HTMLDivElement | null} */
  null);

  var _useMentionsUIHandler = useMentionsUIHandler(message, {
    onMentionsClick: propOnMentionsClick,
    onMentionsHover: propOnMentionsHover
  }),
      onMentionsClick = _useMentionsUIHandler.onMentionsClick,
      onMentionsHover = _useMentionsUIHandler.onMentionsHover;

  var _useReactionClick = useReactionClick(message, reactionSelectorRef),
      onReactionListClick = _useReactionClick.onReactionListClick,
      showDetailedReactions = _useReactionClick.showDetailedReactions,
      isReactionEnabled = _useReactionClick.isReactionEnabled;

  var _useContext = React.useContext(TranslationContext),
      t = _useContext.t,
      userLanguage = _useContext.userLanguage;

  var hasReactions = messageHasReactions(message);
  var hasAttachment = messageHasAttachments(message);
  var handleReaction = useReactionHandler(message);
  var messageTextToRender = (message === null || message === void 0 ? void 0 : (_message$i18n = message.i18n) === null || _message$i18n === void 0 ? void 0 : _message$i18n["".concat(userLanguage, "_text")]) || (message === null || message === void 0 ? void 0 : message.text);
  var messageMentionedUsersItem = message === null || message === void 0 ? void 0 : message.mentioned_users;
  var messageText = React.useMemo(function () {
    return renderText(messageTextToRender, messageMentionedUsersItem);
  }, [messageMentionedUsersItem, messageTextToRender]);
  var wrapperClass = customWrapperClass || 'str-chat__message-text';
  var innerClass = customInnerClass || "str-chat__message-text-inner str-chat__message-".concat(theme, "-text-inner");

  if (!(message !== null && message !== void 0 && message.text)) {
    return null;
  }

  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: wrapperClass
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    "data-testid": "message-text-inner-wrapper",
    className: "\n          ".concat(innerClass, "\n          ").concat(hasAttachment ? " str-chat__message-".concat(theme, "-text-inner--has-attachment") : '', "\n          ").concat(isOnlyEmojis(message.text) ? " str-chat__message-".concat(theme, "-text-inner--is-emoji") : '', "\n        ").trim(),
    onMouseOver: onMentionsHover,
    onClick: onMentionsClick
  }, message.type === 'error' && /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__".concat(theme, "-message--error-message")
  }, t && t('Error ¬∑ Unsent')), message.status === 'failed' && /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__".concat(theme, "-message--error-message")
  }, t && t('Message Failed ¬∑ Click to try again')), unsafeHTML && message.html ? /*#__PURE__*/React__default['default'].createElement("div", {
    dangerouslySetInnerHTML: {
      __html: message.html
    }
  }) : messageText, hasReactions && !showDetailedReactions && isReactionEnabled && /*#__PURE__*/React__default['default'].createElement(ReactionsList, {
    reactions: message.latest_reactions,
    reaction_counts: message.reaction_counts || undefined,
    own_reactions: message.own_reactions,
    onClick: onReactionListClick,
    reverse: true
  }), showDetailedReactions && isReactionEnabled && /*#__PURE__*/React__default['default'].createElement(ReactionSelector, {
    handleReaction: handleReaction,
    detailedView: true,
    reaction_counts: message.reaction_counts || undefined,
    latest_reactions: message.latest_reactions,
    own_reactions: message.own_reactions,
    ref: reactionSelectorRef
  })), /*#__PURE__*/React__default['default'].createElement(MessageOptions, _extends__default['default']({}, props, customOptionProps, {
    onReactionListClick: onReactionListClick
  })));
};

var MessageText = /*#__PURE__*/React__default['default'].memo(MessageTextComponent);

// @ts-check
/**
 * @type{React.FC<import('../types').MessageDeletedProps>}
 */

var MessageDeleted = function MessageDeleted(props) {
  var message = props.message;

  var _useContext = React.useContext(TranslationContext),
      t = _useContext.t;

  var _useUserRole = useUserRole(message),
      isMyMessage = _useUserRole.isMyMessage;

  if (props.isMyMessage) {
    console.warn('The isMyMessage is deprecated, and will be removed in the next major release.');
  }

  var messageClasses = props.isMyMessage && props.isMyMessage(message) || isMyMessage ? 'str-chat__message str-chat__message--me str-chat__message-simple str-chat__message-simple--me' : 'str-chat__message str-chat__message-simple';
  return /*#__PURE__*/React__default['default'].createElement("div", {
    key: message.id,
    className: "".concat(messageClasses, " str-chat__message--deleted ").concat(message.type, " "),
    "data-testid": 'message-deleted-component'
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__message--deleted-inner"
  }, t && t('This message was deleted...')));
};

MessageDeleted.propTypes = {
  /** The [message object](https://getstream.io/chat/docs/#message_format) */
  // @ts-ignore
  // Ignoring this for now as Typescript definitions on 'strem-chat' are wrong.
  message: MessagePropTypes,

  /** @deprecated This is no longer needed. The component should now rely on the user role custom hook */
  isMyMessage: PropTypes__default['default'].func
};

// @ts-check
var defaultTimestampFormat = 'h:mmA';
var notValidDateWarning = 'MessageTimestamp was called without a message, or message has invalid created_at date.';
var noParsingFunctionWarning = 'MessageTimestamp was called but there is no datetime parsing function available';
/**
 * @type { (
 *   messageCreatedAt?: string,
 *   formatDate?: import('../types').MessageTimestampProps['formatDate'],
 *   calendar?: boolean,
 *   tDateTimeParser?: import('../types').MessageTimestampProps['tDateTimeParser'],
 *   format?: string,
 * ) => string | null }
 */

function getDateString(messageCreatedAt, formatDate, calendar, tDateTimeParser, format) {
  if (!messageCreatedAt || !Date.parse(messageCreatedAt)) {
    console.warn(notValidDateWarning);
    return null;
  }

  if (typeof formatDate === 'function') {
    return formatDate(new Date(messageCreatedAt));
  }

  if (!tDateTimeParser) {
    console.warn(noParsingFunctionWarning);
    return null;
  }

  var parsedTime = tDateTimeParser(messageCreatedAt);

  if (calendar && typeof parsedTime.calendar !== 'function') {
    return null;
  }

  return calendar ? parsedTime.calendar() : parsedTime.format(format);
}
/**
 * @typedef { import('../types').MessageTimestampProps } Props
 * @type { React.FC<Props> }
 */


var MessageTimestamp = function MessageTimestamp(props) {
  var message = props.message,
      formatDate = props.formatDate,
      propTDatetimeParser = props.tDateTimeParser,
      _props$customClass = props.customClass,
      customClass = _props$customClass === void 0 ? '' : _props$customClass,
      _props$format = props.format,
      format = _props$format === void 0 ? defaultTimestampFormat : _props$format,
      _props$calendar = props.calendar,
      calendar = _props$calendar === void 0 ? false : _props$calendar;

  var _useContext = React.useContext(TranslationContext),
      contextTDateTimeParser = _useContext.tDateTimeParser;

  var tDateTimeParser = propTDatetimeParser || contextTDateTimeParser;
  var createdAt = message === null || message === void 0 ? void 0 : message.created_at;
  var when = React.useMemo(function () {
    return getDateString(createdAt, formatDate, calendar, tDateTimeParser, format);
  }, [formatDate, calendar, tDateTimeParser, format, createdAt]);

  if (!when) {
    return null;
  }

  return /*#__PURE__*/React__default['default'].createElement("time", {
    className: customClass,
    dateTime: createdAt,
    title: createdAt
  }, when);
};

var MessageTimestamp$1 = /*#__PURE__*/React__default['default'].memo(MessageTimestamp);

/**
 * MessageSimple - Render component, should be used together with the Message component
 *
 * @example ../../docs/MessageSimple.md
 * @type { React.FC<import('../types').MessageSimpleProps> }
 */
// eslint-disable-next-line sonarjs/cognitive-complexity

var MessageSimple = function MessageSimple(props) {
  var clearEditingState = props.clearEditingState,
      editing = props.editing,
      _props$EditMessageInp = props.EditMessageInput,
      EditMessageInput = _props$EditMessageInp === void 0 ? EditMessageForm : _props$EditMessageInp,
      message = props.message,
      threadList = props.threadList,
      formatDate = props.formatDate,
      propUpdateMessage = props.updateMessage,
      propHandleAction = props.handleAction,
      propHandleOpenThread = props.handleOpenThread,
      propHandleReaction = props.handleReaction,
      propHandleRetry = props.handleRetry,
      onUserClickCustomHandler = props.onUserClick,
      onUserHoverCustomHandler = props.onUserHover,
      propTDateTimeParser = props.tDateTimeParser;

  var _useContext = React.useContext(ChannelContext),
      channelUpdateMessage = _useContext.updateMessage;

  var updateMessage = propUpdateMessage || channelUpdateMessage;

  var _useUserRole = useUserRole(message),
      isMyMessage = _useUserRole.isMyMessage;

  var handleOpenThread = useOpenThreadHandler(message);
  var handleReaction = useReactionHandler(message);
  var handleAction = useActionHandler(message);
  var handleRetry = useRetryHandler();

  var _useUserHandler = useUserHandler(message, {
    onUserClickHandler: onUserClickCustomHandler,
    onUserHoverHandler: onUserHoverCustomHandler
  }),
      onUserClick = _useUserHandler.onUserClick,
      onUserHover = _useUserHandler.onUserHover;

  var reactionSelectorRef = /*#__PURE__*/React__default['default'].createRef();
  var messageWrapperRef = React.useRef(null);

  var _useReactionClick = useReactionClick(message, reactionSelectorRef),
      onReactionListClick = _useReactionClick.onReactionListClick,
      showDetailedReactions = _useReactionClick.showDetailedReactions,
      isReactionEnabled = _useReactionClick.isReactionEnabled;

  var _props$Attachment = props.Attachment,
      Attachment$1 = _props$Attachment === void 0 ? Attachment : _props$Attachment,
      _props$Avatar = props.Avatar,
      Avatar$1 = _props$Avatar === void 0 ? Avatar : _props$Avatar,
      _props$MessageDeleted = props.MessageDeleted,
      MessageDeleted$1 = _props$MessageDeleted === void 0 ? MessageDeleted : _props$MessageDeleted,
      _props$ReactionSelect = props.ReactionSelector,
      ReactionSelector = _props$ReactionSelect === void 0 ? DefaultReactionSelector : _props$ReactionSelect,
      _props$ReactionsList = props.ReactionsList,
      ReactionsList = _props$ReactionsList === void 0 ? DefaultReactionsList : _props$ReactionsList;
  var hasReactions = messageHasReactions(message);
  var hasAttachment = messageHasAttachments(message);
  var messageClasses = isMyMessage ? 'str-chat__message str-chat__message--me str-chat__message-simple str-chat__message-simple--me' : 'str-chat__message str-chat__message-simple';

  if ((message === null || message === void 0 ? void 0 : message.type) === 'message.read' || (message === null || message === void 0 ? void 0 : message.type) === 'message.date') {
    return null;
  }

  if (message !== null && message !== void 0 && message.deleted_at) {
    return smartRender(MessageDeleted$1, {
      message
    }, null);
  }

  return /*#__PURE__*/React__default['default'].createElement(React__default['default'].Fragment, null, editing && /*#__PURE__*/React__default['default'].createElement(Modal, {
    open: editing,
    onClose: clearEditingState
  }, /*#__PURE__*/React__default['default'].createElement(MessageInput$1, _extends__default['default']({
    Input: EditMessageInput,
    message: message,
    clearEditingState: clearEditingState,
    updateMessage: updateMessage
  }, props.additionalMessageInputProps))), message && /*#__PURE__*/React__default['default'].createElement("div", {
    key: message.id || '',
    className: "\n\t\t\t\t\t\t".concat(messageClasses, "\n\t\t\t\t\t\tstr-chat__message--").concat(message.type, "\n\t\t\t\t\t\tstr-chat__message--").concat(message.status, "\n\t\t\t\t\t\t").concat(message.text ? 'str-chat__message--has-text' : 'has-no-text', "\n\t\t\t\t\t\t").concat(hasAttachment ? 'str-chat__message--has-attachment' : '', "\n            ").concat(hasReactions && isReactionEnabled ? 'str-chat__message--with-reactions' : '', "\n            ").concat(message !== null && message !== void 0 && message.pinned ? 'pinned-message' : '', "\n\t\t\t\t\t").trim(),
    ref: messageWrapperRef
  }, /*#__PURE__*/React__default['default'].createElement(MessageSimpleStatus, props), message.user && /*#__PURE__*/React__default['default'].createElement(Avatar$1, {
    image: message.user.image,
    name: message.user.name || message.user.id,
    onClick: onUserClick,
    onMouseOver: onUserHover
  }), /*#__PURE__*/React__default['default'].createElement("div", {
    "data-testid": "message-inner",
    className: "str-chat__message-inner",
    onClick: function onClick() {
      if (message.status === 'failed' && (propHandleRetry || handleRetry)) {
        var retryHandler = propHandleRetry || handleRetry; // FIXME: type checking fails here because in the case of a failed message,
        // `message` is of type Client.Message (i.e. request object)
        // instead of Client.MessageResponse (i.e. server response object)
        // @ts-ignore

        retryHandler(message);
      }
    }
  }, !message.text && /*#__PURE__*/React__default['default'].createElement(React__default['default'].Fragment, null, /*#__PURE__*/React__default['default'].createElement(MessageOptions, _extends__default['default']({}, props, {
    messageWrapperRef: messageWrapperRef,
    onReactionListClick: onReactionListClick,
    handleOpenThread: propHandleOpenThread
  })), hasReactions && !showDetailedReactions && isReactionEnabled && /*#__PURE__*/React__default['default'].createElement(ReactionsList, {
    reactions: message.latest_reactions,
    reaction_counts: message.reaction_counts || undefined,
    own_reactions: message.own_reactions,
    onClick: onReactionListClick,
    reverse: true
  }), showDetailedReactions && isReactionEnabled && /*#__PURE__*/React__default['default'].createElement(ReactionSelector, {
    handleReaction: propHandleReaction || handleReaction,
    detailedView: true,
    reaction_counts: message.reaction_counts || undefined,
    latest_reactions: message.latest_reactions,
    own_reactions: message.own_reactions,
    ref: reactionSelectorRef
  })), (message === null || message === void 0 ? void 0 : message.attachments) && Attachment$1 && /*#__PURE__*/React__default['default'].createElement(Attachment$1, {
    attachments: message.attachments,
    actionHandler: propHandleAction || handleAction
  }), message.text && /*#__PURE__*/React__default['default'].createElement(MessageText, _extends__default['default']({}, props, {
    customOptionProps: {
      messageWrapperRef,
      handleOpenThread: propHandleOpenThread
    } // FIXME: There's some unmatched definition between the infered and the declared
    // ReactionSelector reference
    // @ts-ignore
    ,
    reactionSelectorRef: reactionSelectorRef
  })), message.mml && /*#__PURE__*/React__default['default'].createElement(MML, {
    source: message.mml,
    actionHandler: handleAction,
    align: isMyMessage ? 'right' : 'left'
  }), !threadList && message.reply_count !== 0 && /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__message-simple-reply-button"
  }, /*#__PURE__*/React__default['default'].createElement(MessageRepliesCountButton$1, {
    onClick: propHandleOpenThread || handleOpenThread,
    reply_count: message.reply_count
  })), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__message-data str-chat__message-simple-data"
  }, !isMyMessage && message.user ? /*#__PURE__*/React__default['default'].createElement("span", {
    className: "str-chat__message-simple-name"
  }, message.user.name || message.user.id) : null, /*#__PURE__*/React__default['default'].createElement(MessageTimestamp$1, {
    customClass: "str-chat__message-simple-timestamp",
    tDateTimeParser: propTDateTimeParser,
    formatDate: formatDate,
    message: message,
    calendar: true
  })))));
};
/** @type { React.FC<import('../types').MessageSimpleProps> } */


var MessageSimpleStatus = function MessageSimpleStatus(_ref) {
  var _client$user;

  var _ref$Avatar = _ref.Avatar,
      Avatar$1 = _ref$Avatar === void 0 ? Avatar : _ref$Avatar,
      readBy = _ref.readBy,
      message = _ref.message,
      threadList = _ref.threadList,
      lastReceivedId = _ref.lastReceivedId;

  var _useContext2 = React.useContext(TranslationContext),
      t = _useContext2.t;

  var _useContext3 = React.useContext(ChannelContext),
      client = _useContext3.client;

  var _useUserRole2 = useUserRole(message),
      isMyMessage = _useUserRole2.isMyMessage;

  if (!isMyMessage || (message === null || message === void 0 ? void 0 : message.type) === 'error') {
    return null;
  }

  var justReadByMe = readBy && readBy.length === 1 && readBy[0] && client && readBy[0].id === ((_client$user = client.user) === null || _client$user === void 0 ? void 0 : _client$user.id);

  if (message && message.status === 'sending') {
    return /*#__PURE__*/React__default['default'].createElement("span", {
      className: "str-chat__message-simple-status",
      "data-testid": "message-status-sending"
    }, /*#__PURE__*/React__default['default'].createElement(Tooltip$1, null, t && t('Sending...')), /*#__PURE__*/React__default['default'].createElement(DefaultLoadingIndicator, null));
  }

  if (readBy && readBy.length !== 0 && !threadList && !justReadByMe) {
    var lastReadUser = readBy.filter(
    /** @type {(item: import('stream-chat').UserResponse) => boolean} Typescript syntax */
    function (item) {
      var _client$user2;

      return !!item && !!client && item.id !== ((_client$user2 = client.user) === null || _client$user2 === void 0 ? void 0 : _client$user2.id);
    })[0];
    return /*#__PURE__*/React__default['default'].createElement("span", {
      className: "str-chat__message-simple-status",
      "data-testid": "message-status-read-by"
    }, /*#__PURE__*/React__default['default'].createElement(Tooltip$1, null, readBy && getReadByTooltipText(readBy, t, client)), /*#__PURE__*/React__default['default'].createElement(Avatar$1, {
      name: lastReadUser === null || lastReadUser === void 0 ? void 0 : lastReadUser.name,
      image: lastReadUser === null || lastReadUser === void 0 ? void 0 : lastReadUser.image,
      size: 15
    }), readBy.length > 2 && /*#__PURE__*/React__default['default'].createElement("span", {
      className: "str-chat__message-simple-status-number",
      "data-testid": "message-status-read-by-many"
    }, readBy.length - 1));
  }

  if (message && message.status === 'received' && message.id === lastReceivedId && !threadList) {
    return /*#__PURE__*/React__default['default'].createElement("span", {
      className: "str-chat__message-simple-status",
      "data-testid": "message-status-received"
    }, /*#__PURE__*/React__default['default'].createElement(Tooltip$1, null, t && t('Delivered')), /*#__PURE__*/React__default['default'].createElement(DeliveredCheckIcon, null));
  }

  return null;
};

MessageSimple.propTypes = {
  /** The [message object](https://getstream.io/chat/docs/#message_format) */
  message:
  /** @type {PropTypes.Validator<import('stream-chat').MessageResponse>} */
  PropTypes__default['default'].object.isRequired,

  /**
   * The attachment UI component.
   * Default: [Attachment](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Attachment.js)
   * */
  Attachment:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').WrapperAttachmentUIComponentProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * Custom UI component to display user avatar
   *
   * Defaults to and accepts same props as: [Avatar](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Avatar/Avatar.js)
   * */
  Avatar:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').AvatarProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * Custom UI component to override default edit message input
   *
   * Defaults to and accepts same props as: [EditMessageForm](https://github.com/GetStream/stream-chat-react/blob/master/src/components/MessageInput/EditMessageForm.js)
   * */
  EditMessageInput:
  /** @type {PropTypes.Validator<React.FC<import("types").MessageInputProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * @deprecated Its not recommended to use this anymore. All the methods in this HOC are provided explicitly.
   *
   * The higher order message component, most logic is delegated to this component
   * @see See [Message HOC](https://getstream.github.io/stream-chat-react/#message) for example
   *
   * */
  Message:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').MessageUIComponentProps>>} */
  PropTypes__default['default'].oneOfType([PropTypes__default['default'].node, PropTypes__default['default'].func, PropTypes__default['default'].object]),

  /** render HTML instead of markdown. Posting HTML is only allowed server-side */
  unsafeHTML: PropTypes__default['default'].bool,

  /** Client object */
  // @ts-ignore
  client: PropTypes__default['default'].object,

  /** If its parent message in thread. */
  initialMessage: PropTypes__default['default'].bool,

  /** Channel config object */
  channelConfig:
  /** @type {PropTypes.Validator<import('stream-chat').ChannelConfig>} */
  PropTypes__default['default'].object,

  /** Override the default formatting of the date. This is a function that has access to the original date object. Returns a string or Node  */
  formatDate: PropTypes__default['default'].func,

  /** If component is in thread list */
  threadList: PropTypes__default['default'].bool,

  /**
   * Function to open thread on current message
   * @deprecated The component now relies on the useThreadHandler custom hook
   * You can customize the behaviour for your thread handler on the <Channel> component instead.
   */
  handleOpenThread: PropTypes__default['default'].func,

  /** If the message is in edit state */
  editing: PropTypes__default['default'].bool,

  /** Function to exit edit state */
  clearEditingState: PropTypes__default['default'].func,

  /** Returns true if message belongs to current user */
  isMyMessage: PropTypes__default['default'].func,

  /**
   * Returns all allowed actions on message by current user e.g., ['edit', 'delete', 'flag', 'mute', 'react', 'reply']
   * Please check [Message](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Message.js) component for default implementation.
   * */
  getMessageActions: PropTypes__default['default'].func.isRequired,

  /**
   * Function to publish updates on message to channel
   *
   * @param message Updated [message object](https://getstream.io/chat/docs/#message_format)
   * */
  updateMessage: PropTypes__default['default'].func,

  /**
   * Reattempt sending a message
   * @param message A [message object](https://getstream.io/chat/docs/#message_format) to resent.
   * @deprecated This component now relies on the useRetryHandler custom hook.
   */
  handleRetry: PropTypes__default['default'].func,

  /**
   * Add or remove reaction on message
   *
   * @param type Type of reaction - 'like' | 'love' | 'haha' | 'wow' | 'sad' | 'angry'
   * @param event Dom event which triggered this function
   * @deprecated This component now relies on the useReactionHandler custom hook.
   */
  handleReaction: PropTypes__default['default'].func,

  /**
   * A component to display the selector that allows a user to react to a certain message.
   */
  ReactionSelector:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').ReactionSelectorProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * A component to display the a message list of reactions.
   */
  ReactionsList:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').ReactionsListProps>>} */
  PropTypes__default['default'].elementType,

  /** If actions such as edit, delete, flag, mute are enabled on message */
  actionsEnabled: PropTypes__default['default'].bool,

  /** DOMRect object for parent MessageList component */
  messageListRect: PropTypes__default['default'].shape({
    x: PropTypes__default['default'].number.isRequired,
    y: PropTypes__default['default'].number.isRequired,
    height: PropTypes__default['default'].number.isRequired,
    width: PropTypes__default['default'].number.isRequired,
    top: PropTypes__default['default'].number.isRequired,
    right: PropTypes__default['default'].number.isRequired,
    bottom: PropTypes__default['default'].number.isRequired,
    left: PropTypes__default['default'].number.isRequired,
    toJSON: PropTypes__default['default'].func.isRequired
  }),

  /**
   * @param name {string} Name of action
   * @param value {string} Value of action
   * @param event Dom event that triggered this handler
   * @deprecated This component now relies on the useActionHandler custom hook, and this prop will be removed on the next major release.
   */
  handleAction: PropTypes__default['default'].func,

  /**
   * The handler for hover event on @mention in message
   *
   * @param event Dom hover event which triggered handler.
   * @param user Target user object
   * @deprecated This component now relies on the useMentionsHandler custom hook, and this prop will be removed on the next major release.
   * You can customize the behaviour for your mention handler on the <Channel> component instead.
   */
  onMentionsHoverMessage: PropTypes__default['default'].func,

  /**
   * The handler for click event on @mention in message
   *
   * @param event Dom click event which triggered handler.
   * @param user Target user object
   * @deprecated This component now relies on the useMentionsHandler custom hook, and this prop will be removed on the next major release.
   * You can customize the behaviour for your mention handler on the <Channel> component instead.
   */
  onMentionsClickMessage: PropTypes__default['default'].func,

  /**
   * The handler for click event on the user that posted the message
   *
   * @param event Dom click event which triggered handler.
   */
  onUserClick: PropTypes__default['default'].func,

  /**
   * The handler for mouseOver event on the user that posted the message
   *
   * @param event Dom mouseOver event which triggered handler.
   */
  onUserHover: PropTypes__default['default'].func,

  /**
   * Additional props for underlying MessageInput component.
   * Available props - https://getstream.github.io/stream-chat-react/#messageinput
   * */
  additionalMessageInputProps: PropTypes__default['default'].object,

  /**
   * The component that will be rendered if the message has been deleted.
   * All of Message's props are passed into this component.
   */
  MessageDeleted:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').MessageDeletedProps>>} */
  PropTypes__default['default'].elementType
};
var MessageSimple$1 = /*#__PURE__*/React__default['default'].memo(MessageSimple, areMessagePropsEqual);

/**
 * Message - A high level component which implements all the logic required for a message.
 * The actual rendering of the message is delegated via the "Message" property
 *
 * @example ../../docs/Message.md
 * @type { React.FC<import('../types').MessageComponentProps> }
 */

var Message = function Message(props) {
  var addNotification = props.addNotification,
      propChannel = props.channel,
      formatDate = props.formatDate,
      getFlagMessageErrorNotification = props.getFlagMessageErrorNotification,
      getFlagMessageSuccessNotification = props.getFlagMessageSuccessNotification,
      getMuteUserErrorNotification = props.getMuteUserErrorNotification,
      getMuteUserSuccessNotification = props.getMuteUserSuccessNotification,
      getPinMessageErrorNotification = props.getPinMessageErrorNotification,
      _props$groupStyles = props.groupStyles,
      groupStyles = _props$groupStyles === void 0 ? [] : _props$groupStyles,
      _props$Message = props.Message,
      MessageUIComponent = _props$Message === void 0 ? MessageSimple$1 : _props$Message,
      message = props.message,
      _props$messageActions = props.messageActions,
      messageActions = _props$messageActions === void 0 ? Object.keys(MESSAGE_ACTIONS) : _props$messageActions,
      propOnMentionsClick = props.onMentionsClick,
      propOnMentionsHover = props.onMentionsHover,
      propOnUserClick = props.onUserClick,
      propOnUserHover = props.onUserHover,
      propOpenThread = props.openThread,
      _props$pinPermissions = props.pinPermissions,
      pinPermissions = _props$pinPermissions === void 0 ? defaultPinPermissions : _props$pinPermissions,
      propRetrySendMessage = props.retrySendMessage;

  var _useContext = React.useContext(ChannelContext),
      contextChannel = _useContext.channel;

  var channel = propChannel || contextChannel;
  var channelConfig = (channel === null || channel === void 0 ? void 0 : channel.getConfig) && channel.getConfig();
  var handleAction = useActionHandler(message);
  var handleDelete = useDeleteHandler(message);

  var _useEditHandler = useEditHandler(),
      editing = _useEditHandler.editing,
      setEdit = _useEditHandler.setEdit,
      clearEdit = _useEditHandler.clearEdit;

  var handleOpenThread = useOpenThreadHandler(message, propOpenThread);
  var handleReaction = useReactionHandler(message);
  var handleRetry = useRetryHandler(propRetrySendMessage);
  var handleFlag = useFlagHandler(message, {
    notify: addNotification,
    getSuccessNotification: getFlagMessageSuccessNotification,
    getErrorNotification: getFlagMessageErrorNotification
  });
  var handleMute = useMuteHandler(message, {
    notify: addNotification,
    getSuccessNotification: getMuteUserSuccessNotification,
    getErrorNotification: getMuteUserErrorNotification
  });

  var _useMentionsHandler = useMentionsHandler(message, {
    onMentionsClick: propOnMentionsClick,
    onMentionsHover: propOnMentionsHover
  }),
      onMentionsClick = _useMentionsHandler.onMentionsClick,
      onMentionsHover = _useMentionsHandler.onMentionsHover;

  var _usePinHandler = usePinHandler(message, pinPermissions, {
    notify: addNotification,
    getErrorNotification: getPinMessageErrorNotification
  }),
      canPin = _usePinHandler.canPin,
      handlePin = _usePinHandler.handlePin;

  var _useUserHandler = useUserHandler(message, {
    onUserClickHandler: propOnUserClick,
    onUserHoverHandler: propOnUserHover
  }),
      onUserClick = _useUserHandler.onUserClick,
      onUserHover = _useUserHandler.onUserHover;

  var _useUserRole = useUserRole(message),
      _isMyMessage = _useUserRole.isMyMessage,
      isAdmin = _useUserRole.isAdmin,
      isModerator = _useUserRole.isModerator,
      isOwner = _useUserRole.isOwner;

  var canEdit = _isMyMessage || isModerator || isOwner || isAdmin;
  var canDelete = canEdit;
  var canReact = true;
  var canReply = true;
  var messageActionsHandler = React.useCallback(function () {
    if (!message || !messageActions) {
      return [];
    }

    return getMessageActions(messageActions, {
      canDelete,
      canEdit,
      canPin,
      canReply,
      canReact,
      canFlag: !_isMyMessage,
      canMute: !_isMyMessage && !!(channelConfig !== null && channelConfig !== void 0 && channelConfig.mutes)
    });
  }, [canDelete, canEdit, canPin, canReply, canReact, channelConfig === null || channelConfig === void 0 ? void 0 : channelConfig.mutes, _isMyMessage, message, messageActions]);
  var actionsEnabled = message && message.type === 'regular' && message.status === 'received';
  return MessageUIComponent && /*#__PURE__*/React__default['default'].createElement(MessageUIComponent, _extends__default['default']({}, props, {
    actionsEnabled: actionsEnabled,
    channelConfig: channelConfig,
    clearEditingState: clearEdit,
    editing: editing,
    formatDate: formatDate,
    getMessageActions: messageActionsHandler,
    groupStyles: groupStyles,
    handleAction: handleAction,
    handleDelete: handleDelete,
    handleEdit: setEdit,
    handleFlag: handleFlag,
    handleMute: handleMute,
    handlePin: handlePin,
    handleReaction: handleReaction,
    handleRetry: handleRetry,
    handleOpenThread: handleOpenThread,
    isMyMessage: function isMyMessage() {
      return _isMyMessage;
    },
    Message: MessageUIComponent,
    onMentionsClickMessage: onMentionsClick,
    onMentionsHoverMessage: onMentionsHover,
    onUserClick: onUserClick,
    onUserHover: onUserHover,
    setEditingState: setEdit
  }));
};

Message.propTypes = {
  /** The message object */
  message:
  /** @type {PropTypes.Validator<import('stream-chat').MessageResponse>} */
  PropTypes__default['default'].shape({
    text: PropTypes__default['default'].string.isRequired,
    html: PropTypes__default['default'].string.isRequired,
    type: PropTypes__default['default'].string.isRequired,
    reaction_counts: PropTypes__default['default'].objectOf(PropTypes__default['default'].number.isRequired),
    reaction_scores: PropTypes__default['default'].objectOf(PropTypes__default['default'].number.isRequired),
    created_at: PropTypes__default['default'].oneOfType([PropTypes__default['default'].string, PropTypes__default['default'].object]),
    updated_at: PropTypes__default['default'].oneOfType([PropTypes__default['default'].string, PropTypes__default['default'].object])
  }).isRequired,

  /** The client connection object for connecting to Stream */
  client:
  /** @type {PropTypes.Validator<import('../types').StreamChatReactClient>} */
  PropTypes__default['default'].objectOf(checkClientPropType),

  /** The current channel this message is displayed in */
  channel:
  /** @type {PropTypes.Validator<ReturnType<import('../types').StreamChatReactClient['channel']>>} */
  PropTypes__default['default'].objectOf(checkChannelPropType),

  /** A list of users that have read this message */
  readBy: PropTypes__default['default'].array,

  /** groupStyles, a list of styles to apply to this message. ie. top, bottom, single etc */
  groupStyles: PropTypes__default['default'].array,

  /** Override the default formatting of the date. This is a function that has access to the original date object. Returns a string or Node  */
  formatDate: PropTypes__default['default'].func,

  /**
   * Custom UI component to display user avatar
   *
   * Defaults to and accepts same props as: [Avatar](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Avatar/Avatar.js)
   * */
  Avatar:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').AvatarProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * Message UI component to display a message in message list.
   * Available from [channel context](https://getstream.github.io/stream-chat-react/#channelcontext)
   * */
  Message:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').MessageUIComponentProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * The component that will be rendered if the message has been deleted.
   * All props are passed into this component.
   */
  MessageDeleted:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').MessageDeletedProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * A component to display the selector that allows a user to react to a certain message.
   */
  ReactionSelector:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').ReactionSelectorProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * A component to display the a message list of reactions.
   */
  ReactionsList:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').ReactionsListProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * Attachment UI component to display attachment in individual message.
   * Available from [channel context](https://getstream.github.io/stream-chat-react/#channelcontext)
   * */
  Attachment:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').WrapperAttachmentUIComponentProps>>} */
  PropTypes__default['default'].elementType,

  /** render HTML instead of markdown. Posting HTML is only allowed server-side */
  unsafeHTML: PropTypes__default['default'].bool,

  /**
   * Array of allowed actions on message. e.g. ['edit', 'delete', 'flag', 'mute', 'react', 'reply']
   * If all the actions need to be disabled, empty array or false should be provided as value of prop.
   * */
  messageActions: PropTypes__default['default'].oneOfType([PropTypes__default['default'].bool, PropTypes__default['default'].array]),

  /**
   * Function that returns message/text as string to be shown as notification, when request for flagging a message is successful
   *
   * This function should accept following params:
   *
   * @param message A [message object](https://getstream.io/chat/docs/#message_format) which is flagged.
   *
   * */
  getFlagMessageSuccessNotification: PropTypes__default['default'].func,

  /**
   * Function that returns message/text as string to be shown as notification, when request for flagging a message runs into error
   *
   * This function should accept following params:
   *
   * @param message A [message object](https://getstream.io/chat/docs/#message_format) which is flagged.
   *
   * */
  getFlagMessageErrorNotification: PropTypes__default['default'].func,

  /**
   * Function that returns message/text as string to be shown as notification, when request for muting a user is successful
   *
   * This function should accept following params:
   *
   * @param user A user object which is being muted
   *
   * */
  getMuteUserSuccessNotification: PropTypes__default['default'].func,

  /**
   * Function that returns message/text as string to be shown as notification, when request for muting a user runs into error
   *
   * This function should accept following params:
   *
   * @param user A user object which is being muted
   *
   * */
  getMuteUserErrorNotification: PropTypes__default['default'].func,

  /**
   * Function that returns message/text as string to be shown as notification, when request for pinning a message runs into error
   *
   * This function should accept following params:
   *
   * @param message A [message object](https://getstream.io/chat/docs/#message_format)
   *
   * */
  getPinMessageErrorNotification: PropTypes__default['default'].func,

  /** Latest message id on current channel */
  lastReceivedId: PropTypes__default['default'].string,

  /** DOMRect object for parent MessageList component */
  messageListRect:
  /** @type {PropTypes.Validator<DOMRect>} */
  PropTypes__default['default'].object,

  /** @see See [Channel Context](https://getstream.github.io/stream-chat-react/#channelcontext) */
  members:
  /** @type {PropTypes.Validator<import('seamless-immutable').ImmutableObject<{[user_id: string]: import('stream-chat').ChannelMemberResponse<import('../types').StreamChatReactUserType>}> | null | undefined>} */
  PropTypes__default['default'].object,

  /**
   * Function to add custom notification on message list
   *
   * @param text Notification text to display
   * @param type Type of notification. 'success' | 'error'
   * */
  addNotification: PropTypes__default['default'].func,

  /** @see See [Channel Context](https://getstream.github.io/stream-chat-react/#channelcontext) */
  updateMessage: PropTypes__default['default'].func,

  /** @see See [Channel Context](https://getstream.github.io/stream-chat-react/#channelcontext) */
  removeMessage: PropTypes__default['default'].func,

  /** @see See [Channel Context](https://getstream.github.io/stream-chat-react/#channelcontext) */
  retrySendMessage: PropTypes__default['default'].func,

  /** @see See [Channel Context](https://getstream.github.io/stream-chat-react/#channelcontext) */
  onMentionsClick: PropTypes__default['default'].func,

  /** @see See [Channel Context](https://getstream.github.io/stream-chat-react/#channelcontext) */
  onMentionsHover: PropTypes__default['default'].func,

  /**
   * The handler for click event on the user that posted the message
   *
   * @param event Dom click event which triggered handler.
   * @param user the User object for the corresponding user.
   */
  onUserClick: PropTypes__default['default'].func,

  /**
   * The handler for hover events on the user that posted the message
   *
   * @param event Dom hover event which triggered handler.
   * @param user the User object for the corresponding user.
   */
  onUserHover: PropTypes__default['default'].func,

  /** @see See [Channel Context](https://getstream.github.io/stream-chat-react/#channelcontext) */
  openThread: PropTypes__default['default'].func,

  /**
   * Additional props for underlying MessageInput component.
   * Available props - https://getstream.github.io/stream-chat-react/#messageinput
   * */
  additionalMessageInputProps: PropTypes__default['default'].object,

  /**
   * The user roles allowed to pin messages in various channel types
   */
  pinPermissions:
  /** @type {PropTypes.Validator<import('../types').PinPermissions>>} */
  PropTypes__default['default'].object
};
Message.defaultProps = {
  readBy: []
};
var Message$1 = /*#__PURE__*/React__default['default'].memo(Message, areMessagePropsEqual);

/**
 * MessageCommerce - Render component, should be used together with the Message component
 *
 * @example ../../docs/MessageCommerce.md
 * @type { React.FC<import('../types').MessageCommerceProps> }
 */
// eslint-disable-next-line sonarjs/cognitive-complexity

var MessageCommerce = function MessageCommerce(props) {
  var _message$user, _message$user2, _message$user3, _message$user4, _message$user5;

  var message = props.message,
      formatDate = props.formatDate,
      groupStyles = props.groupStyles,
      actionsEnabled = props.actionsEnabled,
      threadList = props.threadList,
      MessageDeleted = props.MessageDeleted,
      getMessageActions = props.getMessageActions,
      _props$ReactionsList = props.ReactionsList,
      ReactionsList = _props$ReactionsList === void 0 ? DefaultReactionsList : _props$ReactionsList,
      _props$ReactionSelect = props.ReactionSelector,
      ReactionSelector = _props$ReactionSelect === void 0 ? DefaultReactionSelector : _props$ReactionSelect,
      propHandleReaction = props.handleReaction,
      propHandleAction = props.handleAction,
      propHandleOpenThread = props.handleOpenThread,
      propOnUserClick = props.onUserClick,
      propOnUserHover = props.onUserHover,
      propTDateTimeParser = props.tDateTimeParser;
  var Attachment$1 = props.Attachment || Attachment;
  var Avatar$1 = props.Avatar || Avatar;
  var hasReactions = messageHasReactions(message);
  var handleAction = useActionHandler(message);
  var handleReaction = useReactionHandler(message);
  var handleOpenThread = useOpenThreadHandler(message);
  var reactionSelectorRef = React.useRef(null);

  var _useReactionClick = useReactionClick(message, reactionSelectorRef),
      onReactionListClick = _useReactionClick.onReactionListClick,
      showDetailedReactions = _useReactionClick.showDetailedReactions,
      isReactionEnabled = _useReactionClick.isReactionEnabled;

  var _useUserHandler = useUserHandler(message, {
    onUserClickHandler: propOnUserClick,
    onUserHoverHandler: propOnUserHover
  }),
      onUserClick = _useUserHandler.onUserClick,
      onUserHover = _useUserHandler.onUserHover;

  var _useUserRole = useUserRole(message),
      isMyMessage = _useUserRole.isMyMessage;

  var messageClasses = "str-chat__message-commerce str-chat__message-commerce--".concat(isMyMessage ? 'right' : 'left');
  var hasAttachment = messageHasAttachments(message);
  var firstGroupStyle = groupStyles ? groupStyles[0] : '';

  if (message !== null && message !== void 0 && message.deleted_at) {
    return smartRender(MessageDeleted, props, null);
  }

  if (message && (message.type === 'message.read' || message.type === 'message.date')) {
    return null;
  } // eslint-disable-next-line sonarjs/cognitive-complexity


  return /*#__PURE__*/React__default['default'].createElement(React__default['default'].Fragment, null, /*#__PURE__*/React__default['default'].createElement("div", {
    "data-testid": "message-commerce-wrapper",
    key: (message === null || message === void 0 ? void 0 : message.id) || '',
    className: "\n\t\t\t\t\t\t".concat(messageClasses, "\n\t\t\t\t\t\tstr-chat__message-commerce--").concat(message === null || message === void 0 ? void 0 : message.type, "\n\t\t\t\t\t\t").concat(message !== null && message !== void 0 && message.text ? 'str-chat__message-commerce--has-text' : 'str-chat__message-commerce--has-no-text', "\n\t\t\t\t\t\t").concat(hasAttachment ? 'str-chat__message-commerce--has-attachment' : '', "\n\t\t\t\t\t\t").concat(hasReactions && isReactionEnabled ? 'str-chat__message-commerce--with-reactions' : '', "\n            ", "str-chat__message-commerce--".concat(firstGroupStyle), "\n            ").concat(message !== null && message !== void 0 && message.pinned ? 'pinned-message' : '', "\n\t\t\t\t\t").trim()
  }, (firstGroupStyle === 'bottom' || firstGroupStyle === 'single') && /*#__PURE__*/React__default['default'].createElement(Avatar$1, {
    image: message === null || message === void 0 ? void 0 : (_message$user = message.user) === null || _message$user === void 0 ? void 0 : _message$user.image,
    size: 32,
    name: (message === null || message === void 0 ? void 0 : (_message$user2 = message.user) === null || _message$user2 === void 0 ? void 0 : _message$user2.name) || (message === null || message === void 0 ? void 0 : (_message$user3 = message.user) === null || _message$user3 === void 0 ? void 0 : _message$user3.id),
    onClick: onUserClick,
    onMouseOver: onUserHover
  }), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__message-commerce-inner"
  }, message && !message.text && /*#__PURE__*/React__default['default'].createElement(React__default['default'].Fragment, null, /*#__PURE__*/React__default['default'].createElement(MessageOptions, _extends__default['default']({}, props, {
    displayLeft: false,
    displayReplies: false,
    displayActions: false,
    onReactionListClick: onReactionListClick,
    theme: 'commerce'
  })), hasReactions && !showDetailedReactions && isReactionEnabled && /*#__PURE__*/React__default['default'].createElement(ReactionsList, {
    reactions: message.latest_reactions,
    reaction_counts: message.reaction_counts || undefined,
    own_reactions: message.own_reactions,
    onClick: onReactionListClick
  }), showDetailedReactions && isReactionEnabled && /*#__PURE__*/React__default['default'].createElement(ReactionSelector, {
    reverse: false,
    handleReaction: propHandleReaction || handleReaction,
    detailedView: true,
    reaction_counts: message.reaction_counts || undefined,
    latest_reactions: message.latest_reactions,
    own_reactions: message.own_reactions,
    ref: reactionSelectorRef
  })), (message === null || message === void 0 ? void 0 : message.attachments) && Attachment$1 && /*#__PURE__*/React__default['default'].createElement(Attachment$1, {
    attachments: message.attachments,
    actionHandler: propHandleAction || handleAction
  }), (message === null || message === void 0 ? void 0 : message.mml) && /*#__PURE__*/React__default['default'].createElement(MML, {
    source: message.mml,
    actionHandler: handleAction,
    align: isMyMessage ? 'right' : 'left'
  }), (message === null || message === void 0 ? void 0 : message.text) && /*#__PURE__*/React__default['default'].createElement(MessageText, {
    ReactionSelector: ReactionSelector,
    ReactionsList: ReactionsList,
    actionsEnabled: actionsEnabled,
    customWrapperClass: "str-chat__message-commerce-text",
    customInnerClass: "str-chat__message-commerce-text-inner",
    customOptionProps: {
      displayLeft: false,
      displayReplies: false,
      displayActions: false,
      theme: 'commerce'
    },
    getMessageActions: getMessageActions,
    message: message,
    messageListRect: props.messageListRect,
    unsafeHTML: props.unsafeHTML,
    onMentionsClickMessage: props.onMentionsClickMessage,
    onMentionsHoverMessage: props.onMentionsHoverMessage,
    theme: "commerce"
  }), !threadList && /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__message-commerce-reply-button"
  }, /*#__PURE__*/React__default['default'].createElement(MessageRepliesCountButton$1, {
    onClick: propHandleOpenThread || handleOpenThread,
    reply_count: message === null || message === void 0 ? void 0 : message.reply_count
  })), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__message-commerce-data"
  }, !isMyMessage ? /*#__PURE__*/React__default['default'].createElement("span", {
    className: "str-chat__message-commerce-name"
  }, (message === null || message === void 0 ? void 0 : (_message$user4 = message.user) === null || _message$user4 === void 0 ? void 0 : _message$user4.name) || (message === null || message === void 0 ? void 0 : (_message$user5 = message.user) === null || _message$user5 === void 0 ? void 0 : _message$user5.id)) : null, /*#__PURE__*/React__default['default'].createElement(MessageTimestamp$1, {
    formatDate: formatDate,
    customClass: "str-chat__message-commerce-timestamp",
    message: message,
    tDateTimeParser: propTDateTimeParser,
    format: "LT"
  })))));
};

MessageCommerce.propTypes = {
  /** The [message object](https://getstream.io/chat/docs/#message_format) */
  message:
  /** @type {PropTypes.Validator<import('stream-chat').MessageResponse>} */
  PropTypes__default['default'].object.isRequired,

  /**
   * The attachment UI component.
   * Default: [Attachment](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Attachment.js)
   * */
  Attachment:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').WrapperAttachmentUIComponentProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * Custom UI component to display user avatar
   *
   * Defaults to and accepts same props as: [Avatar](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Avatar/Avatar.js)
   * */
  Avatar:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').AvatarProps>>} */
  PropTypes__default['default'].elementType,

  /**
   *
   * @deprecated Its not recommended to use this anymore. All the methods in this HOC are provided explicitly.
   *
   * The higher order message component, most logic is delegated to this component
   * @see See [Message HOC](https://getstream.github.io/stream-chat-react/#message) for example
   *
   */
  Message:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').MessageUIComponentProps>>} */
  PropTypes__default['default'].oneOfType([PropTypes__default['default'].node, PropTypes__default['default'].func, PropTypes__default['default'].object]),

  /** render HTML instead of markdown. Posting HTML is only allowed server-side */
  unsafeHTML: PropTypes__default['default'].bool,

  /** If its parent message in thread. */
  initialMessage: PropTypes__default['default'].bool,

  /** Channel config object */
  channelConfig:
  /** @type {PropTypes.Validator<import('stream-chat').ChannelConfig>} */
  PropTypes__default['default'].object,

  /** Override the default formatting of the date. This is a function that has access to the original date object. Returns a string or Node  */
  formatDate: PropTypes__default['default'].func,

  /** If component is in thread list */
  threadList: PropTypes__default['default'].bool,

  /**
   * Function to open thread on current message
   * @deprecated The component now relies on the useThreadHandler custom hook
   * You can customize the behaviour for your thread handler on the <Channel> component instead.
   */
  handleOpenThread: PropTypes__default['default'].func,

  /** Returns true if message belongs to current user */
  isMyMessage: PropTypes__default['default'].func,

  /** Returns all allowed actions on message by current user e.g., ['edit', 'delete', 'flag', 'mute', 'react', 'reply'] */
  getMessageActions: PropTypes__default['default'].func.isRequired,

  /**
   * Add or remove reaction on message
   *
   * @param type Type of reaction - 'like' | 'love' | 'haha' | 'wow' | 'sad' | 'angry'
   * @param event Dom event which triggered this function
   * @deprecated This component now relies on the useReactionHandler custom hook.
   */
  handleReaction: PropTypes__default['default'].func,

  /**
   * A component to display the selector that allows a user to react to a certain message.
   */
  ReactionSelector:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').ReactionSelectorProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * A component to display the a message list of reactions.
   */
  ReactionsList:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').ReactionsListProps>>} */
  PropTypes__default['default'].elementType,

  /** If actions such as edit, delete, flag, mute are enabled on message */
  actionsEnabled: PropTypes__default['default'].bool,

  /**
   * @param name {string} Name of action
   * @param value {string} Value of action
   * @param event Dom event that triggered this handler
   * @deprecated This component now relies on the useActionHandler custom hook, and this prop will be removed on the next major release.
   */
  handleAction: PropTypes__default['default'].func,

  /**
   * The handler for hover event on @mention in message
   *
   * @param event Dom hover event which triggered handler.
   * @param user Target user object
   */
  onMentionsHoverMessage: PropTypes__default['default'].func,

  /**
   * The handler for click event on @mention in message
   *
   * @param event Dom click event which triggered handler.
   * @param user Target user object
   */
  onMentionsClickMessage: PropTypes__default['default'].func,

  /** Position of message in group. Possible values: top, bottom, middle, single */
  groupStyles: PropTypes__default['default'].array,

  /**
   * The handler for click event on the user that posted the message
   *
   * @param event Dom click event which triggered handler.
   * @deprecated This component now relies on the useUserHandler custom hook, and this prop will be removed on the next major release.
   */
  onUserClick: PropTypes__default['default'].func,

  /**
   * The handler for mouseOver event on the user that posted the message
   *
   * @param event Dom mouseOver event which triggered handler.
   * @deprecated This component now relies on the useUserHandler custom hook, and this prop will be removed on the next major release.
   */
  onUserHover: PropTypes__default['default'].func,

  /** The component that will be rendered if the message has been deleted.
   * All of Message's props are passed into this component.
   */
  MessageDeleted:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').MessageDeletedProps>>} */
  PropTypes__default['default'].elementType
};
var MessageCommerce$1 = /*#__PURE__*/React__default['default'].memo(MessageCommerce, areMessagePropsEqual);

/**
 * MessageLivestream - Render component, should be used together with the Message component
 * Implements the look and feel for a livestream use case.
 *
 * @example ../../docs/MessageLivestream.md
 * @typedef { import('../../../types').MessageLivestreamProps } Props
 * @type { React.FC<Props> }
 */
// eslint-disable-next-line sonarjs/cognitive-complexity

var MessageLivestreamComponent = function MessageLivestreamComponent(props) {
  var _message$i18n, _message$user4, _message$user5, _message$user6, _message$user7, _message$user8;

  var message = props.message,
      groupStyles = props.groupStyles,
      propEditing = props.editing,
      propSetEdit = props.setEditingState,
      propClearEdit = props.clearEditingState,
      initialMessage = props.initialMessage,
      unsafeHTML = props.unsafeHTML,
      formatDate = props.formatDate,
      propChannelConfig = props.channelConfig,
      _props$ReactionsList = props.ReactionsList,
      ReactionsList = _props$ReactionsList === void 0 ? DefaultReactionsList$1 : _props$ReactionsList,
      _props$ReactionSelect = props.ReactionSelector,
      ReactionSelector = _props$ReactionSelect === void 0 ? DefaultReactionSelector : _props$ReactionSelect,
      propOnUserClick = props.onUserClick,
      propHandleReaction = props.handleReaction,
      propHandleOpenThread = props.handleOpenThread,
      propOnUserHover = props.onUserHover,
      propHandleRetry = props.handleRetry,
      propHandleAction = props.handleAction,
      propUpdateMessage = props.updateMessage,
      propOnMentionsClick = props.onMentionsClickMessage,
      propOnMentionsHover = props.onMentionsHoverMessage,
      _props$Attachment = props.Attachment,
      Attachment$1 = _props$Attachment === void 0 ? Attachment : _props$Attachment,
      _props$Avatar = props.Avatar,
      Avatar$1 = _props$Avatar === void 0 ? Avatar : _props$Avatar,
      _props$EditMessageInp = props.EditMessageInput,
      EditMessageInput = _props$EditMessageInp === void 0 ? EditMessageForm : _props$EditMessageInp,
      propT = props.t,
      propTDateTimeParser = props.tDateTimeParser,
      MessageDeleted = props.MessageDeleted,
      _props$PinIndicator = props.PinIndicator,
      PinIndicator$1 = _props$PinIndicator === void 0 ? PinIndicator : _props$PinIndicator;

  var _useContext = React.useContext(TranslationContext),
      contextT = _useContext.t,
      userLanguage = _useContext.userLanguage;

  var t = propT || contextT;
  var messageWrapperRef = React.useRef(null);
  var reactionSelectorRef = React.useRef(null);
  /**
   *@type {import('../types').ChannelContextValue}
   */

  var _useContext2 = React.useContext(ChannelContext),
      channelUpdateMessage = _useContext2.updateMessage,
      channel = _useContext2.channel;

  var channelConfig = propChannelConfig || (channel === null || channel === void 0 ? void 0 : channel.getConfig());

  var _useMentionsUIHandler = useMentionsUIHandler(message, {
    onMentionsClick: propOnMentionsClick,
    onMentionsHover: propOnMentionsHover
  }),
      onMentionsClick = _useMentionsUIHandler.onMentionsClick,
      onMentionsHover = _useMentionsUIHandler.onMentionsHover;

  var handleAction = useActionHandler(message);
  var handleReaction = useReactionHandler(message);
  var handleOpenThread = useOpenThreadHandler(message);

  var _useEditHandler = useEditHandler(),
      ownEditing = _useEditHandler.editing,
      ownSetEditing = _useEditHandler.setEdit,
      ownClearEditing = _useEditHandler.clearEdit;

  var editing = propEditing || ownEditing;
  var setEdit = propSetEdit || ownSetEditing;
  var clearEdit = propClearEdit || ownClearEditing;
  var handleRetry = useRetryHandler();
  var retryHandler = propHandleRetry || handleRetry;

  var _useReactionClick = useReactionClick(message, reactionSelectorRef, messageWrapperRef),
      onReactionListClick = _useReactionClick.onReactionListClick,
      showDetailedReactions = _useReactionClick.showDetailedReactions,
      isReactionEnabled = _useReactionClick.isReactionEnabled;

  var _useUserHandler = useUserHandler(message, {
    onUserClickHandler: propOnUserClick,
    onUserHoverHandler: propOnUserHover
  }),
      onUserClick = _useUserHandler.onUserClick,
      onUserHover = _useUserHandler.onUserHover;

  var messageTextToRender = (message === null || message === void 0 ? void 0 : (_message$i18n = message.i18n) === null || _message$i18n === void 0 ? void 0 : _message$i18n["".concat(userLanguage, "_text")]) || (message === null || message === void 0 ? void 0 : message.text);
  var messageMentionedUsersItem = message === null || message === void 0 ? void 0 : message.mentioned_users;
  var messageText = React.useMemo(function () {
    return renderText(messageTextToRender, messageMentionedUsersItem);
  }, [messageMentionedUsersItem, messageTextToRender]);
  var firstGroupStyle = groupStyles ? groupStyles[0] : '';

  if (!message || message.type === 'message.read' || message.type === 'message.date') {
    return null;
  }

  if (message.deleted_at) {
    return smartRender(MessageDeleted, props, null);
  }

  if (editing) {
    var _message$user, _message$user2, _message$user3;

    return /*#__PURE__*/React__default['default'].createElement("div", {
      "data-testid": 'message-livestream-edit',
      className: "str-chat__message-team str-chat__message-team--".concat(firstGroupStyle, " str-chat__message-team--editing")
    }, (firstGroupStyle === 'top' || firstGroupStyle === 'single') && /*#__PURE__*/React__default['default'].createElement("div", {
      className: "str-chat__message-team-meta"
    }, /*#__PURE__*/React__default['default'].createElement(Avatar$1, {
      image: (_message$user = message.user) === null || _message$user === void 0 ? void 0 : _message$user.image,
      name: ((_message$user2 = message.user) === null || _message$user2 === void 0 ? void 0 : _message$user2.name) || ((_message$user3 = message.user) === null || _message$user3 === void 0 ? void 0 : _message$user3.id),
      size: 40,
      onClick: onUserClick,
      onMouseOver: onUserHover
    })), /*#__PURE__*/React__default['default'].createElement(MessageInput$1, {
      Input: EditMessageInput,
      message: message,
      clearEditingState: clearEdit,
      updateMessage: propUpdateMessage || channelUpdateMessage
    }));
  }

  return /*#__PURE__*/React__default['default'].createElement(React__default['default'].Fragment, null, (message === null || message === void 0 ? void 0 : message.pinned) && /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__message-livestream-pin-indicator"
  }, /*#__PURE__*/React__default['default'].createElement(PinIndicator$1, {
    message: message,
    t: t
  })), /*#__PURE__*/React__default['default'].createElement("div", {
    "data-testid": "message-livestream",
    className: "str-chat__message-livestream str-chat__message-livestream--".concat(firstGroupStyle, " str-chat__message-livestream--").concat(message.type, " str-chat__message-livestream--").concat(message.status, " ").concat(initialMessage ? 'str-chat__message-livestream--initial-message' : '', " ").concat(message !== null && message !== void 0 && message.pinned ? 'pinned-message' : ''),
    ref: messageWrapperRef
  }, showDetailedReactions && isReactionEnabled && /*#__PURE__*/React__default['default'].createElement(ReactionSelector, {
    reverse: false,
    handleReaction: handleReaction,
    detailedView: true,
    latest_reactions: message === null || message === void 0 ? void 0 : message.latest_reactions,
    reaction_counts: (message === null || message === void 0 ? void 0 : message.reaction_counts) || undefined,
    own_reactions: message.own_reactions,
    ref: reactionSelectorRef
  }), /*#__PURE__*/React__default['default'].createElement(MessageLivestreamActions, {
    initialMessage: initialMessage,
    message: message,
    formatDate: formatDate,
    onReactionListClick: onReactionListClick,
    messageWrapperRef: messageWrapperRef,
    getMessageActions: props.getMessageActions,
    tDateTimeParser: propTDateTimeParser,
    channelConfig: channelConfig,
    threadList: props.threadList,
    addNotification: props.addNotification,
    handleOpenThread: propHandleOpenThread || handleOpenThread,
    setEditingState: setEdit
  }), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__message-livestream-left"
  }, /*#__PURE__*/React__default['default'].createElement(Avatar$1, {
    image: (_message$user4 = message.user) === null || _message$user4 === void 0 ? void 0 : _message$user4.image,
    name: ((_message$user5 = message.user) === null || _message$user5 === void 0 ? void 0 : _message$user5.name) || (message === null || message === void 0 ? void 0 : (_message$user6 = message.user) === null || _message$user6 === void 0 ? void 0 : _message$user6.id),
    size: 30,
    onClick: onUserClick,
    onMouseOver: onUserHover
  })), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__message-livestream-right"
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__message-livestream-content"
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__message-livestream-author"
  }, /*#__PURE__*/React__default['default'].createElement("strong", null, ((_message$user7 = message.user) === null || _message$user7 === void 0 ? void 0 : _message$user7.name) || ((_message$user8 = message.user) === null || _message$user8 === void 0 ? void 0 : _message$user8.id)), (message === null || message === void 0 ? void 0 : message.type) === 'error' && /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__message-team-error-header"
  }, t('Only visible to you'))), /*#__PURE__*/React__default['default'].createElement("div", {
    "data-testid": "message-livestream-text",
    className: isOnlyEmojis(message.text) ? 'str-chat__message-livestream-text--is-emoji' : '',
    onMouseOver: onMentionsHover,
    onClick: onMentionsClick
  }, message.type !== 'error' && message.status !== 'failed' && !unsafeHTML && messageText, message.type !== 'error' && message.status !== 'failed' && unsafeHTML && !!message.html && /*#__PURE__*/React__default['default'].createElement("div", {
    dangerouslySetInnerHTML: {
      __html: message.html
    }
  }), message.type === 'error' && !message.command && /*#__PURE__*/React__default['default'].createElement("p", {
    "data-testid": "message-livestream-error"
  }, /*#__PURE__*/React__default['default'].createElement(ErrorIcon, null), message.text), message.type === 'error' && message.command && /*#__PURE__*/React__default['default'].createElement("p", {
    "data-testid": "message-livestream-command-error"
  }, /*#__PURE__*/React__default['default'].createElement(ErrorIcon, null), /*#__PURE__*/React__default['default'].createElement("strong", null, "/", message.command), " is not a valid command"), message.status === 'failed' && /*#__PURE__*/React__default['default'].createElement("p", {
    onClick: function onClick() {
      if (retryHandler) {
        // FIXME: type checking fails here because in the case of a failed message,
        // `message` is of type Client.Message (i.e. request object)
        // instead of Client.MessageResponse (i.e. server response object)
        // @ts-ignore
        retryHandler(message);
      }
    }
  }, /*#__PURE__*/React__default['default'].createElement(ErrorIcon, null), t('Message failed. Click to try again.'))), (message === null || message === void 0 ? void 0 : message.attachments) && Attachment$1 && /*#__PURE__*/React__default['default'].createElement(Attachment$1, {
    attachments: message.attachments,
    actionHandler: propHandleAction || handleAction
  }), isReactionEnabled && /*#__PURE__*/React__default['default'].createElement(ReactionsList, {
    reaction_counts: message.reaction_counts || undefined,
    reactions: message.latest_reactions,
    own_reactions: message.own_reactions,
    handleReaction: propHandleReaction || handleReaction
  }), !initialMessage && /*#__PURE__*/React__default['default'].createElement(MessageRepliesCountButton$1, {
    onClick: propHandleOpenThread || handleOpenThread,
    reply_count: message.reply_count
  })))));
};
/**
 * @type { React.FC<import('../types').MessageLivestreamActionProps> }
 */


var MessageLivestreamActions = function MessageLivestreamActions(props) {
  var initialMessage = props.initialMessage,
      message = props.message,
      channelConfig = props.channelConfig,
      threadList = props.threadList,
      formatDate = props.formatDate,
      messageWrapperRef = props.messageWrapperRef,
      onReactionListClick = props.onReactionListClick,
      getMessageActions = props.getMessageActions,
      handleOpenThread = props.handleOpenThread,
      propTDateTimeParser = props.tDateTimeParser;

  var _useState = React.useState(false),
      _useState2 = _slicedToArray__default['default'](_useState, 2),
      actionsBoxOpen = _useState2[0],
      setActionsBoxOpen = _useState2[1];
  /** @type {() => void} Typescript syntax */


  var hideOptions = React.useCallback(function () {
    return setActionsBoxOpen(false);
  }, []);
  var messageDeletedAt = !!(message !== null && message !== void 0 && message.deleted_at);
  var messageWrapper = messageWrapperRef === null || messageWrapperRef === void 0 ? void 0 : messageWrapperRef.current;
  React.useEffect(function () {
    if (messageWrapper) {
      messageWrapper.addEventListener('mouseleave', hideOptions);
    }

    return function () {
      if (messageWrapper) {
        messageWrapper.removeEventListener('mouseleave', hideOptions);
      }
    };
  }, [messageWrapper, hideOptions]);
  React.useEffect(function () {
    if (messageDeletedAt) {
      document.removeEventListener('click', hideOptions);
    }
  }, [messageDeletedAt, hideOptions]);
  React.useEffect(function () {
    if (actionsBoxOpen) {
      document.addEventListener('click', hideOptions);
    } else {
      document.removeEventListener('click', hideOptions);
    }

    return function () {
      document.removeEventListener('click', hideOptions);
    };
  }, [actionsBoxOpen, hideOptions]);

  if (initialMessage || !message || message.type === 'error' || message.type === 'system' || message.type === 'ephemeral' || message.status === 'failed' || message.status === 'sending') {
    return null;
  }

  return /*#__PURE__*/React__default['default'].createElement("div", {
    "data-testid": 'message-livestream-actions',
    className: "str-chat__message-livestream-actions"
  }, /*#__PURE__*/React__default['default'].createElement(MessageTimestamp$1, {
    customClass: "str-chat__message-livestream-time",
    message: message,
    formatDate: formatDate,
    tDateTimeParser: propTDateTimeParser
  }), channelConfig && channelConfig.reactions && /*#__PURE__*/React__default['default'].createElement("span", {
    onClick: onReactionListClick,
    "data-testid": "message-livestream-reactions-action"
  }, /*#__PURE__*/React__default['default'].createElement("span", null, /*#__PURE__*/React__default['default'].createElement(ReactionIcon, null))), !threadList && channelConfig && channelConfig.replies && /*#__PURE__*/React__default['default'].createElement("span", {
    "data-testid": "message-livestream-thread-action",
    onClick: handleOpenThread
  }, /*#__PURE__*/React__default['default'].createElement(ThreadIcon, null)), /*#__PURE__*/React__default['default'].createElement(MessageActions, _extends__default['default']({}, props, {
    getMessageActions: getMessageActions,
    customWrapperClass: '',
    inline: true
  })));
};

MessageLivestreamComponent.propTypes = {
  /** The [message object](https://getstream.io/chat/docs/#message_format) */
  message:
  /** @type {PropTypes.Validator<import('stream-chat').MessageResponse>} */
  PropTypes__default['default'].object.isRequired,

  /**
   * The attachment UI component.
   * Default: [Attachment](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Attachment.js)
   * */
  Attachment:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').WrapperAttachmentUIComponentProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * Custom UI component to display user avatar
   *
   * Defaults to and accepts same props as: [Avatar](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Avatar/Avatar.js)
   * */
  Avatar:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').AvatarProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * Custom UI component to override default edit message input
   *
   * Defaults to and accepts same props as: [EditMessageForm](https://github.com/GetStream/stream-chat-react/blob/master/src/components/MessageInput/EditMessageForm.js)
   * */
  EditMessageInput:
  /** @type {PropTypes.Validator<React.FC<import("types").MessageInputProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * Custom UI component to override default pinned message indicator
   *
   * Defaults to and accepts same props as: [PinIndicator](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Message/icon.js)
   * */
  PinIndicator:
  /** @type {PropTypes.Validator<React.FC<import("types").PinIndicatorProps>>} */
  PropTypes__default['default'].elementType,

  /**
   *
   * @deprecated Its not recommended to use this anymore. All the methods in this HOC are provided explicitly.
   *
   * The higher order message component, most logic is delegated to this component
   * @see See [Message HOC](https://getstream.github.io/stream-chat-react/#message) for example
   *
   * */
  Message:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').MessageUIComponentProps>>} */
  PropTypes__default['default'].oneOfType([PropTypes__default['default'].node, PropTypes__default['default'].func, PropTypes__default['default'].object]),

  /** render HTML instead of markdown. Posting HTML is only allowed server-side */
  unsafeHTML: PropTypes__default['default'].bool,

  /** If its parent message in thread. */
  initialMessage: PropTypes__default['default'].bool,

  /** Override the default formatting of the date. This is a function that has access to the original date object. Returns a string or Node  */
  formatDate: PropTypes__default['default'].func,

  /** Channel config object */
  channelConfig:
  /** @type {PropTypes.Validator<import('stream-chat').ChannelConfig>} */
  PropTypes__default['default'].object,

  /** If component is in thread list */
  threadList: PropTypes__default['default'].bool,

  /** Function to open thread on current message */
  handleOpenThread: PropTypes__default['default'].func,

  /** If the message is in edit state */
  editing: PropTypes__default['default'].bool,

  /** Function to exit edit state */
  clearEditingState: PropTypes__default['default'].func,

  /** Returns true if message belongs to current user */
  isMyMessage: PropTypes__default['default'].func,

  /**
   * Returns all allowed actions on message by current user e.g., ['edit', 'delete', 'flag', 'mute', 'react', 'reply']
   * Please check [Message](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Message.js) component for default implementation.
   * */
  getMessageActions:
  /** @type {PropTypes.Validator<() => Array<string>>} */
  PropTypes__default['default'].func,

  /**
   * Function to publish updates on message to channel
   *
   * @param message Updated [message object](https://getstream.io/chat/docs/#message_format)
   * */
  updateMessage: PropTypes__default['default'].func,

  /**
   * Reattempt sending a message
   * @param message A [message object](https://getstream.io/chat/docs/#message_format) to resent.
   */
  handleRetry: PropTypes__default['default'].func,

  /**
   * Add or remove reaction on message
   *
   * @param type Type of reaction - 'like' | 'love' | 'haha' | 'wow' | 'sad' | 'angry'
   * @param event Dom event which triggered this function
   */
  handleReaction: PropTypes__default['default'].func,

  /**
   * A component to display the selector that allows a user to react to a certain message.
   */
  ReactionSelector:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').ReactionSelectorProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * A component to display the a message list of reactions.
   */
  ReactionsList:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').ReactionsListProps>>} */
  PropTypes__default['default'].elementType,

  /** If actions such as edit, delete, flag, mute are enabled on message */

  /** @deprecated This property is no longer used * */
  actionsEnabled: PropTypes__default['default'].bool,

  /** DOMRect object for parent MessageList component */
  messageListRect: PropTypes__default['default'].shape({
    x: PropTypes__default['default'].number.isRequired,
    y: PropTypes__default['default'].number.isRequired,
    height: PropTypes__default['default'].number.isRequired,
    width: PropTypes__default['default'].number.isRequired,
    top: PropTypes__default['default'].number.isRequired,
    right: PropTypes__default['default'].number.isRequired,
    bottom: PropTypes__default['default'].number.isRequired,
    left: PropTypes__default['default'].number.isRequired,
    toJSON: PropTypes__default['default'].func.isRequired
  }),

  /**
   * @param name {string} Name of action
   * @param value {string} Value of action
   * @param event Dom event that triggered this handler
   */
  handleAction: PropTypes__default['default'].func,

  /**
   * The handler for hover event on @mention in message
   *
   * @param event Dom hover event which triggered handler.
   * @param user Target user object
   */
  onMentionsHoverMessage: PropTypes__default['default'].func,

  /**
   * The handler for click event on @mention in message
   *
   * @param event Dom click event which triggered handler.
   * @param user Target user object
   */
  onMentionsClickMessage: PropTypes__default['default'].func,

  /**
   * The handler for click event on the user that posted the message
   *
   * @param event Dom click event which triggered handler.
   */
  onUserClick: PropTypes__default['default'].func,

  /**
   * The handler for mouseOver event on the user that posted the message
   *
   * @param event Dom mouseOver event which triggered handler.
   */
  onUserHover: PropTypes__default['default'].func,

  /**
   * The component that will be rendered if the message has been deleted.
   * All of Message's props are passed into this component.
   */
  MessageDeleted:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').MessageDeletedProps>>} */
  PropTypes__default['default'].elementType
};
var MessageLivestream = /*#__PURE__*/React__default['default'].memo(MessageLivestreamComponent, areMessagePropsEqual);

// @ts-check
/**
 * MessageTeam - Render component, should be used together with the Message component
 * Implements the look and feel for a team style collaboration environment
 *
 * @example ../../docs/MessageTeam.md
 * @typedef { import('../types').MessageTeamProps } Props
 *
 * @type {React.FC<Props>}
 */
// eslint-disable-next-line sonarjs/cognitive-complexity

var MessageTeam = function MessageTeam(props) {
  var _message$i18n, _message$user4, _message$user5, _message$user6, _message$user7, _message$user8;

  var message = props.message,
      threadList = props.threadList,
      formatDate = props.formatDate,
      initialMessage = props.initialMessage,
      unsafeHTML = props.unsafeHTML,
      getMessageActions = props.getMessageActions,
      _props$Avatar = props.Avatar,
      Avatar$1 = _props$Avatar === void 0 ? Avatar : _props$Avatar,
      _props$EditMessageInp = props.EditMessageInput,
      EditMessageInput = _props$EditMessageInp === void 0 ? EditMessageForm : _props$EditMessageInp,
      MessageDeleted = props.MessageDeleted,
      _props$PinIndicator = props.PinIndicator,
      PinIndicator$1 = _props$PinIndicator === void 0 ? PinIndicator : _props$PinIndicator,
      _props$ReactionsList = props.ReactionsList,
      ReactionsList = _props$ReactionsList === void 0 ? DefaultReactionsList$1 : _props$ReactionsList,
      _props$ReactionSelect = props.ReactionSelector,
      ReactionSelector = _props$ReactionSelect === void 0 ? DefaultReactionSelector : _props$ReactionSelect,
      propEditing = props.editing,
      propSetEdit = props.setEditingState,
      propClearEdit = props.clearEditingState,
      propOnMentionsHover = props.onMentionsHoverMessage,
      propOnMentionsClick = props.onMentionsClickMessage,
      propChannelConfig = props.channelConfig,
      propHandleAction = props.handleAction,
      propHandleOpenThread = props.handleOpenThread,
      propHandleReaction = props.handleReaction,
      propHandleRetry = props.handleRetry,
      propUpdateMessage = props.updateMessage,
      propOnUserClick = props.onUserClick,
      propOnUserHover = props.onUserHover,
      propT = props.t;
  /**
   *@type {import('../types').ChannelContextValue}
   */

  var _useContext = React.useContext(ChannelContext),
      channel = _useContext.channel,
      channelUpdateMessage = _useContext.updateMessage;

  var channelConfig = propChannelConfig || (channel === null || channel === void 0 ? void 0 : channel.getConfig());

  var _useContext2 = React.useContext(TranslationContext),
      contextT = _useContext2.t,
      userLanguage = _useContext2.userLanguage;

  var t = propT || contextT;
  var groupStyles = props.groupStyles || ['single'];
  var reactionSelectorRef = React.useRef(null);
  var messageWrapperRef = React.useRef(null);

  var _useEditHandler = useEditHandler(),
      ownEditing = _useEditHandler.editing,
      ownSetEditing = _useEditHandler.setEdit,
      ownClearEditing = _useEditHandler.clearEdit;

  var editing = propEditing || ownEditing;
  var setEdit = propSetEdit || ownSetEditing;
  var clearEdit = propClearEdit || ownClearEditing;
  var handleOpenThread = useOpenThreadHandler(message);
  var handleReaction = useReactionHandler(message);
  var handleAction = useActionHandler(message);
  var retryHandler = useRetryHandler();
  var retry = propHandleRetry || retryHandler;

  var _useMentionsUIHandler = useMentionsUIHandler(message, {
    onMentionsClick: propOnMentionsClick,
    onMentionsHover: propOnMentionsHover
  }),
      onMentionsClick = _useMentionsUIHandler.onMentionsClick,
      onMentionsHover = _useMentionsUIHandler.onMentionsHover;

  var _useReactionClick = useReactionClick(message, reactionSelectorRef, messageWrapperRef),
      onReactionListClick = _useReactionClick.onReactionListClick,
      showDetailedReactions = _useReactionClick.showDetailedReactions,
      isReactionEnabled = _useReactionClick.isReactionEnabled;

  var _useUserHandler = useUserHandler(message, {
    onUserClickHandler: propOnUserClick,
    onUserHoverHandler: propOnUserHover
  }),
      onUserClick = _useUserHandler.onUserClick,
      onUserHover = _useUserHandler.onUserHover;

  var messageTextToRender = (message === null || message === void 0 ? void 0 : (_message$i18n = message.i18n) === null || _message$i18n === void 0 ? void 0 : _message$i18n["".concat(userLanguage, "_text")]) || (message === null || message === void 0 ? void 0 : message.text);
  var messageMentionedUsersItem = message === null || message === void 0 ? void 0 : message.mentioned_users; // eslint-disable-next-line react-hooks/rules-of-hooks

  var messageText = React.useMemo(function () {
    return renderText(messageTextToRender, messageMentionedUsersItem);
  }, [messageMentionedUsersItem, messageTextToRender]);
  var firstGroupStyle = groupStyles ? groupStyles[0] : '';

  if ((message === null || message === void 0 ? void 0 : message.type) === 'message.read') {
    return null;
  }

  if (message !== null && message !== void 0 && message.deleted_at) {
    return smartRender(MessageDeleted, props, null);
  }

  if (editing) {
    var _message$user, _message$user2, _message$user3;

    return /*#__PURE__*/React__default['default'].createElement("div", {
      "data-testid": "message-team-edit",
      className: "str-chat__message-team str-chat__message-team--".concat(firstGroupStyle, " str-chat__message-team--editing")
    }, (firstGroupStyle === 'top' || firstGroupStyle === 'single') && /*#__PURE__*/React__default['default'].createElement("div", {
      className: "str-chat__message-team-meta"
    }, /*#__PURE__*/React__default['default'].createElement(Avatar$1, {
      image: message === null || message === void 0 ? void 0 : (_message$user = message.user) === null || _message$user === void 0 ? void 0 : _message$user.image,
      name: (message === null || message === void 0 ? void 0 : (_message$user2 = message.user) === null || _message$user2 === void 0 ? void 0 : _message$user2.name) || (message === null || message === void 0 ? void 0 : (_message$user3 = message.user) === null || _message$user3 === void 0 ? void 0 : _message$user3.id),
      size: 40,
      onClick: onUserClick,
      onMouseOver: onUserHover
    })), /*#__PURE__*/React__default['default'].createElement(MessageInput$1, {
      Input: EditMessageInput,
      message: message,
      clearEditingState: clearEdit,
      updateMessage: propUpdateMessage || channelUpdateMessage
    }));
  }

  return /*#__PURE__*/React__default['default'].createElement(React__default['default'].Fragment, null, (message === null || message === void 0 ? void 0 : message.pinned) && /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__message-team-pin-indicator"
  }, /*#__PURE__*/React__default['default'].createElement(PinIndicator$1, {
    message: message,
    t: t
  })), /*#__PURE__*/React__default['default'].createElement("div", {
    "data-testid": "message-team",
    className: "str-chat__message-team str-chat__message-team--".concat(firstGroupStyle, " str-chat__message-team--").concat(message === null || message === void 0 ? void 0 : message.type, " ").concat(threadList ? 'thread-list' : '', " str-chat__message-team--").concat(message === null || message === void 0 ? void 0 : message.status, " ").concat(message !== null && message !== void 0 && message.pinned ? 'pinned-message' : ''),
    ref: messageWrapperRef
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__message-team-meta"
  }, firstGroupStyle === 'top' || firstGroupStyle === 'single' || initialMessage ? /*#__PURE__*/React__default['default'].createElement(Avatar$1, {
    image: message === null || message === void 0 ? void 0 : (_message$user4 = message.user) === null || _message$user4 === void 0 ? void 0 : _message$user4.image,
    name: (message === null || message === void 0 ? void 0 : (_message$user5 = message.user) === null || _message$user5 === void 0 ? void 0 : _message$user5.name) || (message === null || message === void 0 ? void 0 : (_message$user6 = message.user) === null || _message$user6 === void 0 ? void 0 : _message$user6.id),
    size: 40,
    onClick: onUserClick,
    onMouseOver: onUserHover
  }) : /*#__PURE__*/React__default['default'].createElement("div", {
    "data-testid": "team-meta-spacer",
    style: {
      width: 40,
      marginRight: 0
    }
  }), /*#__PURE__*/React__default['default'].createElement(MessageTimestamp$1, {
    message: message,
    tDateTimeParser: props.tDateTimeParser,
    formatDate: formatDate
  })), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__message-team-group"
  }, message && (firstGroupStyle === 'top' || firstGroupStyle === 'single' || initialMessage) && /*#__PURE__*/React__default['default'].createElement("div", {
    "data-testid": "message-team-author",
    className: "str-chat__message-team-author",
    onClick: onUserClick
  }, /*#__PURE__*/React__default['default'].createElement("strong", null, ((_message$user7 = message.user) === null || _message$user7 === void 0 ? void 0 : _message$user7.name) || ((_message$user8 = message.user) === null || _message$user8 === void 0 ? void 0 : _message$user8.id)), message.type === 'error' && /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__message-team-error-header"
  }, t('Only visible to you'))), /*#__PURE__*/React__default['default'].createElement("div", {
    "data-testid": "message-team-content",
    className: "str-chat__message-team-content str-chat__message-team-content--".concat(firstGroupStyle, " str-chat__message-team-content--").concat((message === null || message === void 0 ? void 0 : message.text) === '' ? 'image' : 'text')
  }, !initialMessage && message && message.status !== 'sending' && message.status !== 'failed' && message.type !== 'system' && message.type !== 'ephemeral' && message.type !== 'error' && /*#__PURE__*/React__default['default'].createElement("div", {
    "data-testid": "message-team-actions",
    className: "str-chat__message-team-actions"
  }, message && showDetailedReactions && /*#__PURE__*/React__default['default'].createElement(ReactionSelector, {
    handleReaction: propHandleReaction || handleReaction,
    latest_reactions: message.latest_reactions,
    reaction_counts: message.reaction_counts || undefined,
    own_reactions: message.own_reactions,
    detailedView: true,
    ref: reactionSelectorRef
  }), isReactionEnabled && /*#__PURE__*/React__default['default'].createElement("span", {
    "data-testid": "message-team-reaction-icon",
    title: "Reactions",
    onClick: onReactionListClick
  }, /*#__PURE__*/React__default['default'].createElement(ReactionIcon, null)), !threadList && (channelConfig === null || channelConfig === void 0 ? void 0 : channelConfig.replies) !== false && /*#__PURE__*/React__default['default'].createElement("span", {
    "data-testid": "message-team-thread-icon",
    title: "Start a thread",
    onClick: propHandleOpenThread || handleOpenThread
  }, /*#__PURE__*/React__default['default'].createElement(ThreadIcon, null)), message && getMessageActions && getMessageActions().length > 0 && /*#__PURE__*/React__default['default'].createElement(MessageActions, {
    addNotification: props.addNotification,
    message: message,
    getMessageActions: props.getMessageActions,
    messageListRect: props.messageListRect,
    messageWrapperRef: messageWrapperRef,
    setEditingState: setEdit,
    getMuteUserSuccessNotification: props.getMuteUserSuccessNotification,
    getMuteUserErrorNotification: props.getMuteUserErrorNotification,
    getFlagMessageErrorNotification: props.getFlagMessageErrorNotification,
    getFlagMessageSuccessNotification: props.getFlagMessageSuccessNotification,
    handleFlag: props.handleFlag,
    handleMute: props.handleMute,
    handleEdit: props.handleEdit,
    handleDelete: props.handleDelete,
    handlePin: props.handlePin,
    customWrapperClass: '',
    inline: true
  })), message && /*#__PURE__*/React__default['default'].createElement("span", {
    "data-testid": "message-team-message",
    className: isOnlyEmojis(message.text) ? 'str-chat__message-team-text--is-emoji' : '',
    onMouseOver: onMentionsHover,
    onClick: onMentionsClick
  }, unsafeHTML && message.html ? /*#__PURE__*/React__default['default'].createElement("div", {
    dangerouslySetInnerHTML: {
      __html: message.html
    }
  }) : messageText), (message === null || message === void 0 ? void 0 : message.mml) && /*#__PURE__*/React__default['default'].createElement(MML, {
    source: message.mml,
    actionHandler: handleAction,
    align: "left"
  }), message && message.text === '' && /*#__PURE__*/React__default['default'].createElement(MessageTeamAttachments, {
    Attachment: props.Attachment,
    message: message,
    handleAction: propHandleAction || handleAction
  }), (message === null || message === void 0 ? void 0 : message.latest_reactions) && message.latest_reactions.length !== 0 && message.text !== '' && isReactionEnabled && /*#__PURE__*/React__default['default'].createElement(ReactionsList, {
    reaction_counts: message.reaction_counts || undefined,
    handleReaction: propHandleReaction || handleReaction,
    reactions: message.latest_reactions,
    own_reactions: message.own_reactions
  }), (message === null || message === void 0 ? void 0 : message.status) === 'failed' && /*#__PURE__*/React__default['default'].createElement("button", {
    "data-testid": "message-team-failed",
    className: "str-chat__message-team-failed",
    onClick: function onClick() {
      if (message.status === 'failed' && retry) {
        // FIXME: type checking fails here because in the case of a failed message,
        // `message` is of type Client.Message (i.e. request object)
        // instead of Client.MessageResponse (i.e. server response object)
        // @ts-ignore
        retry(message);
      }
    }
  }, /*#__PURE__*/React__default['default'].createElement(ErrorIcon, null), t('Message failed. Click to try again.'))), /*#__PURE__*/React__default['default'].createElement(MessageTeamStatus, {
    Avatar: Avatar$1,
    readBy: props.readBy,
    message: message,
    threadList: threadList,
    lastReceivedId: props.lastReceivedId,
    t: propT
  }), message && message.text !== '' && message.attachments && /*#__PURE__*/React__default['default'].createElement(MessageTeamAttachments, {
    Attachment: props.Attachment,
    message: message,
    handleAction: propHandleAction || handleAction
  }), (message === null || message === void 0 ? void 0 : message.latest_reactions) && message.latest_reactions.length !== 0 && message.text === '' && isReactionEnabled && /*#__PURE__*/React__default['default'].createElement(ReactionsList, {
    reaction_counts: message.reaction_counts || undefined,
    handleReaction: propHandleReaction || handleReaction,
    reactions: message.latest_reactions,
    own_reactions: message.own_reactions
  }), !threadList && message && /*#__PURE__*/React__default['default'].createElement(MessageRepliesCountButton$1, {
    onClick: propHandleOpenThread || handleOpenThread,
    reply_count: message.reply_count
  }))));
};
/** @type {(props: import('../types').MessageTeamStatusProps) => React.ReactElement | null} */


var MessageTeamStatus = function MessageTeamStatus(props) {
  var _props$Avatar2 = props.Avatar,
      Avatar$1 = _props$Avatar2 === void 0 ? Avatar : _props$Avatar2,
      readBy = props.readBy,
      message = props.message,
      threadList = props.threadList,
      lastReceivedId = props.lastReceivedId,
      propT = props.t;

  var _useContext3 = React.useContext(ChannelContext),
      client = _useContext3.client;

  var _useContext4 = React.useContext(TranslationContext),
      contextT = _useContext4.t;

  var t = propT || contextT;

  var _useUserRole = useUserRole(message),
      isMyMessage = _useUserRole.isMyMessage;

  if (!isMyMessage || (message === null || message === void 0 ? void 0 : message.type) === 'error') {
    return null;
  }

  var justReadByMe = readBy && (client === null || client === void 0 ? void 0 : client.user) && readBy.length === 1 && readBy[0] && readBy[0].id === client.user.id;

  if (message && message.status === 'sending') {
    return /*#__PURE__*/React__default['default'].createElement("span", {
      className: "str-chat__message-team-status",
      "data-testid": "message-team-sending"
    }, /*#__PURE__*/React__default['default'].createElement(Tooltip$1, null, t && t('Sending...')), /*#__PURE__*/React__default['default'].createElement(DefaultLoadingIndicator, null));
  }

  if (readBy && readBy.length !== 0 && !threadList && !justReadByMe) {
    var lastReadUser = readBy.filter(function (item) {
      return item && (client === null || client === void 0 ? void 0 : client.user) && item.id !== client.user.id;
    })[0];
    return /*#__PURE__*/React__default['default'].createElement("span", {
      className: "str-chat__message-team-status"
    }, /*#__PURE__*/React__default['default'].createElement(Tooltip$1, null, getReadByTooltipText(readBy, t, client)), /*#__PURE__*/React__default['default'].createElement(Avatar$1, {
      name: lastReadUser === null || lastReadUser === void 0 ? void 0 : lastReadUser.name,
      image: lastReadUser === null || lastReadUser === void 0 ? void 0 : lastReadUser.image,
      size: 15
    }), readBy.length - 1 > 1 && /*#__PURE__*/React__default['default'].createElement("span", {
      "data-testid": "message-team-read-by-count",
      className: "str-chat__message-team-status-number"
    }, readBy.length - 1));
  }

  if (message && message.status === 'received' && message.id === lastReceivedId && !threadList) {
    return /*#__PURE__*/React__default['default'].createElement("span", {
      "data-testid": "message-team-received",
      className: "str-chat__message-team-status"
    }, /*#__PURE__*/React__default['default'].createElement(Tooltip$1, null, t && t('Delivered')), /*#__PURE__*/React__default['default'].createElement(DeliveredCheckIcon, null));
  }

  return null;
};
/** @type {(props: import('../types').MessageTeamAttachmentsProps) => React.ReactElement | null} Typescript syntax */


var MessageTeamAttachments = function MessageTeamAttachments(props) {
  var _props$Attachment = props.Attachment,
      Attachment$1 = _props$Attachment === void 0 ? Attachment : _props$Attachment,
      message = props.message,
      handleAction = props.handleAction;

  if (message !== null && message !== void 0 && message.attachments && Attachment$1) {
    return /*#__PURE__*/React__default['default'].createElement(Attachment$1, {
      attachments: message.attachments,
      actionHandler: handleAction
    });
  }

  return null;
};

MessageTeam.propTypes = {
  /** The [message object](https://getstream.io/chat/docs/#message_format) */
  message:
  /** @type {PropTypes.Validator<import('stream-chat').MessageResponse>} */
  PropTypes__default['default'].object.isRequired,

  /**
   * The attachment UI component.
   * Default: [Attachment](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Attachment.js)
   * */
  Attachment:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').WrapperAttachmentUIComponentProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * Custom UI component to display user avatar
   *
   * Defaults to and accepts same props as: [Avatar](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Avatar/Avatar.js)
   * */
  Avatar:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').AvatarProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * Custom UI component to override default edit message input
   *
   * Defaults to and accepts same props as: [EditMessageForm](https://github.com/GetStream/stream-chat-react/blob/master/src/components/MessageInput/EditMessageForm.js)
   * */
  EditMessageInput:
  /** @type {PropTypes.Validator<React.FC<import("types").MessageInputProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * Custom UI component to override default pinned message indicator
   *
   * Defaults to and accepts same props as: [PinIndicator](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Message/icon.js)
   * */
  PinIndicator:
  /** @type {PropTypes.Validator<React.FC<import("types").PinIndicatorProps>>} */
  PropTypes__default['default'].elementType,

  /**
   *
   * @deprecated Its not recommended to use this anymore. All the methods in this HOC are provided explicitly.
   *
   * The higher order message component, most logic is delegated to this component
   * @see See [Message HOC](https://getstream.github.io/stream-chat-react/#message) for example
   * */
  Message:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').MessageUIComponentProps>>} */
  PropTypes__default['default'].oneOfType([PropTypes__default['default'].node, PropTypes__default['default'].func, PropTypes__default['default'].object]),

  /** render HTML instead of markdown. Posting HTML is only allowed server-side */
  unsafeHTML: PropTypes__default['default'].bool,

  /** Client object */
  client:
  /** @type {PropTypes.Validator<import('stream-chat').StreamChat>} */
  PropTypes__default['default'].object,

  /** If its parent message in thread. */
  initialMessage: PropTypes__default['default'].bool,

  /** Channel config object */
  channelConfig:
  /** @type {PropTypes.Validator<import('stream-chat').ChannelConfig>} */
  PropTypes__default['default'].object,

  /** If component is in thread list */
  threadList: PropTypes__default['default'].bool,

  /** Function to open thread on current message */
  handleOpenThread: PropTypes__default['default'].func,

  /** If the message is in edit state */
  editing: PropTypes__default['default'].bool,

  /** Function to exit edit state */
  clearEditingState: PropTypes__default['default'].func,

  /** Returns true if message belongs to current user */
  isMyMessage: PropTypes__default['default'].func,

  /** Override the default formatting of the date. This is a function that has access to the original date object. Returns a string or Node  */
  formatDate: PropTypes__default['default'].func,

  /**
   * Returns all allowed actions on message by current user e.g., ['edit', 'delete', 'flag', 'mute', 'react', 'reply']
   * Please check [Message](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Message.js) component for default implementation.
   * */
  getMessageActions:
  /** @type {PropTypes.Validator<() => Array<string>>} */
  PropTypes__default['default'].func,

  /**
   * Function to publish updates on message to channel
   *
   * @param message Updated [message object](https://getstream.io/chat/docs/#message_format)
   * */
  updateMessage: PropTypes__default['default'].func,

  /**
   * Reattempt sending a message
   * @param message A [message object](https://getstream.io/chat/docs/#message_format) to resent.
   */
  handleRetry: PropTypes__default['default'].func,

  /**
   * Add or remove reaction on message
   *
   * @param type Type of reaction - 'like' | 'love' | 'haha' | 'wow' | 'sad' | 'angry'
   * @param event Dom event which triggered this function
   */
  handleReaction: PropTypes__default['default'].func,

  /**
   * A component to display the selector that allows a user to react to a certain message.
   */
  ReactionSelector:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').ReactionSelectorProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * A component to display the a message list of reactions.
   */
  ReactionsList:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').ReactionsListProps>>} */
  PropTypes__default['default'].elementType,

  /** DOMRect object for parent MessageList component */
  messageListRect:
  /** @type {PropTypes.Validator<DOMRect>} */
  PropTypes__default['default'].object,

  /**
   * @param name {string} Name of action
   * @param value {string} Value of action
   * @param event Dom event that triggered this handler
   */
  handleAction: PropTypes__default['default'].func,

  /**
   * Handler for pinning a current message
   *
   * @param event React's MouseEventHandler event
   * @returns void
   * */
  handlePin: PropTypes__default['default'].func,

  /**
   * The handler for hover event on @mention in message
   *
   * @param event Dom hover event which triggered handler.
   * @param user Target user object
   */
  onMentionsHoverMessage: PropTypes__default['default'].func,

  /**
   * The handler for click event on @mention in message
   *
   * @param event Dom click event which triggered handler.
   * @param user Target user object
   */
  onMentionsClickMessage: PropTypes__default['default'].func,

  /**
   * The handler for click event on the user that posted the message
   *
   * @param event Dom click event which triggered handler.
   */
  onUserClick: PropTypes__default['default'].func,

  /**
   * The handler for mouseOver event on the user that posted the message
   *
   * @param event Dom mouseOver event which triggered handler.
   */
  onUserHover: PropTypes__default['default'].func,

  /** Position of message in group. Possible values: top, bottom, middle, single */
  groupStyles: PropTypes__default['default'].array,

  /**
   * The component that will be rendered if the message has been deleted.
   * All of Message's props are passed into this component.
   */
  MessageDeleted:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').MessageDeletedProps>>} */
  PropTypes__default['default'].elementType
};
var MessageTeam$1 = /*#__PURE__*/React__default['default'].memo(MessageTeam, areMessagePropsEqual);

// @ts-check
/**
 * @param { number } number
 * @param { boolean } dark
 */

var selectColor = function selectColor(number, dark) {
  var hue = number * 137.508; // use golden angle approximation

  return "hsl(".concat(hue, ",").concat(dark ? '50%' : '85%', ", ").concat(dark ? '75%' : '55%', ")");
};
/**
 * @param { string } userId
 */


var hashUserId = function hashUserId(userId) {
  var hash = userId.split('').reduce(function (acc, c) {
    acc = (acc << 5) - acc + c.charCodeAt(0); // eslint-disable-line

    return acc & acc; // eslint-disable-line no-bitwise
  }, 0);
  return Math.abs(hash) / Math.pow(10, Math.ceil(Math.log10(Math.abs(hash) + 1)));
};
/**
 * @param { string } theme
 * @param { string } userId
 */


var getUserColor = function getUserColor(theme, userId) {
  return selectColor(hashUserId(userId), theme.includes('dark'));
};
/**
 * FixedHeightMessage - This component renders a single message.
 * It uses fixed height elements to make sure it works well in VirtualizedMessageList
 * @type {React.FC<import('../types').FixedHeightMessageProps>}
 */


var FixedHeightMessage = function FixedHeightMessage(_ref) {
  var _message$i18n, _message$user, _message$attachments, _message$user2, _message$user3, _message$user4, _message$user5;

  var message = _ref.message,
      groupedByUser = _ref.groupedByUser;

  var _useContext = React.useContext(ChatContext),
      theme = _useContext.theme;

  var _useContext2 = React.useContext(TranslationContext),
      userLanguage = _useContext2.userLanguage;

  var role = useUserRole(message);
  var handleAction = useActionHandler(message);
  var messageTextToRender = // @ts-expect-error
  (message === null || message === void 0 ? void 0 : (_message$i18n = message.i18n) === null || _message$i18n === void 0 ? void 0 : _message$i18n["".concat(userLanguage, "_text")]) || (message === null || message === void 0 ? void 0 : message.text);
  var renderedText = React.useMemo(function () {
    return renderText(messageTextToRender, message.mentioned_users);
  }, [message.mentioned_users, messageTextToRender]);
  var userId = (_message$user = message.user) === null || _message$user === void 0 ? void 0 : _message$user.id; // @ts-ignore

  var userColor = React.useMemo(function () {
    return getUserColor(theme, userId);
  }, [userId, theme]);
  var messageActionsHandler = React.useCallback(function () {
    return getMessageActions(['delete'], {
      canDelete: role.canDeleteMessage
    });
  }, [role]);
  var images = message === null || message === void 0 ? void 0 : (_message$attachments = message.attachments) === null || _message$attachments === void 0 ? void 0 : _message$attachments.filter(function (_ref2) {
    var type = _ref2.type;
    return type === 'image';
  });
  return /*#__PURE__*/React__default['default'].createElement("div", {
    key: message.id,
    className: "str-chat__virtual-message__wrapper ".concat(role.isMyMessage ? 'str-chat__virtual-message__wrapper--me' : '', " ").concat(groupedByUser ? 'str-chat__virtual-message__wrapper--group' : '')
  }, /*#__PURE__*/React__default['default'].createElement(Avatar, {
    shape: "rounded",
    size: 38 // @ts-ignore
    ,
    image: (_message$user2 = message.user) === null || _message$user2 === void 0 ? void 0 : _message$user2.image,
    name: ((_message$user3 = message.user) === null || _message$user3 === void 0 ? void 0 : _message$user3.name) || ((_message$user4 = message.user) === null || _message$user4 === void 0 ? void 0 : _message$user4.id)
  }), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__virtual-message__content"
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__virtual-message__meta"
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__virtual-message__author",
    style: {
      color: userColor
    }
  }, /*#__PURE__*/React__default['default'].createElement("strong", null, ((_message$user5 = message.user) === null || _message$user5 === void 0 ? void 0 : _message$user5.name) || 'unknown'))), images && /*#__PURE__*/React__default['default'].createElement(Gallery$1, {
    images: images
  }), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__virtual-message__text",
    "data-testid": "msg-text"
  }, renderedText, message.mml && /*#__PURE__*/React__default['default'].createElement(MML, {
    source: message.mml,
    actionHandler: handleAction,
    align: "left"
  }), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__virtual-message__data"
  }, /*#__PURE__*/React__default['default'].createElement(MessageActions, {
    message: message,
    customWrapperClass: "str-chat__virtual-message__actions",
    getMessageActions: messageActionsHandler
  }), /*#__PURE__*/React__default['default'].createElement("span", {
    className: "str-chat__virtual-message__date"
  }, /*#__PURE__*/React__default['default'].createElement(MessageTimestamp$1, {
    customClass: "str-chat__message-simple-timestamp",
    message: message
  }))))));
};

var FixedHeightMessage$1 = /*#__PURE__*/React__default['default'].memo(FixedHeightMessage);

function ownKeys$7(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$7(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$7(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$7(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
/** @type {import('./types').ChannelStateReducer} */

var channelReducer = function channelReducer(state, action) {
  switch (action.type) {
    case 'initStateFromChannel':
      {
        var channel = action.channel;
        return _objectSpread$7(_objectSpread$7({}, state), {}, {
          messages: channel.state.messages,
          pinnedMessages: channel.state.pinnedMessages,
          read: channel.state.read,
          watchers: channel.state.watchers,
          members: channel.state.members,
          watcherCount: channel.state.watcher_count,
          loading: false
        });
      }

    case 'copyStateFromChannelOnEvent':
      {
        var _channel = action.channel;
        return _objectSpread$7(_objectSpread$7({}, state), {}, {
          messages: _channel.state.messages,
          pinnedMessages: _channel.state.pinnedMessages,
          read: _channel.state.read,
          watchers: _channel.state.watchers,
          members: _channel.state.members,
          typing: _channel.state.typing,
          watcherCount: _channel.state.watcher_count
        });
      }

    case 'setThread':
      {
        var message = action.message;
        return _objectSpread$7(_objectSpread$7({}, state), {}, {
          thread: message
        });
      }

    case 'loadMoreFinished':
      {
        var hasMore = action.hasMore,
            messages = action.messages;
        return _objectSpread$7(_objectSpread$7({}, state), {}, {
          loadingMore: false,
          hasMore,
          messages
        });
      }

    case 'setLoadingMore':
      {
        var loadingMore = action.loadingMore;
        return _objectSpread$7(_objectSpread$7({}, state), {}, {
          loadingMore
        });
      }

    case 'copyMessagesFromChannel':
      {
        var _channel2 = action.channel,
            parentId = action.parentId;
        return _objectSpread$7(_objectSpread$7({}, state), {}, {
          messages: _channel2.state.messages,
          pinnedMessages: _channel2.state.pinnedMessages,
          threadMessages: parentId ? _channel2.state.threads[parentId] || Immutable__default['default']([]) : state.threadMessages
        });
      }

    case 'updateThreadOnEvent':
      {
        var _state$thread;

        var _channel3 = action.channel,
            _message = action.message;
        if (!state.thread) return state;
        return _objectSpread$7(_objectSpread$7({}, state), {}, {
          threadMessages: (_state$thread = state.thread) !== null && _state$thread !== void 0 && _state$thread.id ? _channel3.state.threads[state.thread.id] || Immutable__default['default']([]) : Immutable__default['default']([]),
          thread: (_message === null || _message === void 0 ? void 0 : _message.id) === state.thread.id ? _channel3.state.messageToImmutable(_message) : state.thread
        });
      }

    case 'openThread':
      {
        var _message2 = action.message,
            _channel4 = action.channel;
        return _objectSpread$7(_objectSpread$7({}, state), {}, {
          thread: _message2,
          threadMessages: _message2.id ? _channel4.state.threads[_message2.id] || Immutable__default['default']([]) : Immutable__default['default']([])
        });
      }

    case 'startLoadingThread':
      {
        return _objectSpread$7(_objectSpread$7({}, state), {}, {
          threadLoadingMore: true
        });
      }

    case 'loadMoreThreadFinished':
      {
        var threadHasMore = action.threadHasMore,
            threadMessages = action.threadMessages;
        return _objectSpread$7(_objectSpread$7({}, state), {}, {
          threadHasMore,
          threadMessages,
          threadLoadingMore: false
        });
      }

    case 'closeThread':
      {
        return _objectSpread$7(_objectSpread$7({}, state), {}, {
          thread: null,
          threadMessages: Immutable__default['default']([]),
          threadLoadingMore: false
        });
      }

    case 'setError':
      {
        var error = action.error;
        return _objectSpread$7(_objectSpread$7({}, state), {}, {
          error
        });
      }

    default:
      return state;
  }
};
/** @type {import('./types').ChannelState} */

var initialState = {
  error: null,
  loading: true,
  loadingMore: false,
  hasMore: true,
  messages: Immutable__default['default']([]),
  pinnedMessages: Immutable__default['default']([]),
  typing: Immutable__default['default'](
  /** @type {any} infer from ChannelState */
  {}),
  members: Immutable__default['default'](
  /** @type {any} infer from ChannelState */
  {}),
  watchers: Immutable__default['default'](
  /** @type {any} infer from ChannelState */
  {}),
  watcherCount: 0,
  read: Immutable__default['default'](
  /** @type {any} infer from ChannelState */
  {}),
  thread: null,
  threadMessages: Immutable__default['default']([]),
  threadLoadingMore: false,
  threadHasMore: true
};

// @ts-check
/**
 * @type {import('../types').useMentionsHandlers}
 */

var useMentionsHandlers = function useMentionsHandlers(onMentionsHover, onMentionsClick) {
  return React.useCallback(function (e, mentioned_users) {
    if (!onMentionsHover && !onMentionsClick) return; // eslint-disable-next-line prefer-destructuring

    var target =
    /** @type {HTMLSpanElement} */
    e.target;
    var tagName = target === null || target === void 0 ? void 0 : target.tagName.toLowerCase();
    var textContent = target === null || target === void 0 ? void 0 : target.innerHTML.replace('*', '');

    if (tagName === 'strong' && textContent[0] === '@') {
      var userName = textContent.replace('@', '');
      var user = mentioned_users.find(function (_ref) {
        var name = _ref.name,
            id = _ref.id;
        return name === userName || id === userName;
      });

      if (onMentionsHover && typeof onMentionsHover === 'function' && e.type === 'mouseover') {
        onMentionsHover(e, user);
      }

      if (onMentionsClick && e.type === 'click' && typeof onMentionsClick === 'function') {
        onMentionsClick(e, user);
      }
    }
  }, [onMentionsClick, onMentionsHover]);
};

// @ts-check
/**
 * @type {import('../types').useEditMessageHandler}
 */

var useEditMessageHandler = function useEditMessageHandler(doUpdateMessageRequest) {
  var _useContext = React.useContext(ChatContext),
      channel = _useContext.channel,
      client = _useContext.client;

  return function (updatedMessage) {
    if (doUpdateMessageRequest && channel) {
      return Promise.resolve(doUpdateMessageRequest(channel.cid, updatedMessage));
    }

    return client.updateMessage(updatedMessage);
  };
};

var useIsMounted = (function () {
  var isMounted = React.useRef(true);
  React.useEffect(function () {
    return function () {
      isMounted.current = false;
    };
  }, []);
  return isMounted;
});

function ownKeys$8(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$8(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$8(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$8(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
/** @type {React.FC<import('../types').ChannelProps>}>} */

var Channel = function Channel(_ref) {
  var _ref$EmptyPlaceholder = _ref.EmptyPlaceholder,
      EmptyPlaceholder = _ref$EmptyPlaceholder === void 0 ? null : _ref$EmptyPlaceholder,
      props = _objectWithoutProperties__default['default'](_ref, ["EmptyPlaceholder"]);

  var _useContext = React.useContext(ChatContext),
      contextChannel = _useContext.channel;

  var channel = props.channel || contextChannel;
  if (!(channel !== null && channel !== void 0 && channel.cid)) return EmptyPlaceholder;
  return /*#__PURE__*/React__default['default'].createElement(ChannelInner, _extends__default['default']({}, props, {
    channel: channel,
    key: channel.cid
  }));
};
/** @type {React.FC<import('../types').ChannelProps & { channel: import('stream-chat').Channel }>} */


var ChannelInner = function ChannelInner(_ref2) {
  var _props$channel;

  var _ref2$Attachment = _ref2.Attachment,
      Attachment$1 = _ref2$Attachment === void 0 ? Attachment : _ref2$Attachment,
      doMarkReadRequest = _ref2.doMarkReadRequest,
      _ref2$LoadingErrorInd = _ref2.LoadingErrorIndicator,
      LoadingErrorIndicator = _ref2$LoadingErrorInd === void 0 ? DefaultLoadingErrorIndicator : _ref2$LoadingErrorInd,
      _ref2$LoadingIndicato = _ref2.LoadingIndicator,
      LoadingIndicator = _ref2$LoadingIndicato === void 0 ? DefaultLoadingIndicator : _ref2$LoadingIndicato,
      _ref2$Message = _ref2.Message,
      Message = _ref2$Message === void 0 ? MessageSimple$1 : _ref2$Message,
      props = _objectWithoutProperties__default['default'](_ref2, ["Attachment", "doMarkReadRequest", "LoadingErrorIndicator", "LoadingIndicator", "Message"]);

  var channel = props.channel;

  var _useContext2 = React.useContext(ChatContext),
      client = _useContext2.client,
      mutes = _useContext2.mutes,
      theme = _useContext2.theme;

  var _useContext3 = React.useContext(TranslationContext),
      t = _useContext3.t;

  var _useReducer = React.useReducer(channelReducer, initialState),
      _useReducer2 = _slicedToArray__default['default'](_useReducer, 2),
      state = _useReducer2[0],
      dispatch = _useReducer2[1];

  var isMounted = useIsMounted();
  var originalTitle = React.useRef('');
  var lastRead = React.useRef(new Date());
  var online = React.useRef(true); // eslint-disable-next-line react-hooks/exhaustive-deps

  var throttledCopyStateFromChannel = React.useCallback(throttle__default['default'](function () {
    dispatch({
      type: 'copyStateFromChannelOnEvent',
      channel
    });
  }, 500, {
    leading: true,
    trailing: true
  }), [channel]);
  var markRead = React.useCallback(function () {
    var _channel$getConfig;

    if (channel.disconnected || !((_channel$getConfig = channel.getConfig()) !== null && _channel$getConfig !== void 0 && _channel$getConfig.read_events)) {
      return;
    }

    lastRead.current = new Date();

    if (doMarkReadRequest) {
      doMarkReadRequest(channel);
    } else {
      streamChat.logChatPromiseExecution(channel.markRead(), 'mark read');
    }

    if (originalTitle.current) {
      document.title = originalTitle.current;
    }
  }, [channel, doMarkReadRequest]); // eslint-disable-next-line react-hooks/exhaustive-deps

  var markReadThrottled = React.useCallback(throttle__default['default'](markRead, 500, {
    leading: true,
    trailing: true
  }), [markRead]);
  var handleEvent = React.useCallback(function (e) {
    dispatch({
      type: 'updateThreadOnEvent',
      message: e.message,
      channel
    });

    if (e.type === 'connection.changed') {
      online.current = e.online;
    }

    if (e.type === 'message.new') {
      var mainChannelUpdated = true;

      if (e.message.parent_id && !e.message.show_in_channel) {
        mainChannelUpdated = false;
      }

      if (mainChannelUpdated && e.message.user.id !== client.userID) {
        var _channel$getConfig2;

        if (!document.hidden) {
          markReadThrottled();
        } else if ((_channel$getConfig2 = channel.getConfig()) !== null && _channel$getConfig2 !== void 0 && _channel$getConfig2.read_events && !channel.muteStatus().muted) {
          var unread = channel.countUnread(lastRead.current);
          document.title = "(".concat(unread, ") ").concat(originalTitle.current);
        }
      }
    }

    throttledCopyStateFromChannel();
  }, [channel, throttledCopyStateFromChannel, client.userID, markReadThrottled]); // useLayoutEffect here to prevent spinner. Use Suspense when it is available in stable release

  React.useLayoutEffect(function () {
    var errored = false;
    var done = false;

    var onVisibilityChange = function onVisibilityChange() {
      if (!document.hidden) {
        markRead();
      }
    };

    _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {
      return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (channel.initialized) {
                _context.next = 10;
                break;
              }

              _context.prev = 1;
              _context.next = 4;
              return channel.watch();

            case 4:
              _context.next = 10;
              break;

            case 6:
              _context.prev = 6;
              _context.t0 = _context["catch"](1);
              dispatch({
                type: 'setError',
                error: _context.t0
              });
              errored = true;

            case 10:
              done = true;
              originalTitle.current = document.title;

              if (!errored) {
                dispatch({
                  type: 'initStateFromChannel',
                  channel
                });
                if (channel.countUnread() > 0) markRead(); // The more complex sync logic is done in chat.js
                // listen to client.connection.recovered and all channel events

                document.addEventListener('visibilitychange', onVisibilityChange);
                client.on('connection.changed', handleEvent);
                client.on('connection.recovered', handleEvent);
                channel.on(handleEvent);
              }

            case 13:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[1, 6]]);
    }))();

    return function () {
      if (errored || !done) return;
      document.removeEventListener('visibilitychange', onVisibilityChange);
      channel.off(handleEvent);
      client.off('connection.changed', handleEvent);
      client.off('connection.recovered', handleEvent);
    };
  }, [channel, client, handleEvent, markRead, props.channel]);
  React.useEffect(function () {
    if (state.thread) {
      for (var i = state.messages.length - 1; i >= 0; i -= 1) {
        if (state.messages[i].id === state.thread.id) {
          dispatch({
            type: 'setThread',
            message: state.messages[i]
          });
          break;
        }
      }
    }
  }, [state.messages, state.thread]); // Message
  // eslint-disable-next-line react-hooks/exhaustive-deps

  var loadMoreFinished = React.useCallback(debounce__default['default'](
  /**
   * @param {boolean} hasMore
   * @param {import('stream-chat').ChannelState['messages']} messages
   */
  function (hasMore, messages) {
    if (!isMounted.current) return;
    dispatch({
      type: 'loadMoreFinished',
      hasMore,
      messages
    });
  }, 2000, {
    leading: true,
    trailing: true
  }), []);
  var loadMore = React.useCallback( /*#__PURE__*/_asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2() {
    var limit,
        oldestMessage,
        oldestID,
        perPage,
        queryResponse,
        hasMoreMessages,
        _args2 = arguments;
    return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            limit = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : 100;

            if (!(!online.current || !window.navigator.onLine)) {
              _context2.next = 3;
              break;
            }

            return _context2.abrupt("return", 0);

          case 3:
            // prevent duplicate loading events...
            oldestMessage = state.messages[0];

            if (!(state.loadingMore || (oldestMessage === null || oldestMessage === void 0 ? void 0 : oldestMessage.status) !== 'received')) {
              _context2.next = 6;
              break;
            }

            return _context2.abrupt("return", 0);

          case 6:
            dispatch({
              type: 'setLoadingMore',
              loadingMore: true
            });
            oldestID = oldestMessage === null || oldestMessage === void 0 ? void 0 : oldestMessage.id;
            perPage = limit;
            _context2.prev = 9;
            _context2.next = 12;
            return channel.query({
              messages: {
                limit: perPage,
                id_lt: oldestID
              }
            });

          case 12:
            queryResponse = _context2.sent;
            _context2.next = 20;
            break;

          case 15:
            _context2.prev = 15;
            _context2.t0 = _context2["catch"](9);
            console.warn('message pagination request failed with error', _context2.t0);
            dispatch({
              type: 'setLoadingMore',
              loadingMore: false
            });
            return _context2.abrupt("return", 0);

          case 20:
            hasMoreMessages = queryResponse.messages.length === perPage;
            loadMoreFinished(hasMoreMessages, channel.state.messages);
            return _context2.abrupt("return", queryResponse.messages.length);

          case 23:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[9, 15]]);
  })), [channel, loadMoreFinished, state.loadingMore, state.messages, online]);
  var updateMessage = React.useCallback(function (updatedMessage) {
    // adds the message to the local channel state..
    // this adds to both the main channel state as well as any reply threads
    channel.state.addMessageSorted(updatedMessage, true);
    dispatch({
      type: 'copyMessagesFromChannel',
      parentId: state.thread && updatedMessage.parent_id,
      channel
    });
  }, [channel, state.thread]);
  var doSendMessageRequest = props.doSendMessageRequest;
  var doSendMessage = React.useCallback( /*#__PURE__*/function () {
    var _ref5 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(message) {
      var text, attachments, id, parent_id, mentioned_users, messageData, messageResponse;
      return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              text = message.text, attachments = message.attachments, id = message.id, parent_id = message.parent_id, mentioned_users = message.mentioned_users;
              messageData = {
                text,
                attachments,
                mentioned_users,
                id,
                parent_id
              };
              _context3.prev = 2;

              if (!doSendMessageRequest) {
                _context3.next = 9;
                break;
              }

              _context3.next = 6;
              return doSendMessageRequest(channel.cid, messageData);

            case 6:
              messageResponse = _context3.sent;
              _context3.next = 12;
              break;

            case 9:
              _context3.next = 11;
              return channel.sendMessage(messageData);

            case 11:
              messageResponse = _context3.sent;

            case 12:
              // replace it after send is completed
              if (messageResponse && messageResponse.message) {
                updateMessage(_objectSpread$8(_objectSpread$8({}, messageResponse.message), {}, {
                  status: 'received'
                }));
              }

              _context3.next = 18;
              break;

            case 15:
              _context3.prev = 15;
              _context3.t0 = _context3["catch"](2);
              // set the message to failed..
              updateMessage(_objectSpread$8(_objectSpread$8({}, message), {}, {
                status: 'failed'
              }));

            case 18:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, null, [[2, 15]]);
    }));

    return function (_x) {
      return _ref5.apply(this, arguments);
    };
  }(), [channel, doSendMessageRequest, updateMessage]);
  var createMessagePreview = React.useCallback(function (text, attachments, parent, mentioned_users) {
    // create a preview of the message
    var clientSideID = "".concat(client.userID, "-").concat(uuid.v4());
    return _objectSpread$8({
      text,
      html: text,
      __html: text,
      id: clientSideID,
      type: 'regular',
      status: 'sending',
      user: client.user,
      created_at: new Date(),
      attachments,
      mentioned_users,
      reactions: []
    }, parent !== null && parent !== void 0 && parent.id ? {
      parent_id: parent.id
    } : null);
  }, [client.user, client.userID]);
  var sendMessage = React.useCallback( /*#__PURE__*/function () {
    var _ref7 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee4(_ref6) {
      var text, _ref6$attachments, attachments, _ref6$mentioned_users, mentioned_users, parent, messagePreview;

      return _regeneratorRuntime__default['default'].wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              text = _ref6.text, _ref6$attachments = _ref6.attachments, attachments = _ref6$attachments === void 0 ? [] : _ref6$attachments, _ref6$mentioned_users = _ref6.mentioned_users, mentioned_users = _ref6$mentioned_users === void 0 ? [] : _ref6$mentioned_users, parent = _ref6.parent;
              // remove error messages upon submit
              channel.state.filterErrorMessages(); // create a local preview message to show in the UI

              messagePreview = createMessagePreview(text, attachments, parent, mentioned_users); // first we add the message to the UI

              updateMessage(messagePreview);
              _context4.next = 6;
              return doSendMessage(messagePreview);

            case 6:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    return function (_x2) {
      return _ref7.apply(this, arguments);
    };
  }(), [channel.state, createMessagePreview, doSendMessage, updateMessage]);
  var retrySendMessage = React.useCallback( /*#__PURE__*/function () {
    var _ref8 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee5(message) {
      return _regeneratorRuntime__default['default'].wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              // set the message status to sending
              updateMessage(_objectSpread$8(_objectSpread$8({}, message), {}, {
                status: 'sending'
              })); // actually try to send the message...

              _context5.next = 3;
              return doSendMessage(message);

            case 3:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));

    return function (_x3) {
      return _ref8.apply(this, arguments);
    };
  }(), [doSendMessage, updateMessage]);
  var removeMessage = React.useCallback(function (message) {
    channel.state.removeMessage(message);
    dispatch({
      type: 'copyMessagesFromChannel',
      parentId: state.thread && message.parent_id,
      channel
    });
  }, [channel, state.thread]); // Thread

  var openThread = React.useCallback(function (message, e) {
    if (e && e.preventDefault) {
      e.preventDefault();
    }

    dispatch({
      type: 'openThread',
      message,
      channel
    });
  }, [channel]); // eslint-disable-next-line react-hooks/exhaustive-deps

  var loadMoreThreadFinished = React.useCallback(debounce__default['default'](
  /**
   * @param {boolean} threadHasMore
   * @param {import('seamless-immutable').ImmutableArray<ReturnType<import('stream-chat').ChannelState['messageToImmutable']>>} threadMessages
   */
  function (threadHasMore, threadMessages) {
    dispatch({
      type: 'loadMoreThreadFinished',
      threadHasMore,
      threadMessages
    });
  }, 2000, {
    leading: true,
    trailing: true
  }), []);
  var loadMoreThread = React.useCallback( /*#__PURE__*/_asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee6() {
    var _oldMessages$;

    var parentID, oldMessages, oldestMessageID, limit, queryResponse, threadHasMoreMessages, newThreadMessages;
    return _regeneratorRuntime__default['default'].wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            if (!(state.threadLoadingMore || !state.thread)) {
              _context6.next = 2;
              break;
            }

            return _context6.abrupt("return");

          case 2:
            dispatch({
              type: 'startLoadingThread'
            });
            parentID = state.thread.id;

            if (parentID) {
              _context6.next = 7;
              break;
            }

            dispatch({
              type: 'closeThread'
            });
            return _context6.abrupt("return");

          case 7:
            oldMessages = channel.state.threads[parentID] || [];
            oldestMessageID = (_oldMessages$ = oldMessages[0]) === null || _oldMessages$ === void 0 ? void 0 : _oldMessages$.id;
            limit = 50;
            _context6.prev = 10;
            _context6.next = 13;
            return channel.getReplies(parentID, {
              limit,
              id_lt: oldestMessageID
            });

          case 13:
            queryResponse = _context6.sent;
            threadHasMoreMessages = queryResponse.messages.length === limit;
            newThreadMessages = channel.state.threads[parentID] || []; // next set loadingMore to false so we can start asking for more data...

            loadMoreThreadFinished(threadHasMoreMessages, newThreadMessages);
            _context6.next = 22;
            break;

          case 19:
            _context6.prev = 19;
            _context6.t0 = _context6["catch"](10);
            loadMoreThreadFinished(false, oldMessages);

          case 22:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, null, [[10, 19]]);
  })), [channel, loadMoreThreadFinished, state.thread, state.threadLoadingMore]);
  var closeThread = React.useCallback(function (e) {
    if (e && e.preventDefault) {
      e.preventDefault();
    }

    dispatch({
      type: 'closeThread'
    });
  }, []);
  var onMentionsHoverOrClick = useMentionsHandlers(props.onMentionsHover, props.onMentionsClick);
  var editMessage = useEditMessageHandler(props.doUpdateMessageRequest);

  var channelContextValue = _objectSpread$8(_objectSpread$8({}, state), {}, {
    watcher_count: state.watcherCount,
    // props
    acceptedFiles: props.acceptedFiles,
    Attachment: Attachment$1,
    channel,
    maxNumberOfFiles: props.maxNumberOfFiles,
    Message,
    multipleUploads: props.multipleUploads,
    mutes,
    // handlers
    closeThread,
    editMessage,
    loadMore,
    loadMoreThread,
    onMentionsClick: onMentionsHoverOrClick,
    onMentionsHover: onMentionsHoverOrClick,
    openThread,
    removeMessage,
    retrySendMessage,
    sendMessage,
    updateMessage,
    // from chatContext, for legacy reasons
    client
  });

  var core;

  if (state.error) {
    core = /*#__PURE__*/React__default['default'].createElement(LoadingErrorIndicator, {
      error: state.error
    });
  } else if (state.loading) {
    core = /*#__PURE__*/React__default['default'].createElement(LoadingIndicator, {
      size: 25
    });
  } else if (!((_props$channel = props.channel) !== null && _props$channel !== void 0 && _props$channel.watch)) {
    core = /*#__PURE__*/React__default['default'].createElement("div", null, t('Channel Missing'));
  } else {
    core = /*#__PURE__*/React__default['default'].createElement(ChannelContext.Provider, {
      value: channelContextValue
    }, /*#__PURE__*/React__default['default'].createElement("div", {
      className: "str-chat__container"
    }, props.children));
  }

  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat str-chat-channel ".concat(theme)
  }, core);
};

Channel.defaultProps = {
  multipleUploads: true
};
Channel.propTypes = {
  /** Which channel to connect to, will initialize the channel if it's not initialized yet */
  channel: PropTypes__default['default'].instanceOf(streamChat.Channel),

  /**
   * Empty channel UI component. This will be shown on the screen if there is no active channel.
   *
   * Defaults to null which skips rendering the Channel
   *
   * */
  EmptyPlaceholder: PropTypes__default['default'].element,

  /**
   * Error indicator UI component. This will be shown on the screen if channel query fails.
   *
   * Defaults to and accepts same props as: [LoadingErrorIndicator](https://getstream.github.io/stream-chat-react/#loadingerrorindicator)
   *
   * */
  // @ts-ignore elementType
  LoadingErrorIndicator: PropTypes__default['default'].elementType,

  /**
   * Loading indicator UI component. This will be shown on the screen until the messages are
   * being queried from channel≈ì. Once the messages are loaded, loading indicator is removed from the screen
   * and replaced with children of the Channel component.
   *
   * Defaults to and accepts same props as: [LoadingIndicator](https://github.com/GetStream/stream-chat-react/blob/master/src/components/LoadingIndicator.js)
   */
  // @ts-ignore elementType
  LoadingIndicator: PropTypes__default['default'].elementType,

  /**
   * Message UI component to display a message in message list.
   *
   * Available built-in components (also accepts the same props as):
   *
   * 1. [MessageSimple](https://github.com/GetStream/stream-chat-react/blob/master/src/components/MessageSimple.js) (default)
   * 2. [MessageTeam](https://github.com/GetStream/stream-chat-react/blob/master/src/components/MessageTeam.js)
   * 3. [MessageLivestream](https://github.com/GetStream/stream-chat-react/blob/master/src/components/MessageLivestream.js)
   * 3. [MessageCommerce](https://github.com/GetStream/stream-chat-react/blob/master/src/components/MessageCommerce.js)
   *
   * */
  // @ts-ignore elementType
  Message: PropTypes__default['default'].elementType,

  /**
   * Attachment UI component to display attachment in individual message.
   *
   * Defaults to and accepts same props as: [Attachment](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Attachment.js)
   * */
  // @ts-ignore elementType
  Attachment: PropTypes__default['default'].elementType,

  /**
   * Handle for click on @mention in message
   *
   * @param {Event} event DOM Click event
   * @param {User} user   Target [user object](https://getstream.io/chat/docs/#chat-doc-set-user) which is clicked
   */
  onMentionsClick: PropTypes__default['default'].func,

  /**
   * Handle for hover on @mention in message
   *
   * @param {Event} event DOM hover event
   * @param {User} user   Target [user object](https://getstream.io/chat/docs/#chat-doc-set-user) which is hovered
   */
  onMentionsHover: PropTypes__default['default'].func,

  /** Whether to allow multiple attachment uploads */
  multipleUploads: PropTypes__default['default'].bool,

  /** List of accepted file types */
  acceptedFiles: PropTypes__default['default'].array,

  /** Maximum number of attachments allowed per message */
  maxNumberOfFiles: PropTypes__default['default'].number,

  /** Override send message request (Advanced usage only)
   *
   * @param {String} channelId full channel ID in format of `type:id`
   * @param {Object} message
   */
  doSendMessageRequest: PropTypes__default['default'].func,

  /**
   * Override mark channel read request (Advanced usage only)
   *
   * @param {Channel} channel object
   * */
  doMarkReadRequest: PropTypes__default['default'].func,

  /** Override update(edit) message request (Advanced usage only)
   *
   * @param {String} channelId full channel ID in format of `type:id`
   * @param {Object} updatedMessage
   */
  doUpdateMessageRequest: PropTypes__default['default'].func
};
var Channel$1 = /*#__PURE__*/React__default['default'].memo(Channel);

// @ts-check
/**
 * ChannelHeader - Render some basic information about this channel
 * @example ../../docs/ChannelHeader.md
 * @type {React.FC<import('../types').ChannelHeaderProps>}
 */

var ChannelHeader = function ChannelHeader(_ref) {
  var _ref$Avatar = _ref.Avatar,
      Avatar$1 = _ref$Avatar === void 0 ? Avatar : _ref$Avatar,
      title = _ref.title,
      live = _ref.live;

  /** @type {import("types").TranslationContextValue} */
  var _useContext = React.useContext(TranslationContext),
      t = _useContext.t;
  /** @type {import("types").ChannelContextValue} */


  var _useContext2 = React.useContext(ChannelContext),
      channel = _useContext2.channel,
      watcher_count = _useContext2.watcher_count;

  var _useContext3 = React.useContext(ChatContext),
      openMobileNav = _useContext3.openMobileNav;

  var _ref2 = (channel === null || channel === void 0 ? void 0 : channel.data) || {},
      image = _ref2.image,
      member_count = _ref2.member_count,
      name = _ref2.name,
      subtitle = _ref2.subtitle;

  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__header-livestream"
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__header-hamburger",
    onClick: openMobileNav
  }, /*#__PURE__*/React__default['default'].createElement("span", {
    className: "str-chat__header-hamburger--line"
  }), /*#__PURE__*/React__default['default'].createElement("span", {
    className: "str-chat__header-hamburger--line"
  }), /*#__PURE__*/React__default['default'].createElement("span", {
    className: "str-chat__header-hamburger--line"
  })), image && /*#__PURE__*/React__default['default'].createElement(Avatar$1, {
    image: image,
    shape: "rounded",
    size: (channel === null || channel === void 0 ? void 0 : channel.type) === 'commerce' ? 60 : 40
  }), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__header-livestream-left"
  }, /*#__PURE__*/React__default['default'].createElement("p", {
    className: "str-chat__header-livestream-left--title"
  }, title || name, ' ', live && /*#__PURE__*/React__default['default'].createElement("span", {
    className: "str-chat__header-livestream-left--livelabel"
  }, t('live'))), subtitle && /*#__PURE__*/React__default['default'].createElement("p", {
    className: "str-chat__header-livestream-left--subtitle"
  }, subtitle), /*#__PURE__*/React__default['default'].createElement("p", {
    className: "str-chat__header-livestream-left--members"
  }, !live && !!member_count && member_count > 0 && /*#__PURE__*/React__default['default'].createElement(React__default['default'].Fragment, null, t('{{ memberCount }} members', {
    memberCount: member_count
  }), ",", ' '), t('{{ watcherCount }} online', {
    watcherCount: watcher_count
  }))));
};

ChannelHeader.propTypes = {
  /**
   * Custom UI component to display user avatar
   *
   * Defaults to and accepts same props as: [Avatar](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Avatar/Avatar.js)
   * */
  Avatar:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').AvatarProps>>} */
  PropTypes__default['default'].elementType,

  /** Set title manually */
  title: PropTypes__default['default'].string,

  /** Show a little indicator that the channel is live right now */
  live: PropTypes__default['default'].bool
};
var ChannelHeader$1 = /*#__PURE__*/React__default['default'].memo(ChannelHeader);

var placeholder = "data:image/svg+xml,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%3F%3E%3Csvg%20width%3D%2278px%22%20height%3D%2278px%22%20viewBox%3D%220%200%2078%2078%22%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%20%20%20%20%20%20%20%20%3Ctitle%3ECombined%20Shape%3C%2Ftitle%3E%20%20%20%20%3Cdesc%3ECreated%20with%20Sketch.%3C%2Fdesc%3E%20%20%20%20%3Cg%20id%3D%22Interactions%22%20stroke%3D%22none%22%20stroke-width%3D%221%22%20fill%3D%22none%22%20fill-rule%3D%22evenodd%22%3E%20%20%20%20%20%20%20%20%3Cg%20id%3D%22Connection-Error-_-Connectivity%22%20transform%3D%22translate%28-270.000000%2C%20-30.000000%29%22%20fill%3D%22%23CF1F25%22%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Cg%20id%3D%22109-network-connection%22%20transform%3D%22translate%28270.000000%2C%2030.000000%29%22%3E%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M66.4609744%2C11.414231%20C81.6225232%2C26.5757798%2081.6225232%2C51.157545%2066.4609744%2C66.3188467%20C51.2994256%2C81.4803954%2026.7176604%2C81.4803954%2011.5563587%2C66.3188467%20C-3.60519004%2C51.1572979%20-3.60519004%2C26.5755327%2011.5563587%2C11.414231%20C26.7179075%2C-3.74731776%2051.2996727%2C-3.74731776%2066.4609744%2C11.414231%20Z%20M54.7853215%2C45.8823776%20L54.7853215%2C40.5882574%20C54.7853215%2C39.613638%2053.9952341%2C38.8235506%2053.0206147%2C38.8235506%20L44.9576695%2C38.8235506%20L41.428256%2C42.3529641%20L51.255555%2C42.3529641%20L51.255555%2C45.8823776%20L54.7853215%2C45.8823776%20Z%20M40.6659027%2C43.1153174%20L37.8988425%2C45.8823776%20L40.6659027%2C45.8823776%20L40.6659027%2C43.1153174%20Z%20M51.1764962%2C56.4702653%20L58.2353232%2C56.4702653%20C59.2099355%2C56.4702653%2060.00003%2C55.6801708%2060.00003%2C54.7055585%20L60.00003%2C51.176145%20C60.00003%2C50.2015327%2059.2099355%2C49.4114382%2058.2353232%2C49.4114382%20L51.1764962%2C49.4114382%20C50.2018839%2C49.4114382%2049.4117894%2C50.2015327%2049.4117894%2C51.176145%20L49.4117894%2C54.7055585%20C49.4117894%2C55.6801708%2050.2018839%2C56.4702653%2051.1764962%2C56.4702653%20Z%20M35.2941353%2C56.4702653%20L42.3529624%2C56.4702653%20C43.3275746%2C56.4702653%2044.1176691%2C55.6801708%2044.1176691%2C54.7055585%20L44.1176691%2C51.176145%20C44.1176691%2C50.2015327%2043.3275746%2C49.4114382%2042.3529624%2C49.4114382%20L35.2941353%2C49.4114382%20C34.319523%2C49.4114382%2033.5294285%2C50.2015327%2033.5294285%2C51.176145%20L33.5294285%2C54.7055585%20C33.5294285%2C55.6801708%2034.319523%2C56.4702653%2035.2941353%2C56.4702653%20Z%20M56.6964989%2C19.0874231%20C56.007381%2C18.3985134%2054.8903216%2C18.3985134%2054.2012036%2C19.087423%20L45.882376%2C27.4062507%20L45.882376%2C19.4117761%20C45.882376%2C18.4371568%2045.0922885%2C17.6470693%2044.1176692%2C17.6470693%20L33.5294286%2C17.6470693%20C32.5548092%2C17.6470694%2031.7647218%2C18.4371568%2031.7647218%2C19.4117761%20L31.7647218%2C30.0000167%20C31.7647219%2C30.9746363%2032.5548092%2C31.7647237%2033.5294285%2C31.7647237%20L41.5239031%2C31.7647237%20L34.4650761%2C38.8235508%20L24.7058947%2C38.8235508%20C23.7312753%2C38.8235508%2022.9411879%2C39.6136382%2022.9411879%2C40.5882575%20L22.9411879%2C45.8823778%20L26.4706014%2C45.8823778%20L26.4706014%2C42.3529643%20L30.9356624%2C42.3529643%20L23.8768354%2C49.4117914%20L19.4117743%2C49.4117914%20C18.4371549%2C49.4117914%2017.6470675%2C50.2018788%2017.6470675%2C51.1764981%20L17.6470675%2C54.7059117%20C17.6504049%2C54.9674302%2017.7129076%2C55.2248042%2017.8298886%2C55.4587302%20L16.4456526%2C56.8429662%20C15.7446193%2C57.5200453%2015.7252005%2C58.6372282%2016.4022825%2C59.3382615%20C17.0793616%2C60.0392948%2018.1965445%2C60.0587136%2018.8975778%2C59.3816316%20C18.9122847%2C59.3674273%2018.9267436%2C59.3529684%2018.940948%2C59.3382615%20L56.6964963%2C21.5830662%20C57.3856425%2C20.8939094%2057.3856425%2C19.7765747%2056.6964963%2C19.0874179%20Z%22%20id%3D%22Combined-Shape%22%3E%3C%2Fpath%3E%20%20%20%20%20%20%20%20%20%20%20%20%3C%2Fg%3E%20%20%20%20%20%20%20%20%3C%2Fg%3E%20%20%20%20%3C%2Fg%3E%3C%2Fsvg%3E";

// @ts-check
/**
 * ChatDown - Indicator that chat is down or your network isn't working
 * @example ../../docs/ChatDown.md
 * @typedef {import('../types').ChatDownProps} Props
 * @type {React.FC<Props>}
 */

var ChatDown = function ChatDown(_ref) {
  var image = _ref.image,
      _ref$type = _ref.type,
      type = _ref$type === void 0 ? 'Error' : _ref$type,
      text = _ref.text;

  var _useContext = React.useContext(TranslationContext),
      t = _useContext.t;

  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__down"
  }, /*#__PURE__*/React__default['default'].createElement(LoadingChannels$1, null), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__down-main"
  }, /*#__PURE__*/React__default['default'].createElement("img", {
    "data-testid": "chatdown-img",
    src: image || placeholder
  }), /*#__PURE__*/React__default['default'].createElement("h1", null, type), /*#__PURE__*/React__default['default'].createElement("h3", null, text || t('Error connecting to chat, refresh the page to try again.'))));
};

ChatDown.propTypes = {
  /** The image url for this error */
  image: PropTypes__default['default'].string,

  /** The type of error */
  type: PropTypes__default['default'].string.isRequired,

  /** The error message to show */
  text: PropTypes__default['default'].string
};
var ChatDown$1 = /*#__PURE__*/React__default['default'].memo(ChatDown);

var chevrondown = "data:image/svg+xml,%3Csvg%20width%3D%228%22%20height%3D%225%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%3Cdefs%3E%3Cpath%20id%3D%22b%22%20d%3D%22M.667.667L4%204%207.333.667z%22%2F%3E%3Cfilter%20x%3D%22-7.5%25%22%20y%3D%22-15%25%22%20width%3D%22115%25%22%20height%3D%22160%25%22%20filterUnits%3D%22objectBoundingBox%22%20id%3D%22a%22%3E%3CfeOffset%20dy%3D%221%22%20in%3D%22SourceAlpha%22%20result%3D%22shadowOffsetOuter1%22%2F%3E%3CfeComposite%20in%3D%22shadowOffsetOuter1%22%20in2%3D%22SourceAlpha%22%20operator%3D%22out%22%20result%3D%22shadowOffsetOuter1%22%2F%3E%3CfeColorMatrix%20values%3D%220%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200.685858243%200%22%20in%3D%22shadowOffsetOuter1%22%2F%3E%3C%2Ffilter%3E%3C%2Fdefs%3E%3Cg%20fill%3D%22none%22%20fill-rule%3D%22evenodd%22%3E%3Cuse%20fill%3D%22%23000%22%20filter%3D%22url%28%23a%29%22%20xlink%3Ahref%3D%22%23b%22%2F%3E%3Cuse%20fill-opacity%3D%22.7%22%20fill%3D%22%23FFF%22%20xlink%3Ahref%3D%22%23b%22%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E";

// @ts-check
/**
 * ChannelList - A preview list of channels, allowing you to select the channel you want to open
 * @example ../../docs/ChannelList.md
 * @type React.FC<import('../types').ChannelListUIComponentProps>
 */

var ChannelListTeam = function ChannelListTeam(_ref) {
  var _ref$error = _ref.error,
      error = _ref$error === void 0 ? false : _ref$error,
      loading = _ref.loading,
      sidebarImage = _ref.sidebarImage,
      showSidebar = _ref.showSidebar,
      _ref$Avatar = _ref.Avatar,
      Avatar$1 = _ref$Avatar === void 0 ? Avatar : _ref$Avatar,
      _ref$LoadingErrorIndi = _ref.LoadingErrorIndicator,
      LoadingErrorIndicator = _ref$LoadingErrorIndi === void 0 ? ChatDown$1 : _ref$LoadingErrorIndi,
      _ref$LoadingIndicator = _ref.LoadingIndicator,
      LoadingIndicator = _ref$LoadingIndicator === void 0 ? LoadingChannels$1 : _ref$LoadingIndicator,
      children = _ref.children;

  var _useContext = React.useContext(ChatContext),
      client = _useContext.client;

  var _ref2 = client.user || {},
      id = _ref2.id,
      image = _ref2.image,
      name = _ref2.name,
      status = _ref2.status;

  if (error) {
    return /*#__PURE__*/React__default['default'].createElement(LoadingErrorIndicator, {
      type: "Connection Error"
    });
  }

  if (loading) {
    return /*#__PURE__*/React__default['default'].createElement(LoadingIndicator, null);
  }

  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__channel-list-team"
  }, showSidebar && /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__channel-list-team__sidebar"
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__channel-list-team__sidebar--top"
  }, /*#__PURE__*/React__default['default'].createElement(Avatar$1, {
    image: sidebarImage,
    size: 50
  }))), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__channel-list-team__main"
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__channel-list-team__header"
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__channel-list-team__header--left"
  }, /*#__PURE__*/React__default['default'].createElement(Avatar$1, {
    image: image,
    name: name || id,
    size: 40
  })), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__channel-list-team__header--middle"
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__channel-list-team__header--title"
  }, name || id), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__channel-list-team__header--status ".concat(status)
  }, status)), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__channel-list-team__header--right"
  }, /*#__PURE__*/React__default['default'].createElement("button", {
    className: "str-chat__channel-list-team__header--button"
  }, /*#__PURE__*/React__default['default'].createElement("img", {
    src: chevrondown
  })))), children));
};

ChannelListTeam.propTypes = {
  /** When true, loading indicator is shown - [LoadingChannels](https://github.com/GetStream/stream-chat-react/blob/master/src/components/LoadingChannels.js) */
  loading: PropTypes__default['default'].bool,

  /** When true, error indicator is shown - [ChatDown](https://github.com/GetStream/stream-chat-react/blob/master/src/components/ChatDown.js) */
  error: PropTypes__default['default'].bool,

  /** When true, sidebar containing logo of the team is visible */
  showSidebar: PropTypes__default['default'].bool,

  /** Url for sidebar logo image. */
  sidebarImage: PropTypes__default['default'].string,

  /**
   * Custom UI component to display user avatar
   *
   * Defaults to and accepts same props as: [Avatar](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Avatar/Avatar.js)
   * */
  Avatar:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').AvatarProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * Loading indicator UI Component. It will be displayed if `loading` prop is true.
   *
   * Defaults to and accepts same props as:
   * [LoadingChannels](https://github.com/GetStream/stream-chat-react/blob/master/src/components/LoadingChannels.js)
   *
   */
  LoadingIndicator:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').LoadingIndicatorProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * Error indicator UI Component. It will be displayed if `error` prop is true
   *
   * Defaults to and accepts same props as:
   * [ChatDown](https://github.com/GetStream/stream-chat-react/blob/master/src/components/ChatDown.js)
   *
   */
  LoadingErrorIndicator:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').ChatDownProps>>} */
  PropTypes__default['default'].elementType
};

// @ts-check
/**
 * @type {React.FC<import('../types').LoadMoreButtonProps>}
 */

var LoadMoreButton = function LoadMoreButton(_ref) {
  var onClick = _ref.onClick,
      refreshing = _ref.refreshing,
      _ref$children = _ref.children,
      children = _ref$children === void 0 ? 'Load more' : _ref$children;
  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__load-more-button"
  }, /*#__PURE__*/React__default['default'].createElement("button", {
    className: "str-chat__load-more-button__button",
    onClick: onClick,
    "data-testid": "load-more-button",
    disabled: refreshing
  }, refreshing ? /*#__PURE__*/React__default['default'].createElement(reactFileUtils.LoadingIndicator, null) : children));
};

LoadMoreButton.propTypes = {
  /** onClick handler load more button. Pagination logic should be executed in this handler. */
  onClick: PropTypes__default['default'].func.isRequired,

  /** If true, LoadingIndicator is displayed instead of button */
  refreshing: PropTypes__default['default'].bool.isRequired
};
var DefaultLoadMoreButton = /*#__PURE__*/React__default['default'].memo(LoadMoreButton);

var LoadMorePaginator = function LoadMorePaginator(_ref) {
  var reverse = _ref.reverse,
      hasNextPage = _ref.hasNextPage,
      refreshing = _ref.refreshing,
      loadNextPage = _ref.loadNextPage,
      LoadMoreButton = _ref.LoadMoreButton,
      children = _ref.children;
  return /*#__PURE__*/React__default['default'].createElement(React__default['default'].Fragment, null, !reverse && children, hasNextPage && smartRender(LoadMoreButton, {
    refreshing,
    onClick: loadNextPage
  }), reverse && children);
};

LoadMorePaginator.defaultProps = {
  LoadMoreButton: DefaultLoadMoreButton
};
LoadMorePaginator.propTypes = {
  LoadMoreButton: PropTypes__default['default'].oneOfType([PropTypes__default['default'].node, PropTypes__default['default'].func, PropTypes__default['default'].object]),

  /** callback to load the next page */
  loadNextPage: PropTypes__default['default'].func,

  /** indicates if there is a next page to load */
  hasNextPage: PropTypes__default['default'].bool,

  /** display the items in opposite order */
  reverse: PropTypes__default['default'].bool
};
var LoadMorePaginator$1 = /*#__PURE__*/React__default['default'].memo(LoadMorePaginator);

// @ts-check
/**
 * @type {React.FC<import('../types').EmptyStateIndicatorProps>} param0
 */

var EmptyStateIndicator = function EmptyStateIndicator(_ref) {
  var listType = _ref.listType;

  var _useContext = React.useContext(TranslationContext),
      t = _useContext.t;

  if (listType === 'channel') return /*#__PURE__*/React__default['default'].createElement("p", null, t('You have no channels currently'));
  if (listType === 'message') return null;
  return /*#__PURE__*/React__default['default'].createElement("p", null, "No items exist");
};

EmptyStateIndicator.propTypes = {
  /** channel | message */
  listType: PropTypes__default['default'].string.isRequired
};
var DefaultEmptyStateIndicator = /*#__PURE__*/React__default['default'].memo(EmptyStateIndicator);

// @ts-check

/**
 * @param {string | undefined} cid
 * @param {import('stream-chat').Channel[]} channels
 */
var moveChannelUp = function moveChannelUp(cid, channels) {
  // get channel index
  var channelIndex = channels.findIndex(function (channel) {
    return channel.cid === cid;
  });
  if (channelIndex <= 0) return channels; // get channel from channels

  var channel = channels[channelIndex]; // remove channel from current position

  channels.splice(channelIndex, 1); // add channel at the start

  channels.unshift(channel);
  return _toConsumableArray__default['default'](channels);
};
/**
 * @param {import('../types').StreamChatReactClient} client
 * @param {string} type
 * @param {string} id
 */

var getChannel = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(client, type, id) {
    var channel;
    return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            channel = client.channel(type, id);
            _context.next = 3;
            return channel.watch();

          case 3:
            return _context.abrupt("return", channel);

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function getChannel(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
}();
var MAX_QUERY_CHANNELS_LIMIT = 30;

/**
 * @typedef {React.Dispatch<React.SetStateAction<import('stream-chat').Channel[]>>} SetChannels
 * @param {SetChannels} setChannels
 * @param {boolean} [lockChannelOrder]
 */

var useMessageNewListener = function useMessageNewListener(setChannels) {
  var lockChannelOrder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var allowNewMessagesFromUnfilteredChannels = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

  var _useContext = React.useContext(ChatContext),
      client = _useContext.client;

  React.useEffect(function () {
    /** @param {import('stream-chat').Event} e */
    var handleEvent = function handleEvent(e) {
      setChannels(function (channels) {
        var channelInList = channels.filter(function (c) {
          return c.cid === e.cid;
        }).length > 0;

        if (!channelInList && allowNewMessagesFromUnfilteredChannels) {
          // @ts-ignore
          var channel = client.channel(e.channel_type, e.channel_id);
          return uniqBy__default['default']([channel].concat(_toConsumableArray__default['default'](channels)), 'cid');
        }

        if (!lockChannelOrder) return moveChannelUp(e.cid, channels);
        return channels;
      });
    };

    client.on('message.new', handleEvent);
    return function () {
      client.off('message.new', handleEvent);
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [lockChannelOrder]);
};

/**
 * @typedef {import('stream-chat').Event} NotificationAddedToChannelEvent
 * @typedef {React.Dispatch<React.SetStateAction<import('stream-chat').Channel[]>>} SetChannels
 * @param {SetChannels} setChannels
 * @param {(setChannels: SetChannels, event: NotificationAddedToChannelEvent) => void} [customHandler]
 */

var useNotificationMessageNewListener = function useNotificationMessageNewListener(setChannels, customHandler) {
  var _useContext = React.useContext(ChatContext),
      client = _useContext.client;

  React.useEffect(function () {
    /** @param {import('stream-chat').Event} e */
    var handleEvent = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(e) {
        var _e$channel;

        var channel;
        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(customHandler && typeof customHandler === 'function')) {
                  _context.next = 4;
                  break;
                }

                customHandler(setChannels, e);
                _context.next = 9;
                break;

              case 4:
                if (!((_e$channel = e.channel) !== null && _e$channel !== void 0 && _e$channel.type)) {
                  _context.next = 9;
                  break;
                }

                _context.next = 7;
                return getChannel(client, e.channel.type, e.channel.id);

              case 7:
                channel = _context.sent;
                // move channel to starting position
                setChannels(function (channels) {
                  return uniqBy__default['default']([channel].concat(_toConsumableArray__default['default'](channels)), 'cid');
                });

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function handleEvent(_x) {
        return _ref.apply(this, arguments);
      };
    }();

    client.on('notification.message_new', handleEvent);
    return function () {
      client.off('notification.message_new', handleEvent);
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [customHandler]);
};

/**
 * @typedef {import('stream-chat').Event} NotificationAddedToChannelEvent
 * @typedef {React.Dispatch<React.SetStateAction<import('stream-chat').Channel[]>>} SetChannels
 * @param {SetChannels} setChannels
 * @param {(setChannels: SetChannels, event: NotificationAddedToChannelEvent) => void} [customHandler]
 */

var useNotificationAddedToChannelListener = function useNotificationAddedToChannelListener(setChannels, customHandler) {
  var _useContext = React.useContext(ChatContext),
      client = _useContext.client;

  React.useEffect(function () {
    /** @param {import('stream-chat').Event} e */
    var handleEvent = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(e) {
        var _e$channel;

        var channel;
        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(customHandler && typeof customHandler === 'function')) {
                  _context.next = 4;
                  break;
                }

                customHandler(setChannels, e);
                _context.next = 9;
                break;

              case 4:
                if (!((_e$channel = e.channel) !== null && _e$channel !== void 0 && _e$channel.type)) {
                  _context.next = 9;
                  break;
                }

                _context.next = 7;
                return getChannel(client, e.channel.type, e.channel.id);

              case 7:
                channel = _context.sent;
                setChannels(function (channels) {
                  return uniqBy__default['default']([channel].concat(_toConsumableArray__default['default'](channels)), 'cid');
                });

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function handleEvent(_x) {
        return _ref.apply(this, arguments);
      };
    }();

    client.on('notification.added_to_channel', handleEvent);
    return function () {
      client.off('notification.added_to_channel', handleEvent);
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [customHandler]);
};

// @ts-check
/**
 * @typedef {import('stream-chat').Event} NotificationAddedToChannelEvent
 * @typedef {React.Dispatch<React.SetStateAction<import('stream-chat').Channel[]>>} SetChannels
 * @param {SetChannels} setChannels
 * @param {(setChannels: SetChannels, event: NotificationAddedToChannelEvent) => void} [customHandler]
 */

var useNotificationRemovedFromChannelListener = function useNotificationRemovedFromChannelListener(setChannels, customHandler) {
  var _useContext = React.useContext(ChatContext),
      client = _useContext.client;

  React.useEffect(function () {
    /** @param {import('stream-chat').Event} e */
    var handleEvent = function handleEvent(e) {
      if (customHandler && typeof customHandler === 'function') {
        customHandler(setChannels, e);
      } else {
        setChannels(function (channels) {
          return channels.filter(function (channel) {
            var _e$channel;

            return channel.cid !== ((_e$channel = e.channel) === null || _e$channel === void 0 ? void 0 : _e$channel.cid);
          });
        });
      }
    };

    client.on('notification.removed_from_channel', handleEvent);
    return function () {
      client.off('notification.removed_from_channel', handleEvent);
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [customHandler]);
};

/**
 * @typedef {import('stream-chat').Event} ChannelDeletedEvent
 * @typedef {React.Dispatch<React.SetStateAction<import('stream-chat').Channel[]>>} SetChannels
 * @param {SetChannels} setChannels
 * @param {(setChannels: SetChannels, event: ChannelDeletedEvent) => void} [customHandler]
 */

var useChannelDeletedListener = function useChannelDeletedListener(setChannels, customHandler) {
  var _useContext = React.useContext(ChatContext),
      client = _useContext.client;

  React.useEffect(function () {
    /** @param {import('stream-chat').Event} e */
    var handleEvent = function handleEvent(e) {
      if (customHandler && typeof customHandler === 'function') {
        customHandler(setChannels, e);
      } else {
        setChannels(function (channels) {
          var channelIndex = channels.findIndex(function (channel) {
            return channel.cid === (e === null || e === void 0 ? void 0 : e.cid);
          });
          if (channelIndex < 0) return _toConsumableArray__default['default'](channels); // Remove the deleted channel from the list.s

          channels.splice(channelIndex, 1); // eslint-disable-next-line consistent-return

          return _toConsumableArray__default['default'](channels);
        });
      }
    };

    client.on('channel.deleted', handleEvent);
    return function () {
      client.off('channel.deleted', handleEvent);
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [customHandler]);
};

/**
 * @typedef {import('stream-chat').Event} ChannelTruncatedEvent
 * @typedef {React.Dispatch<React.SetStateAction<import('stream-chat').Channel[]>>} SetChannels
 * @param {SetChannels} setChannels
 * @param {(setChannels: SetChannels, event: ChannelTruncatedEvent) => void} [customHandler]
 * @param {() => void} [forceUpdate]
 */

var useChannelTruncatedListener = function useChannelTruncatedListener(setChannels, customHandler, forceUpdate) {
  var _useContext = React.useContext(ChatContext),
      client = _useContext.client;

  React.useEffect(function () {
    /** @param {import('stream-chat').Event} e */
    var handleEvent = function handleEvent(e) {
      setChannels(function (channels) {
        return _toConsumableArray__default['default'](channels);
      });

      if (customHandler && typeof customHandler === 'function') {
        customHandler(setChannels, e);
      }

      if (forceUpdate) {
        forceUpdate();
      }
    };

    client.on('channel.truncated', handleEvent);
    return function () {
      client.off('channel.truncated', handleEvent);
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [customHandler]);
};

/**
 * @typedef {import('stream-chat').Event} ChannelUpdatedEvent
 * @typedef {React.Dispatch<React.SetStateAction<import('stream-chat').Channel[]>>} SetChannels
 * @param {SetChannels} setChannels
 * @param {(setChannels: SetChannels, event: ChannelUpdatedEvent) => void} [customHandler]
 * @param {() => void} [forceUpdate]
 */

var useChannelUpdatedListener = function useChannelUpdatedListener(setChannels, customHandler, forceUpdate) {
  var _useContext = React.useContext(ChatContext),
      client = _useContext.client;

  React.useEffect(function () {
    /** @param {import('stream-chat').Event} e */
    var handleEvent = function handleEvent(e) {
      setChannels(function (channels) {
        var channelIndex = channels.findIndex(function (channel) {
          var _e$channel;

          return channel.cid === ((_e$channel = e.channel) === null || _e$channel === void 0 ? void 0 : _e$channel.cid);
        });

        if (channelIndex > -1 && e.channel) {
          var newChannels = channels;
          newChannels[channelIndex].data = e.channel;
          return _toConsumableArray__default['default'](newChannels);
        }

        return channels;
      });

      if (forceUpdate) {
        forceUpdate();
      }

      if (customHandler && typeof customHandler === 'function') {
        customHandler(setChannels, e);
      }
    };

    client.on('channel.updated', handleEvent);
    return function () {
      client.off('channel.updated', handleEvent);
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [customHandler]);
};

/**
 * @typedef {import('stream-chat').Event} ChannelHiddenEvent
 * @typedef {React.Dispatch<React.SetStateAction<import('stream-chat').Channel[]>>} SetChannels
 * @param {SetChannels} setChannels
 * @param {(setChannels: SetChannels, event: ChannelHiddenEvent) => void} [customHandler]
 */

var useChannelHiddenListener = function useChannelHiddenListener(setChannels, customHandler) {
  var _useContext = React.useContext(ChatContext),
      client = _useContext.client;

  React.useEffect(function () {
    /** @param {import('stream-chat').Event} e */
    var handleEvent = function handleEvent(e) {
      if (customHandler && typeof customHandler === 'function') {
        customHandler(setChannels, e);
      } else {
        setChannels(function (channels) {
          var channelIndex = channels.findIndex(function (channel) {
            return channel.cid === (e === null || e === void 0 ? void 0 : e.cid);
          });
          if (channelIndex < 0) return _toConsumableArray__default['default'](channels); // Remove the hidden channel from the list.s

          channels.splice(channelIndex, 1); // eslint-disable-next-line consistent-return

          return _toConsumableArray__default['default'](channels);
        });
      }
    };

    client.on('channel.hidden', handleEvent);
    return function () {
      client.off('channel.hidden', handleEvent);
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [customHandler]);
};

/**
 * @typedef {import('stream-chat').Event} ChannelVisibleEvent
 * @typedef {React.Dispatch<React.SetStateAction<import('stream-chat').Channel[]>>} SetChannels
 * @param {SetChannels} setChannels
 * @param {(setChannels: SetChannels, event: ChannelVisibleEvent) => void} [customHandler]
 */

var useChannelVisibleListener = function useChannelVisibleListener(setChannels, customHandler) {
  var _useContext = React.useContext(ChatContext),
      client = _useContext.client;

  React.useEffect(function () {
    /** @param {import('stream-chat').Event} e */
    var handleEvent = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(e) {
        var channel;
        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(customHandler && typeof customHandler === 'function')) {
                  _context.next = 4;
                  break;
                }

                customHandler(setChannels, e);
                _context.next = 9;
                break;

              case 4:
                if (!(e !== null && e !== void 0 && e.type && e.channel_type && e.channel_id)) {
                  _context.next = 9;
                  break;
                }

                _context.next = 7;
                return getChannel(client, e.channel_type, e.channel_id);

              case 7:
                channel = _context.sent;
                setChannels(function (channels) {
                  return uniqBy__default['default']([channel].concat(_toConsumableArray__default['default'](channels)), 'cid');
                });

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function handleEvent(_x) {
        return _ref.apply(this, arguments);
      };
    }();

    client.on('channel.visible', handleEvent);
    return function () {
      client.off('channel.visible', handleEvent);
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [customHandler]);
};

// @ts-check
/**
 * @param {() => void} [forceUpdate]
 */

var useConnectionRecoveredListener = function useConnectionRecoveredListener(forceUpdate) {
  var _useContext = React.useContext(ChatContext),
      client = _useContext.client;

  React.useEffect(function () {
    var handleEvent = function handleEvent() {
      if (forceUpdate) {
        forceUpdate();
      }
    };

    client.on('connection.recovered', handleEvent);
    return function () {
      client.off('connection.recovered', handleEvent);
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
};

/**
 * @typedef {React.Dispatch<React.SetStateAction<import('stream-chat').Channel[]>>} SetChannels
 * @param {SetChannels} setChannels
 */

var useUserPresenceChangedListener = function useUserPresenceChangedListener(setChannels) {
  var _useContext = React.useContext(ChatContext),
      client = _useContext.client;

  React.useEffect(function () {
    /** @param {import('stream-chat').Event} e */
    var handleEvent = function handleEvent(e) {
      setChannels(function (channels) {
        var newChannels = channels.map(function (channel) {
          var _e$user;

          if (!((_e$user = e.user) !== null && _e$user !== void 0 && _e$user.id) || !channel.state.members[e.user.id]) return channel;
          channel.state.members.setIn([e.user.id, 'user'], e.user);
          return channel;
        });
        return _toConsumableArray__default['default'](newChannels);
      });
    };

    client.on('user.presence.changed', handleEvent);
    return function () {
      client.off('user.presence.changed', handleEvent);
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
};

function ownKeys$9(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$9(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$9(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$9(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
/**
 * @typedef {import('stream-chat').Channel} Channel
 * @param {import('../types').StreamChatReactClient} client
 * @param {import('stream-chat').ChannelFilters} filters
 * @param {import('stream-chat').ChannelSort} [sort]
 * @param {import('stream-chat').ChannelOptions} [options]
 * @param {(channels: Channel[], setChannels: React.Dispatch<React.SetStateAction<Channel[]>>) => void} [activeChannelHandler]
 */

var usePaginatedChannels = function usePaginatedChannels(client, filters, sort, options, activeChannelHandler) {
  var _useState = React.useState(
  /** @type {Channel[]} */
  []),
      _useState2 = _slicedToArray__default['default'](_useState, 2),
      channels = _useState2[0],
      setChannels = _useState2[1];

  var _useState3 = React.useState(true),
      _useState4 = _slicedToArray__default['default'](_useState3, 2),
      loadingChannels = _useState4[0],
      setLoadingChannels = _useState4[1];

  var _useState5 = React.useState(true),
      _useState6 = _slicedToArray__default['default'](_useState5, 2),
      refreshing = _useState6[0],
      setRefreshing = _useState6[1];

  var _useState7 = React.useState(0),
      _useState8 = _slicedToArray__default['default'](_useState7, 2),
      offset = _useState8[0],
      setOffset = _useState8[1];

  var _useState9 = React.useState(false),
      _useState10 = _slicedToArray__default['default'](_useState9, 2),
      error = _useState10[0],
      setError = _useState10[1];

  var _useState11 = React.useState(true),
      _useState12 = _slicedToArray__default['default'](_useState11, 2),
      hasNextPage = _useState12[0],
      setHasNextPage = _useState12[1];
  /**
   * @param {string} [queryType]
   */


  var queryChannels = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(queryType) {
      var _options$limit;

      var newOptions, channelQueryResponse, newChannels;
      return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (queryType === 'reload') {
                setChannels([]);
                setLoadingChannels(true);
              }

              setRefreshing(true);
              newOptions = _objectSpread$9(_objectSpread$9({
                offset: queryType === 'reload' ? 0 : offset
              }, options), {}, {
                limit: (_options$limit = options === null || options === void 0 ? void 0 : options.limit) !== null && _options$limit !== void 0 ? _options$limit : MAX_QUERY_CHANNELS_LIMIT
              });
              _context.prev = 3;
              _context.next = 6;
              return client.queryChannels(filters, sort || {}, newOptions);

            case 6:
              channelQueryResponse = _context.sent;

              if (queryType === 'reload') {
                newChannels = channelQueryResponse;
              } else {
                newChannels = [].concat(_toConsumableArray__default['default'](channels), _toConsumableArray__default['default'](channelQueryResponse));
              }

              setChannels(newChannels);
              setHasNextPage(channelQueryResponse.length >= newOptions.limit); // Set active channel only after first page.

              if (offset === 0 && activeChannelHandler) {
                activeChannelHandler(newChannels, setChannels);
              }

              setOffset(newChannels.length);
              _context.next = 18;
              break;

            case 14:
              _context.prev = 14;
              _context.t0 = _context["catch"](3);
              console.warn(_context.t0);
              setError(true);

            case 18:
              setLoadingChannels(false);
              setRefreshing(false);

            case 20:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[3, 14]]);
    }));

    return function queryChannels(_x) {
      return _ref.apply(this, arguments);
    };
  }();

  var loadNextPage = function loadNextPage() {
    queryChannels();
  };

  React.useEffect(function () {
    queryChannels('reload'); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [filters]);
  return {
    channels,
    loadNextPage,
    hasNextPage,
    status: {
      loadingChannels,
      refreshing,
      error
    },
    setChannels
  };
};

// @ts-check
/**
 * @param {React.MutableRefObject<HTMLDivElement | null>} channelListRef
 * @param {boolean} navOpen
 * @param {() => void} [closeMobileNav]
 */

var useMobileNavigation = function useMobileNavigation(channelListRef, navOpen, closeMobileNav) {
  React.useEffect(function () {
    /** @param {MouseEvent} e */
    var handleClickOutside = function handleClickOutside(e) {
      if (closeMobileNav && channelListRef.current && !channelListRef.current.contains(
      /** @type {Node | null} */
      e.target) && navOpen) {
        closeMobileNav();
      }
    };

    document.addEventListener('click', handleClickOutside);
    return function () {
      document.removeEventListener('click', handleClickOutside);
    };
  }, [navOpen, channelListRef, closeMobileNav]);
};

function ownKeys$a(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$a(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$a(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$a(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var DEFAULT_FILTERS = {};
var DEFAULT_OPTIONS = {};
var DEFAULT_SORT = {};
/**
 * ChannelList - A preview list of channels, allowing you to select the channel you want to open
 * @example ../../docs/ChannelList.md
 * @type {React.FC<import('../types').ChannelListProps>}
 */

var ChannelList = function ChannelList(props) {
  var _useContext = React.useContext(ChatContext),
      client = _useContext.client,
      setActiveChannel = _useContext.setActiveChannel,
      _useContext$navOpen = _useContext.navOpen,
      navOpen = _useContext$navOpen === void 0 ? false : _useContext$navOpen,
      closeMobileNav = _useContext.closeMobileNav,
      channel = _useContext.channel,
      theme = _useContext.theme;

  var channelListRef = React.useRef(
  /** @type {HTMLDivElement | null} */
  null);

  var _useState = React.useState(0),
      _useState2 = _slicedToArray__default['default'](_useState, 2),
      channelUpdateCount = _useState2[0],
      setChannelUpdateCount = _useState2[1];
  /**
   * Set a channel with id {customActiveChannel} as active and move it to the top of the list.
   * If customActiveChannel prop is absent, then set the first channel in list as active channel.
   * @param {import('stream-chat').Channel[]} channels
   * @param {React.Dispatch<React.SetStateAction<import('stream-chat').Channel[]>>} setChannels
   */


  var activeChannelHandler = function activeChannelHandler(channels, setChannels) {
    var _props$setActiveChann = props.setActiveChannelOnMount,
        setActiveChannelOnMount = _props$setActiveChann === void 0 ? true : _props$setActiveChann,
        customActiveChannel = props.customActiveChannel,
        watchers = props.watchers,
        _props$options = props.options,
        options = _props$options === void 0 ? {} : _props$options;

    if (!channels || channels.length === 0 || channels.length > (options.limit || MAX_QUERY_CHANNELS_LIMIT)) {
      return;
    }

    if (customActiveChannel) {
      var customActiveChannelObject = channels.find(function (chan) {
        return chan.id === customActiveChannel;
      });

      if (customActiveChannelObject) {
        if (setActiveChannel) {
          setActiveChannel(customActiveChannelObject, watchers);
        }

        var newChannels = moveChannelUp(customActiveChannelObject.cid, channels);
        setChannels(newChannels);
      }

      return;
    }

    if (setActiveChannelOnMount && setActiveChannel) {
      setActiveChannel(channels[0], watchers);
    }
  }; // When channel list (channels array) is updated without any shallow changes (or with only deep changes), then we want
  // to force the channel preview to re-render.
  // This happens in case of event channel.updated, channel.truncated etc. Inner properties of channel is updated but
  // react renderer will only make shallow comparison and choose to not to re-render the UI.
  // By updating the dummy prop - channelUpdateCount, we can force this re-render.


  var forceUpdate = function forceUpdate() {
    setChannelUpdateCount(function (count) {
      return count + 1;
    });
  };

  var _usePaginatedChannels = usePaginatedChannels(client, props.filters || DEFAULT_FILTERS, props.sort || DEFAULT_SORT, props.options || DEFAULT_OPTIONS, activeChannelHandler),
      channels = _usePaginatedChannels.channels,
      loadNextPage = _usePaginatedChannels.loadNextPage,
      hasNextPage = _usePaginatedChannels.hasNextPage,
      status = _usePaginatedChannels.status,
      setChannels = _usePaginatedChannels.setChannels;

  var loadedChannels = props.channelRenderFilterFn ? props.channelRenderFilterFn(channels) : channels;
  useMobileNavigation(channelListRef, navOpen, closeMobileNav); // All the event listeners

  useMessageNewListener(setChannels, props.lockChannelOrder, props.allowNewMessagesFromUnfilteredChannels);
  useNotificationMessageNewListener(setChannels, props.onMessageNew);
  useNotificationAddedToChannelListener(setChannels, props.onAddedToChannel);
  useNotificationRemovedFromChannelListener(setChannels, props.onRemovedFromChannel);
  useChannelDeletedListener(setChannels, props.onChannelDeleted);
  useChannelHiddenListener(setChannels, props.onChannelHidden);
  useChannelVisibleListener(setChannels, props.onChannelVisible);
  useChannelTruncatedListener(setChannels, props.onChannelTruncated, forceUpdate);
  useChannelUpdatedListener(setChannels, props.onChannelUpdated, forceUpdate);
  useConnectionRecoveredListener(forceUpdate);
  useUserPresenceChangedListener(setChannels); // If the active channel is deleted, then unset the active channel.

  React.useEffect(function () {
    /** @param {import('stream-chat').Event} e */
    var handleEvent = function handleEvent(e) {
      if (setActiveChannel && (e === null || e === void 0 ? void 0 : e.cid) === (channel === null || channel === void 0 ? void 0 : channel.cid)) {
        setActiveChannel();
      }
    };

    client.on('channel.deleted', handleEvent);
    client.on('channel.hidden', handleEvent);
    return function () {
      client.off('channel.deleted', handleEvent);
      client.off('channel.hidden', handleEvent);
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [channel]); // renders the channel preview or item

  /** @param {import('stream-chat').Channel} item */

  var renderChannel = function renderChannel(item) {
    if (!item) return null;
    var _props$Avatar = props.Avatar,
        Avatar$1 = _props$Avatar === void 0 ? Avatar : _props$Avatar,
        _props$Preview = props.Preview,
        Preview = _props$Preview === void 0 ? ChannelPreviewLastMessage$1 : _props$Preview,
        _props$watchers = props.watchers,
        watchers = _props$watchers === void 0 ? {} : _props$watchers;
    var previewProps = {
      Avatar: Avatar$1,
      channel: item,
      Preview,
      activeChannel: channel,
      setActiveChannel,
      watchers,
      key: item.id,
      // To force the update of preview component upon channel update.
      channelUpdateCount
    };
    return smartRender(ChannelPreview, _objectSpread$a({}, previewProps));
  }; // renders the empty state indicator (when there are no channels)


  var renderEmptyStateIndicator = function renderEmptyStateIndicator() {
    var _props$EmptyStateIndi = props.EmptyStateIndicator,
        EmptyStateIndicator = _props$EmptyStateIndi === void 0 ? DefaultEmptyStateIndicator : _props$EmptyStateIndi;
    return /*#__PURE__*/React__default['default'].createElement(EmptyStateIndicator, {
      listType: "channel"
    });
  }; // renders the list.


  var renderList = function renderList() {
    var _props$Avatar2 = props.Avatar,
        Avatar$1 = _props$Avatar2 === void 0 ? Avatar : _props$Avatar2,
        _props$List = props.List,
        List = _props$List === void 0 ? ChannelListTeam : _props$List,
        _props$Paginator = props.Paginator,
        Paginator = _props$Paginator === void 0 ? LoadMorePaginator$1 : _props$Paginator,
        showSidebar = props.showSidebar,
        _props$LoadingIndicat = props.LoadingIndicator,
        LoadingIndicator = _props$LoadingIndicat === void 0 ? LoadingChannels$1 : _props$LoadingIndicat,
        _props$LoadingErrorIn = props.LoadingErrorIndicator,
        LoadingErrorIndicator = _props$LoadingErrorIn === void 0 ? ChatDown$1 : _props$LoadingErrorIn;
    return /*#__PURE__*/React__default['default'].createElement(List, {
      loading: status.loadingChannels,
      error: status.error,
      showSidebar: showSidebar,
      Avatar: Avatar$1,
      LoadingIndicator: LoadingIndicator,
      LoadingErrorIndicator: LoadingErrorIndicator
    }, !loadedChannels || loadedChannels.length === 0 ? renderEmptyStateIndicator() : smartRender(Paginator, {
      loadNextPage,
      hasNextPage,
      refreshing: status.refreshing,
      children: loadedChannels.map(renderChannel)
    }));
  };

  return /*#__PURE__*/React__default['default'].createElement(React__default['default'].Fragment, null, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat str-chat-channel-list ".concat(theme, " ").concat(navOpen ? 'str-chat-channel-list--open' : ''),
    ref: channelListRef
  }, renderList()));
};

ChannelList.propTypes = {
  /**
   * Custom UI component to display user avatar
   *
   * Defaults to and accepts same props as: [Avatar](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Avatar/Avatar.js)
   * */
  Avatar:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').AvatarProps>>} */
  PropTypes__default['default'].elementType,

  /** Indicator for Empty State */
  EmptyStateIndicator:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').EmptyStateIndicatorProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * Available built-in options (also accepts the same props as):
   *
   * 1. [ChannelPreviewCompact](https://getstream.github.io/stream-chat-react/#ChannelPreviewCompact) (default)
   * 2. [ChannelPreviewLastMessage](https://getstream.github.io/stream-chat-react/#ChannelPreviewLastMessage)
   * 3. [ChannelPreviewMessanger](https://getstream.github.io/stream-chat-react/#ChannelPreviewMessanger)
   *
   * The Preview to use, defaults to ChannelPreviewLastMessage
   * */
  Preview:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').ChannelPreviewUIComponentProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * Loading indicator UI Component. It will be displayed until the channels are
   * being queried from API. Once the channels are loaded/queried, loading indicator is removed
   * and replaced with children of the Channel component.
   *
   * Defaults to and accepts same props as:
   * [LoadingChannels](https://github.com/GetStream/stream-chat-react/blob/master/src/components/LoadingChannels.js)
   *
   */
  LoadingIndicator:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').LoadingIndicatorProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * Error indicator UI Component. It will be displayed if there is any error if loading the channels.
   * This error could be related to network or failing API.
   *
   * Defaults to and accepts same props as:
   * [ChatDown](https://github.com/GetStream/stream-chat-react/blob/master/src/components/ChatDown.js)
   *
   */
  LoadingErrorIndicator:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').ChatDownProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * Custom UI Component for container of list of channels. Note that, list (UI component) of channels is passed
   * to this component as children. This component is for the purpose of adding header to channel list or styling container
   * for list of channels.
   *
   * Available built-in options (also accepts the same props as):
   *
   * 1. [ChannelListTeam](https://github.com/GetStream/stream-chat-react/blob/master/src/components/ChannelListTeam.js) (default)
   * 2. [ChannelListMessenger](https://github.com/GetStream/stream-chat-react/blob/master/src/components/ChannelListMessenger.js)
   *
   * It has access to some additional props:
   *
   * - `setActiveChannel` {function} Check [chat context](https://getstream.github.io/stream-chat-react/#chat)
   * - `activeChannel` Currently active channel object
   * - `channels` {array} List of channels in channel list
   */
  List:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').ChannelListUIComponentProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * Paginator component for channels. It contains all the pagination logic such as
   * - fetching next page of results when needed e.g., when scroll reaches the end of list
   * - UI to display loading indicator when next page is being loaded
   * - call to action button to trigger loading of next page.
   *
   * Available built-in options (also accepts the same props as):
   *
   * 1. [LoadMorePaginator](https://github.com/GetStream/stream-chat-react/blob/master/src/components/LoadMorePaginator.js)
   * 2. [InfiniteScrollPaginator](https://github.com/GetStream/stream-chat-react/blob/master/src/components/InfiniteScrollPaginator.js)
   */
  Paginator:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').PaginatorProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * Function that overrides default behaviour when new message is received on channel that is not being watched
   *
   * @param {Component} setChannels Setter for channels value in state.
   * @param {Event}     event       [Event object](https://getstream.io/chat/docs/event_object/?language=js) corresponding to `notification.message_new` event
   * */
  onMessageNew: PropTypes__default['default'].func,

  /**
   * Function that overrides default behaviour when users gets added to a channel
   *
   * @param {Component} setChannels Setter for channels value in state.
   * @param {Event}     event       [Event object](https://getstream.io/chat/docs/event_object/?language=js) corresponding to `notification.added_to_channel` event
   * */
  onAddedToChannel: PropTypes__default['default'].func,

  /**
   * Function that overrides default behaviour when users gets removed from a channel
   *
   * @param {Component} setChannels Setter for channels value in state.
   * @param {Event}     event       [Event object](https://getstream.io/chat/docs/event_object/?language=js) corresponding to `notification.removed_from_channel` event
   * */
  onRemovedFromChannel: PropTypes__default['default'].func,

  /**
   * Function that overrides default behaviour when channel gets updated
   *
   * @param {Component} setChannels Setter for channels value in state.
   * @param {Event}     event       [Event object](https://getstream.io/chat/docs/event_object/?language=js) corresponding to `notification.channel_updated` event
   * */
  onChannelUpdated: PropTypes__default['default'].func,

  /**
   * Function to customize behaviour when channel gets truncated
   *
   * @param {Component} setChannels Setter for channels value in state.
   * @param {Event}     event       [Event object](https://getstream.io/chat/docs/event_object/?language=js) corresponding to `channel.truncated` event
   * */
  onChannelTruncated: PropTypes__default['default'].func,

  /**
   * Function that overrides default behaviour when channel gets deleted. In absence of this prop, channel will be removed from the list.
   *
   * @param {Component} setChannels Setter for channels value in state.
   * @param {Event}     event       [Event object](https://getstream.io/chat/docs/event_object/?language=js) corresponding to `channel.deleted` event
   * */
  onChannelDeleted: PropTypes__default['default'].func,

  /**
   * Optional function to filter channels prior to loading in the DOM. Do not use any complex or async logic here that would significantly delay the loading of the ChannelList.
   * We recommend using a pure function with array methods like filter/sort/reduce.
   * @param {Array} channels
   * @returns {Array} channels
   * */
  channelRenderFilterFn:
  /** @type {PropTypes.Validator<(channels: import('stream-chat').Channel[]) => import('stream-chat').Channel[]>} */
  PropTypes__default['default'].func,

  /**
   * Object containing query filters
   * @see See [Channel query documentation](https://getstream.io/chat/docs/query_channels/?language=js) for a list of available fields for filter.
   * */
  filters:
  /** @type {PropTypes.Validator<import('stream-chat').ChannelFilters>} */
  PropTypes__default['default'].object,

  /**
   * Object containing query options
   * @see See [Channel query documentation](https://getstream.io/chat/docs/query_channels/?language=js) for a list of available fields for options.
   * */
  options: PropTypes__default['default'].object,

  /**
   * Object containing sort parameters
   * @see See [Channel query documentation](https://getstream.io/chat/docs/query_channels/?language=js) for a list of available fields for sort.
   * */
  sort:
  /** @type {PropTypes.Validator<import('stream-chat').ChannelSort>} */
  PropTypes__default['default'].object,

  /**
   * Object containing watcher parameters
   * @see See [Pagination documentation](https://getstream.io/chat/docs/channel_pagination/?language=js) for a list of available fields for sort.
   * */
  watchers:
  /** @type {PropTypes.Validator<{ limit?: number | undefined; offset?: number | undefined} | null | undefined> | undefined} */
  PropTypes__default['default'].object,

  /**
   * Set a Channel (of this id) to be active and move it to the top of the list of channels by ID.
   * */
  customActiveChannel: PropTypes__default['default'].string,

  /**
   * Last channel will be set as active channel if true, defaults to true
   */
  setActiveChannelOnMount: PropTypes__default['default'].bool,

  /**
   * If true, channels won't be dynamically sorted by most recent message.
   */
  lockChannelOrder: PropTypes__default['default'].bool,

  /**
   * When client receives an event `message.new`, we push that channel to top of the list.
   *
   * But If the channel doesn't exist in the list, then we get the channel from client
   * (client maintains list of watched channels as `client.activeChannels`) and push
   * that channel to top of the list by default. You can disallow this behavior by setting following
   * prop to false. This is quite usefull where you have multiple tab structure and you don't want
   * ChannelList in Tab1 to react to new message on some channel in Tab2.
   *
   * Default value is true.
   */
  allowNewMessagesFromUnfilteredChannels: PropTypes__default['default'].bool
};
var ChannelList$1 = /*#__PURE__*/React__default['default'].memo(ChannelList);

// @ts-check
/**
 * ChannelList - A preview list of channels, allowing you to select the channel you want to open
 * @example ../../docs/ChannelList.md
 * @type React.FC<import('../types').ChannelListUIComponentProps>
 */

var ChannelListMessenger = function ChannelListMessenger(_ref) {
  var _ref$error = _ref.error,
      error = _ref$error === void 0 ? false : _ref$error,
      loading = _ref.loading,
      _ref$LoadingErrorIndi = _ref.LoadingErrorIndicator,
      LoadingErrorIndicator = _ref$LoadingErrorIndi === void 0 ? ChatDown$1 : _ref$LoadingErrorIndi,
      _ref$LoadingIndicator = _ref.LoadingIndicator,
      LoadingIndicator = _ref$LoadingIndicator === void 0 ? LoadingChannels$1 : _ref$LoadingIndicator,
      children = _ref.children;

  if (error) {
    return /*#__PURE__*/React__default['default'].createElement(LoadingErrorIndicator, {
      type: "Connection Error"
    });
  }

  if (loading) {
    return /*#__PURE__*/React__default['default'].createElement(LoadingIndicator, null);
  }

  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__channel-list-messenger"
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__channel-list-messenger__main"
  }, children));
};
ChannelListMessenger.propTypes = {
  /** When true, loading indicator is shown - [LoadingChannels](https://github.com/GetStream/stream-chat-react/blob/master/src/components/LoadingChannels.js) */
  loading: PropTypes__default['default'].bool,

  /** When true, error indicator is shown - [ChatDown](https://github.com/GetStream/stream-chat-react/blob/master/src/components/ChatDown.js) */
  error: PropTypes__default['default'].bool,

  /**
   * Loading indicator UI Component. It will be displayed if `loading` prop is true.
   *
   * Defaults to and accepts same props as:
   * [LoadingChannels](https://github.com/GetStream/stream-chat-react/blob/master/src/components/LoadingChannels.js)
   *
   */
  LoadingIndicator:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').LoadingIndicatorProps>>} */
  PropTypes__default['default'].elementType,

  /**
   * Error indicator UI Component. It will be displayed if `error` prop is true
   *
   * Defaults to and accepts same props as:
   * [ChatDown](https://github.com/GetStream/stream-chat-react/blob/master/src/components/ChatDown.js)
   *
   */
  LoadingErrorIndicator:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').ChatDownProps>>} */
  PropTypes__default['default'].elementType
};

// @ts-check
/**
 * @type {React.FC}
 */

var ChannelSearch = function ChannelSearch() {
  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__channel-search"
  }, /*#__PURE__*/React__default['default'].createElement("input", {
    type: "text",
    placeholder: "Search"
  }), /*#__PURE__*/React__default['default'].createElement("button", {
    type: "submit"
  }, /*#__PURE__*/React__default['default'].createElement("svg", {
    width: "18",
    height: "17",
    viewBox: "0 0 18 17",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React__default['default'].createElement("path", {
    d: "M0 17.015l17.333-8.508L0 0v6.617l12.417 1.89L0 10.397z",
    fillRule: "evenodd"
  }))));
};

var ChannelSearch$1 = /*#__PURE__*/React__default['default'].memo(ChannelSearch);

// @ts-check
/**
 * DateSeparator - A simple date separator
 *
 * @example ../../docs/DateSeparator.md
 * @type {React.FC<import('../types').DateSeparatorProps>}
 */

var DateSeparator = function DateSeparator(_ref) {
  var _ref$position = _ref.position,
      position = _ref$position === void 0 ? 'right' : _ref$position,
      formatDate = _ref.formatDate,
      date = _ref.date,
      unread = _ref.unread;

  var _useContext = React.useContext(TranslationContext),
      t = _useContext.t,
      tDateTimeParser = _useContext.tDateTimeParser;

  if (typeof date === 'string') return null;
  var formattedDate = formatDate ? formatDate(date) : tDateTimeParser(date.toISOString()).calendar();
  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__date-separator"
  }, (position === 'right' || position === 'center') && /*#__PURE__*/React__default['default'].createElement("hr", {
    className: "str-chat__date-separator-line"
  }), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__date-separator-date"
  }, unread ? t('New') : formattedDate), (position === 'left' || position === 'center') && /*#__PURE__*/React__default['default'].createElement("hr", {
    className: "str-chat__date-separator-line"
  }));
};

DateSeparator.propTypes = {
  /** The date to format */
  date: PropTypes__default['default'].instanceOf(Date).isRequired,

  /** If following messages are not new */
  unread: PropTypes__default['default'].bool,

  /** Set the position of the date in the separator */
  position: PropTypes__default['default'].oneOf(['left', 'center', 'right']),

  /** Override the default formatting of the date. This is a function that has access to the original date object. Returns a string or Node  */
  formatDate: PropTypes__default['default'].func
};
var DefaultDateSeparator = /*#__PURE__*/React__default['default'].memo(DateSeparator);

// @ts-check
/**
 * EventComponent - Custom render component for system and channel event messages
 * @type {React.FC<import('../types').EventComponentProps>}
 */

var EventComponent = function EventComponent(_ref) {
  var _ref$Avatar = _ref.Avatar,
      Avatar$1 = _ref$Avatar === void 0 ? Avatar : _ref$Avatar,
      message = _ref.message;

  var _useContext = React.useContext(TranslationContext),
      tDateTimeParser = _useContext.tDateTimeParser;

  var type = message.type,
      text = message.text,
      event = message.event,
      _message$created_at = message.created_at,
      created_at = _message$created_at === void 0 ? '' : _message$created_at;
  if (type === 'system') return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__message--system"
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__message--system__text"
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__message--system__line"
  }), /*#__PURE__*/React__default['default'].createElement("p", null, text), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__message--system__line"
  })), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__message--system__date"
  }, /*#__PURE__*/React__default['default'].createElement("strong", null, tDateTimeParser(created_at).format('dddd'), " "), "at ", tDateTimeParser(created_at).format('hh:mm A')));

  if (type === 'channel.event' && event && (event.type === 'member.removed' || event.type === 'member.added')) {
    var _event$user, _event$user2, _event$user3;

    var name = (event === null || event === void 0 ? void 0 : (_event$user = event.user) === null || _event$user === void 0 ? void 0 : _event$user.name) || (event === null || event === void 0 ? void 0 : (_event$user2 = event.user) === null || _event$user2 === void 0 ? void 0 : _event$user2.id);
    var sentence = "".concat(name, " ").concat(event.type === 'member.added' ? 'has joined the chat' : 'was removed from the chat');
    return /*#__PURE__*/React__default['default'].createElement("div", {
      className: "str-chat__event-component__channel-event"
    }, /*#__PURE__*/React__default['default'].createElement(Avatar$1, {
      image: event === null || event === void 0 ? void 0 : (_event$user3 = event.user) === null || _event$user3 === void 0 ? void 0 : _event$user3.image,
      name: name
    }), /*#__PURE__*/React__default['default'].createElement("div", {
      className: "str-chat__event-component__channel-event__content"
    }, /*#__PURE__*/React__default['default'].createElement("em", {
      className: "str-chat__event-component__channel-event__sentence"
    }, sentence), /*#__PURE__*/React__default['default'].createElement("div", {
      className: "str-chat__event-component__channel-event__date"
    }, tDateTimeParser(created_at).format('LT'))));
  }

  return null;
};

EventComponent.propTypes = {
  /** Message object */
  // @ts-ignore
  message: PropTypes__default['default'].object.isRequired,

  /**
   * Custom UI component to display user avatar
   *
   * Defaults to and accepts same props as: [Avatar](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Avatar/Avatar.js)
   * */
  Avatar:
  /** @type {PropTypes.Validator<React.ElementType<import('../types').AvatarProps>>} */
  PropTypes__default['default'].elementType
};
var EventComponent$1 = /*#__PURE__*/React__default['default'].memo(EventComponent);

function ownKeys$b(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$b(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$b(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$b(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
/**
 * Prevents Chrome hangups
 * See: https://stackoverflow.com/questions/47524205/random-high-content-download-time-in-chrome/47684257#47684257
 * @param {Event} e
 */

var mousewheelListener = function mousewheelListener(e) {
  if (e instanceof WheelEvent && e.deltaY === 1) {
    e.preventDefault();
  }
};
/**
 * @param {HTMLElement | Element | null} el
 * @returns {number}
 */


var calculateTopPosition = function calculateTopPosition(el) {
  if (el instanceof HTMLElement) {
    return el.offsetTop + calculateTopPosition(el.offsetParent);
  }

  return 0;
};
/**
 * Computes by recursively summing offsetTop until an element without offsetParent is reached
 * @param {HTMLElement} el
 * @param {number} scrollTop
 */


var calculateOffset = function calculateOffset(el, scrollTop) {
  if (!el) {
    return 0;
  }

  return calculateTopPosition(el) + (el.offsetHeight - scrollTop - window.innerHeight);
};
/** @param {import("types").InfiniteScrollProps} props */


var InfiniteScroll = function InfiniteScroll(_ref) {
  var children = _ref.children,
      _ref$element = _ref.element,
      element = _ref$element === void 0 ? 'div' : _ref$element,
      _ref$hasMore = _ref.hasMore,
      hasMore = _ref$hasMore === void 0 ? false : _ref$hasMore,
      _ref$initialLoad = _ref.initialLoad,
      initialLoad = _ref$initialLoad === void 0 ? true : _ref$initialLoad,
      _ref$isReverse = _ref.isReverse,
      isReverse = _ref$isReverse === void 0 ? false : _ref$isReverse,
      loader = _ref.loader,
      loadMore = _ref.loadMore,
      _ref$threshold = _ref.threshold,
      threshold = _ref$threshold === void 0 ? 250 : _ref$threshold,
      _ref$useCapture = _ref.useCapture,
      useCapture = _ref$useCapture === void 0 ? false : _ref$useCapture,
      _ref$useWindow = _ref.useWindow,
      useWindow = _ref$useWindow === void 0 ? true : _ref$useWindow,
      _ref$isLoading = _ref.isLoading,
      isLoading = _ref$isLoading === void 0 ? false : _ref$isLoading,
      listenToScroll = _ref.listenToScroll,
      elementProps = _objectWithoutProperties__default['default'](_ref, ["children", "element", "hasMore", "initialLoad", "isReverse", "loader", "loadMore", "threshold", "useCapture", "useWindow", "isLoading", "listenToScroll"]);

  var scrollComponent = React.useRef(
  /** @type {HTMLElement | null} */
  null);
  var scrollListener = React.useCallback(function () {
    var el = scrollComponent.current;
    if (!el) return;
    var parentElement = el.parentElement;
    var offset = 0;
    var reverseOffset = 0;

    if (useWindow) {
      var doc = document.documentElement || document.body.parentNode || document.body;
      var scrollTop = window.pageYOffset !== undefined ? window.pageYOffset : doc.scrollTop;
      offset = calculateOffset(el, scrollTop);
      reverseOffset = scrollTop;
    } else if (parentElement) {
      offset = el.scrollHeight - parentElement.scrollTop - parentElement.clientHeight;
      reverseOffset = parentElement.scrollTop;
    }

    if (listenToScroll) {
      listenToScroll(offset, reverseOffset, threshold);
    } // Here we make sure the element is visible as well as checking the offset


    if ((isReverse ? reverseOffset : offset) < Number(threshold) && el.offsetParent !== null && typeof loadMore === 'function' && hasMore) {
      loadMore();
    }
  }, [hasMore, useWindow, isReverse, threshold, listenToScroll, loadMore]);
  React.useEffect(function () {
    var _scrollComponent$curr;

    var scrollEl = useWindow ? window : (_scrollComponent$curr = scrollComponent.current) === null || _scrollComponent$curr === void 0 ? void 0 : _scrollComponent$curr.parentNode;

    if (isLoading || !scrollEl) {
      return function () {};
    }

    scrollEl.addEventListener('scroll', scrollListener, useCapture);
    scrollEl.addEventListener('resize', scrollListener, useCapture);

    if (initialLoad) {
      scrollListener();
    }

    return function () {
      scrollEl.removeEventListener('scroll', scrollListener, useCapture);
      scrollEl.removeEventListener('resize', scrollListener, useCapture);
    };
  }, [initialLoad, isLoading, scrollListener, useCapture, useWindow]);
  React.useEffect(function () {
    var _scrollComponent$curr2;

    var scrollEl = useWindow ? window : (_scrollComponent$curr2 = scrollComponent.current) === null || _scrollComponent$curr2 === void 0 ? void 0 : _scrollComponent$curr2.parentNode;
    if (!scrollEl) return function () {};
    scrollEl.addEventListener('mousewheel', mousewheelListener, useCapture);
    return function () {
      return scrollEl.removeEventListener('mousewheel', mousewheelListener, useCapture);
    };
  }, [useCapture, useWindow]);

  var attributes = _objectSpread$b(_objectSpread$b({}, elementProps), {}, {
    /** @param {HTMLElement} e */
    ref: function ref(e) {
      scrollComponent.current = e;
    }
  });

  var childrenArray = [children];

  if (isLoading && loader) {
    if (isReverse) {
      childrenArray.unshift(loader);
    } else {
      childrenArray.push(loader);
    }
  }

  return /*#__PURE__*/React__default['default'].createElement(element, attributes, childrenArray);
};

InfiniteScroll.propTypes = {
  element: PropTypes__default['default'].elementType,
  hasMore: PropTypes__default['default'].bool,
  initialLoad: PropTypes__default['default'].bool,
  isReverse: PropTypes__default['default'].bool,
  loader: PropTypes__default['default'].node,
  loadMore: PropTypes__default['default'].func.isRequired,
  pageStart: PropTypes__default['default'].number,
  isLoading: PropTypes__default['default'].bool,
  threshold: PropTypes__default['default'].number,
  useCapture: PropTypes__default['default'].bool,
  useWindow: PropTypes__default['default'].bool
};

// @ts-check
/**
 * @type { React.FC<import('../types').InfiniteScrollPaginatorProps>}
 */

var InfiniteScrollPaginator = function InfiniteScrollPaginator(_ref) {
  var _ref$LoadingIndicator = _ref.LoadingIndicator,
      LoadingIndicator = _ref$LoadingIndicator === void 0 ? reactFileUtils.LoadingIndicator : _ref$LoadingIndicator,
      loadNextPage = _ref.loadNextPage,
      hasNextPage = _ref.hasNextPage,
      refreshing = _ref.refreshing,
      reverse = _ref.reverse,
      threshold = _ref.threshold,
      children = _ref.children;
  return /*#__PURE__*/React__default['default'].createElement(InfiniteScroll, {
    loadMore: loadNextPage,
    hasMore: hasNextPage,
    isLoading: refreshing,
    isReverse: reverse,
    threshold: threshold,
    useWindow: false,
    loader: /*#__PURE__*/React__default['default'].createElement("div", {
      className: "str-chat__infinite-scroll-paginator",
      key: "loadingindicator"
    }, /*#__PURE__*/React__default['default'].createElement(LoadingIndicator, null))
  }, children);
};

InfiniteScrollPaginator.propTypes = {
  /** callback to load the next page */
  loadNextPage: PropTypes__default['default'].func.isRequired,

  /** indicates if there is a next page to load */
  hasNextPage: PropTypes__default['default'].bool,

  /** indicates if there there's currently any refreshing taking place */
  refreshing: PropTypes__default['default'].bool,

  /** display the items in opposite order */
  reverse: PropTypes__default['default'].bool,

  /** Offset from when to start the loadNextPage call */
  threshold: PropTypes__default['default'].number,

  /** The loading indicator to use */
  // @ts-ignore
  LoadingIndicator: PropTypes__default['default'].elementType
};

/** @type {React.FC<import("types").InfiniteScrollProps>} */

var ReverseInfiniteScroll = function ReverseInfiniteScroll(props) {
  return /*#__PURE__*/React__default['default'].createElement(InfiniteScroll, _extends__default['default']({}, props, {
    isReverse: true
  }));
};

var Center = function Center(_ref) {
  var children = _ref.children;
  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__list__center"
  }, children);
};

var Center$1 = /*#__PURE__*/React__default['default'].memo(Center);

// @ts-check
/** @type {React.FC<import('../types').MessageNotificationProps>} */

var MessageNotification = function MessageNotification(_ref) {
  var showNotification = _ref.showNotification,
      onClick = _ref.onClick,
      children = _ref.children;
  if (!showNotification) return null;
  return /*#__PURE__*/React__default['default'].createElement("button", {
    "data-testid": "message-notification",
    className: "str-chat__message-notification",
    onClick: onClick
  }, children);
};

MessageNotification.defaultProps = {
  showNotification: true
};
MessageNotification.propTypes = {
  /** If we should show the notification or not */
  showNotification: PropTypes__default['default'].bool.isRequired,

  /** Onclick handler */
  onClick: PropTypes__default['default'].func.isRequired
};
var MessageNotification$1 = /*#__PURE__*/React__default['default'].memo(MessageNotification);

var CustomNotification = function CustomNotification(_ref) {
  var children = _ref.children,
      active = _ref.active,
      type = _ref.type;
  if (!active) return null;
  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__custom-notification notification-".concat(type),
    "data-testid": "custom-notification"
  }, children);
};

CustomNotification.propTypes = {
  active: PropTypes__default['default'].bool,
  type: PropTypes__default['default'].string
};
var CustomNotification$1 = /*#__PURE__*/React__default['default'].memo(CustomNotification);

/**
 * ConnectionStatus - Indicator that there is a connection failure
 * @type {React.FC<{}>}
 */

var ConnectionStatus = function ConnectionStatus() {
  var _useContext = React.useContext(ChatContext),
      client = _useContext.client;

  var _useContext2 = React.useContext(TranslationContext),
      t = _useContext2.t;

  var _useState = React.useState(true),
      _useState2 = _slicedToArray__default['default'](_useState, 2),
      online = _useState2[0],
      setOnline = _useState2[1];

  React.useEffect(function () {
    /** @param {import('stream-chat').Event} e */
    var connectionChanged = function connectionChanged(e) {
      if (e.online !== online) setOnline(
      /** @type {boolean} */
      e.online);
    };

    client.on('connection.changed', connectionChanged);
    return function () {
      return client.off('connection.changed', connectionChanged);
    };
  }, [client, online]);
  return /*#__PURE__*/React__default['default'].createElement(CustomNotification$1, {
    active: !online,
    type: "error"
  }, t('Connection failure, reconnecting now...'));
};

var ConnectionStatus$1 = /*#__PURE__*/React__default['default'].memo(ConnectionStatus);

var getLastReceived = function getLastReceived(messages) {
  for (var i = messages.length - 1; i > 0; i -= 1) {
    if (messages[i].status === 'received') return messages[i].id;
  }

  return null;
};

var getReadStates = function getReadStates(messages, read) {
  // create object with empty array for each message id
  var readData = {};
  Object.values(read).forEach(function (readState) {
    if (!readState.last_read) return;
    var userLastReadMsgId;
    messages.forEach(function (msg) {
      if (msg.updated_at < readState.last_read) userLastReadMsgId = msg.id;
    });

    if (userLastReadMsgId) {
      if (!readData[userLastReadMsgId]) readData[userLastReadMsgId] = [];
      readData[userLastReadMsgId].push(readState.user);
    }
  });
  return readData;
};

var insertDates = function insertDates(messages, lastRead, userID, hideDeletedMessages) {
  var unread = false;
  var lastDateSeparator;
  var newMessages = [];

  for (var i = 0, l = messages.length; i < l; i += 1) {
    var _messages, _newMessages;

    var message = messages[i];

    if (hideDeletedMessages && message.type === 'deleted') {
      continue;
    }

    if (message.type === 'message.read') {
      newMessages.push(message);
      continue;
    }

    var messageDate = message.created_at.toDateString();
    var prevMessageDate = messageDate;

    if (i > 0) {
      prevMessageDate = messages[i - 1].created_at.toDateString();
    }

    if (!unread) {
      unread = lastRead && new Date(lastRead) < message.created_at; // do not show date separator for current user's messages

      if (unread && message.user.id !== userID) {
        newMessages.push({
          type: 'message.date',
          date: message.created_at,
          unread
        });
      }
    }

    if ((i === 0 || messageDate !== prevMessageDate || hideDeletedMessages && ((_messages = messages[i - 1]) === null || _messages === void 0 ? void 0 : _messages.type) === 'deleted' && lastDateSeparator !== messageDate) && (newMessages === null || newMessages === void 0 ? void 0 : (_newMessages = newMessages[newMessages.length - 1]) === null || _newMessages === void 0 ? void 0 : _newMessages.type) !== 'message.date' // do not show two date separators in a row
    ) {
        lastDateSeparator = messageDate;
        newMessages.push({
          type: 'message.date',
          date: message.created_at
        }, message);
      } else {
      newMessages.push(message);
    }
  }

  return newMessages;
};

var insertIntro = function insertIntro(messages, headerPosition) {
  var newMessages = messages; // if no headerPosition is set, HeaderComponent will go at the top

  if (!headerPosition) {
    newMessages.unshift({
      type: 'channel.intro'
    });
    return newMessages;
  } // if no messages, intro gets inserted


  if (!newMessages.length) {
    newMessages.unshift({
      type: 'channel.intro'
    });
    return newMessages;
  } // else loop over the messages


  for (var i = 0, l = messages.length; i < l; i += 1) {
    var message = messages[i];
    var messageTime = message.created_at ? message.created_at.getTime() : null;
    var nextMessageTime = messages[i + 1] && messages[i + 1].created_at ? messages[i + 1].created_at.getTime() : null; // header position is smaller than message time so comes after;

    if (messageTime < headerPosition) {
      // if header position is also smaller than message time continue;
      if (nextMessageTime < headerPosition) {
        if (messages[i + 1] && messages[i + 1].type === 'message.date') continue;

        if (!nextMessageTime) {
          newMessages.push({
            type: 'channel.intro'
          });
          return newMessages;
        }

        continue;
      } else {
        newMessages.splice(i + 1, 0, {
          type: 'channel.intro'
        });
        return newMessages;
      }
    }
  }

  return newMessages;
};

var getGroupStyles = function getGroupStyles(message, previousMessage, nextMessage, noGroupByUser) {
  if (message.type === 'message.date') return '';
  if (message.type === 'channel.event') return '';
  if (message.type === 'channel.intro') return '';
  if (noGroupByUser || message.attachments.length !== 0) return 'single';
  var isTopMessage = !previousMessage || previousMessage.type === 'channel.intro' || previousMessage.type === 'message.date' || previousMessage.type === 'system' || previousMessage.type === 'channel.event' || previousMessage.attachments.length !== 0 || message.user.id !== previousMessage.user.id || previousMessage.type === 'error' || previousMessage.deleted_at;
  var isBottomMessage = !nextMessage || nextMessage.type === 'message.date' || nextMessage.type === 'system' || nextMessage.type === 'channel.event' || nextMessage.type === 'channel.intro' || nextMessage.attachments.length !== 0 || message.user.id !== nextMessage.user.id || nextMessage.type === 'error' || nextMessage.deleted_at;

  if (!isTopMessage && !isBottomMessage) {
    if (message.deleted_at || message.type === 'error') return 'single';
    return 'middle';
  }

  if (isBottomMessage) {
    if (isTopMessage || message.deleted_at || message.type === 'error') return 'single';
    return 'bottom';
  }

  if (isTopMessage) return 'top';
  return '';
};

var MessageListInner = function MessageListInner(props) {
  var bottomRef = props.bottomRef,
      client = props.client,
      channel = props.channel,
      DateSeparator = props.DateSeparator,
      _props$disableDateSep = props.disableDateSeparator,
      disableDateSeparator = _props$disableDateSep === void 0 ? false : _props$disableDateSep,
      EmptyStateIndicator = props.EmptyStateIndicator,
      HeaderComponent = props.HeaderComponent,
      headerPosition = props.headerPosition,
      _props$hideDeletedMes = props.hideDeletedMessages,
      hideDeletedMessages = _props$hideDeletedMes === void 0 ? false : _props$hideDeletedMes,
      internalInfiniteScrollProps = props.internalInfiniteScrollProps,
      internalMessageProps = props.internalMessageProps,
      messages = props.messages,
      MessageSystem = props.MessageSystem,
      noGroupByUser = props.noGroupByUser,
      onMessageLoadCaptured = props.onMessageLoadCaptured,
      read = props.read,
      threadList = props.threadList,
      TypingIndicator = props.TypingIndicator;
  var lastRead = React.useMemo(function () {
    return channel.lastRead();
  }, [channel]);
  var enrichedMessages = React.useMemo(function () {
    var messageWithDates = disableDateSeparator || threadList ? messages : insertDates(messages, lastRead, client.userID, hideDeletedMessages);
    if (HeaderComponent) return insertIntro(messageWithDates, headerPosition);
    return messageWithDates;
  }, [client.userID, disableDateSeparator, HeaderComponent, headerPosition, hideDeletedMessages, lastRead, messages, threadList]);
  var messageGroupStyles = React.useMemo(function () {
    return enrichedMessages.reduce(function (acc, message, i) {
      var style = getGroupStyles(message, enrichedMessages[i - 1], enrichedMessages[i + 1], noGroupByUser);
      if (style) acc[message.id] = style;
      return acc;
    }, {});
  }, [enrichedMessages, noGroupByUser]); // get the readData, but only for messages submitted by the user themselves

  var readData = React.useMemo(function () {
    return getReadStates(enrichedMessages.filter(function (_ref) {
      var user = _ref.user;
      return (user === null || user === void 0 ? void 0 : user.id) === client.userID;
    }), read);
  }, [client.userID, enrichedMessages, read]);
  var lastReceivedId = React.useMemo(function () {
    return getLastReceived(enrichedMessages);
  }, [enrichedMessages]);
  var elements = React.useMemo(function () {
    return enrichedMessages.map(function (message) {
      if (message.type === 'message.date') {
        return /*#__PURE__*/React__default['default'].createElement("li", {
          key: "".concat(message.date.toISOString(), "-i")
        }, /*#__PURE__*/React__default['default'].createElement(DateSeparator, {
          date: message.date,
          unread: message.unread
        }));
      }

      if (message.type === 'channel.intro') {
        return /*#__PURE__*/React__default['default'].createElement("li", {
          key: "intro"
        }, /*#__PURE__*/React__default['default'].createElement(HeaderComponent, null));
      }

      if (message.type === 'channel.event' || message.type === 'system') {
        var _message$event;

        if (!MessageSystem) return null;
        return /*#__PURE__*/React__default['default'].createElement("li", {
          key: ((_message$event = message.event) === null || _message$event === void 0 ? void 0 : _message$event.created_at) || message.created_at || ''
        }, /*#__PURE__*/React__default['default'].createElement(MessageSystem, {
          message: message
        }));
      }

      if (message.type !== 'message.read') {
        var groupStyles = messageGroupStyles[message.id] || '';
        return /*#__PURE__*/React__default['default'].createElement("li", {
          className: "str-chat__li str-chat__li--".concat(groupStyles),
          key: message.id || message.created_at,
          onLoadCapture: onMessageLoadCaptured
        }, /*#__PURE__*/React__default['default'].createElement(Message$1, _extends__default['default']({
          client: client,
          groupStyles: [groupStyles]
          /* TODO: convert to simple string */
          ,
          lastReceivedId: lastReceivedId,
          message: message,
          readBy: readData[message.id] || [],
          threadList: threadList
        }, internalMessageProps)));
      }

      return null;
    });
  }, [client, enrichedMessages, internalMessageProps, lastReceivedId, messageGroupStyles, MessageSystem, onMessageLoadCaptured, readData, threadList]);
  if (!elements.length) return /*#__PURE__*/React__default['default'].createElement(EmptyStateIndicator, {
    listType: "message"
  });
  return /*#__PURE__*/React__default['default'].createElement(InfiniteScroll, _extends__default['default']({
    className: "str-chat__reverse-infinite-scroll",
    "data-testid": "reverse-infinite-scroll",
    isReverse: true,
    useWindow: false
  }, internalInfiniteScrollProps), /*#__PURE__*/React__default['default'].createElement("ul", {
    className: "str-chat__ul"
  }, elements), /*#__PURE__*/React__default['default'].createElement(TypingIndicator, {
    threadList: threadList
  }), /*#__PURE__*/React__default['default'].createElement("div", {
    key: "bottom",
    ref: bottomRef
  }));
};

var MessageListInner$1 = /*#__PURE__*/React__default['default'].memo(MessageListInner, deepequal__default['default']);

// @ts-check
/**
 * TypingIndicator lists users currently typing, it needs to be a child of Channel component
 * @typedef {import('../types').TypingIndicatorProps} Props
 * @type {React.FC<Props>}
 */

var TypingIndicator = function TypingIndicator(_ref) {
  var _channel$getConfig;

  var _ref$Avatar = _ref.Avatar,
      Avatar$1 = _ref$Avatar === void 0 ? Avatar : _ref$Avatar,
      _ref$avatarSize = _ref.avatarSize,
      avatarSize = _ref$avatarSize === void 0 ? 32 : _ref$avatarSize,
      threadList = _ref.threadList;

  var _useContext = React.useContext(ChannelContext),
      channel = _useContext.channel,
      client = _useContext.client,
      thread = _useContext.thread,
      typing = _useContext.typing;

  if (!typing || !client || (channel === null || channel === void 0 ? void 0 : (_channel$getConfig = channel.getConfig()) === null || _channel$getConfig === void 0 ? void 0 : _channel$getConfig.typing_events) === false) {
    return null;
  }

  var typingInChannel = Object.values(typing).filter(function (_ref2) {
    var _client$user;

    var user = _ref2.user,
        parent_id = _ref2.parent_id;
    return (user === null || user === void 0 ? void 0 : user.id) !== ((_client$user = client.user) === null || _client$user === void 0 ? void 0 : _client$user.id) && parent_id == null;
  });
  var typingInThread = Object.values(typing).some(function (event) {
    return (event === null || event === void 0 ? void 0 : event.parent_id) === (thread === null || thread === void 0 ? void 0 : thread.id);
  });
  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__typing-indicator ".concat(threadList && typingInThread || !threadList && typingInChannel.length ? 'str-chat__typing-indicator--typing' : '')
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__typing-indicator__avatars"
  }, typingInChannel.map(function (_ref3, i) {
    var user = _ref3.user;
    return /*#__PURE__*/React__default['default'].createElement(Avatar$1, {
      image: user === null || user === void 0 ? void 0 : user.image,
      size: avatarSize,
      name: (user === null || user === void 0 ? void 0 : user.name) || (user === null || user === void 0 ? void 0 : user.id),
      key: "".concat(user === null || user === void 0 ? void 0 : user.id, "-").concat(i)
    });
  })), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__typing-indicator__dots"
  }, /*#__PURE__*/React__default['default'].createElement("span", {
    className: "str-chat__typing-indicator__dot"
  }), /*#__PURE__*/React__default['default'].createElement("span", {
    className: "str-chat__typing-indicator__dot"
  }), /*#__PURE__*/React__default['default'].createElement("span", {
    className: "str-chat__typing-indicator__dot"
  })));
};

var DefaultTypingIndicator = /*#__PURE__*/React__default['default'].memo(TypingIndicator);

function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
/**
 * MessageList - The message list components renders a list of messages. Its a consumer of [Channel Context](https://getstream.github.io/stream-chat-react/#channel)
 *
 * @example ../../docs/MessageList.md
 * @extends PureComponent
 */

var MessageList = /*#__PURE__*/function (_PureComponent) {
  _inherits__default['default'](MessageList, _PureComponent);

  var _super = _createSuper$2(MessageList);

  function MessageList(props) {
    var _this;

    _classCallCheck__default['default'](this, MessageList);

    _this = _super.call(this, props);

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "scrollToBottom", function () {
      _this._scrollToRef(_this.bottomRef, _this.messageList);
    });

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "_scrollToRef", function (el, parent) {
      var scrollDown = function scrollDown() {
        if (el && el.current && parent && parent.current) {
          _this.scrollToTarget(el.current, parent.current);
        }
      };

      scrollDown(); // scroll down after images load again

      setTimeout(scrollDown, 200);
    });

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "scrollToTarget", function (target, containerEl) {
      // Moved up here for readability:
      var isElement = target && target.nodeType === 1;
      var isNumber = Object.prototype.toString.call(target) === '[object Number]';
      var scrollTop;
      if (isElement) scrollTop = target.offsetTop;else if (isNumber) scrollTop = target;else if (target === 'top') scrollTop = 0;else if (target === 'bottom') scrollTop = containerEl.scrollHeight - containerEl.offsetHeight;
      if (scrollTop !== undefined) containerEl.scrollTop = scrollTop; // eslint-disable-line no-param-reassign
    });

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "goToNewMessages", function () {
      _this.scrollToBottom();

      _this.setState({
        newMessagesNotification: false
      });
    });

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "userScrolledUp", function () {
      return _this.scrollOffset > 200;
    });

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "listenToScroll", function (offset, reverseOffset, threshold) {
      _this.scrollOffset = offset;
      _this.closeToTop = reverseOffset < threshold;

      if (_this.state.newMessagesNotification && !_this.userScrolledUp()) {
        _this.setState({
          newMessagesNotification: false
        });
      }
    });

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "addNotification", function (notificationText, type) {
      if (typeof notificationText !== 'string') return;
      if (type !== 'success' && type !== 'error') return;
      var id = uuid.v4();

      _this.setState(function (_ref) {
        var notifications = _ref.notifications;
        return {
          notifications: [].concat(_toConsumableArray__default['default'](notifications), [{
            id,
            text: notificationText,
            type
          }])
        };
      }); // remove the notification after 5000 ms


      var ct = setTimeout(function () {
        return _this.setState(function (_ref2) {
          var notifications = _ref2.notifications;
          return {
            notifications: notifications.filter(function (n) {
              return n.id !== id;
            })
          };
        });
      }, 5000);

      _this.notificationTimeouts.push(ct);
    });

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "onMessageLoadCaptured", function () {
      // A load event (emitted by e.g. an <img>) was captured on a message.
      // In some cases, the loaded asset is larger than the placeholder, which means we have to scroll down.
      if (!_this.userScrolledUp() && !_this.closeToTop) {
        _this.scrollToBottom();
      }
    });

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "loadMore", function () {
      return _this.props.messageLimit ? _this.props.loadMore(_this.props.messageLimit) : _this.props.loadMore();
    });

    _this.state = {
      newMessagesNotification: false,
      notifications: []
    };
    _this.bottomRef = /*#__PURE__*/React__default['default'].createRef();
    _this.messageList = /*#__PURE__*/React__default['default'].createRef();
    _this.notificationTimeouts = [];
    return _this;
  }

  _createClass__default['default'](MessageList, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      // start at the bottom
      this.scrollToBottom();
      var messageListRect = this.messageList.current.getBoundingClientRect();
      this.setState({
        messageListRect
      });
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.notificationTimeouts.forEach(clearTimeout);
    }
  }, {
    key: "getSnapshotBeforeUpdate",
    value: function getSnapshotBeforeUpdate(prevProps) {
      if (this.props.threadList) {
        return null;
      } // Are we adding new items to the list?
      // Capture the scroll position so we can adjust scroll later.


      if (prevProps.messages.length < this.props.messages.length) {
        var list = this.messageList.current;
        return {
          offsetTop: list.scrollTop,
          offsetBottom: list.scrollHeight - list.scrollTop
        };
      }

      return null;
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState, snapshot) {
      // If we have a snapshot value, we've just added new items.
      // Adjust scroll so these new items don't push the old ones out of view.
      // (snapshot here is the value returned from getSnapshotBeforeUpdate)
      var userScrolledUp = this.userScrolledUp();
      var currentLastMessage = this.props.messages[this.props.messages.length - 1];
      var previousLastMessage = prevProps.messages[prevProps.messages.length - 1];

      if (!previousLastMessage || !currentLastMessage) {
        return;
      }

      var hasNewMessage = currentLastMessage.id !== previousLastMessage.id;
      var isOwner = currentLastMessage.user.id === this.props.client.userID;
      var list = this.messageList.current; // always scroll down when it's your own message that you added...

      var scrollToBottom = hasNewMessage && (isOwner || !userScrolledUp);

      if (scrollToBottom) {
        this.scrollToBottom(); // remove the scroll notification if we already scrolled down...

        if (this.state.newMessagesNotification) this.setState({
          newMessagesNotification: false
        });
        return;
      }

      if (snapshot !== null) {
        // Maintain the offsetTop of scroll so that content in viewport doesn't move.
        // This is for the case where user has scroll up significantly and a new message arrives from someone.
        if (hasNewMessage) {
          this.scrollToTarget(snapshot.offsetTop, this.messageList.current);
        } else {
          // Maintain the bottomOffset of scroll.
          // This is for the case of pagination, when more messages get loaded.
          this.scrollToTarget(list.scrollHeight - snapshot.offsetBottom, this.messageList.current);
        }
      } // Check the scroll position... if you're scrolled up show a little notification


      if (hasNewMessage && !this.state.newMessagesNotification) {
        this.setState({
          newMessagesNotification: true
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var t = this.props.t;
      return /*#__PURE__*/React__default['default'].createElement(React__default['default'].Fragment, null, /*#__PURE__*/React__default['default'].createElement("div", {
        className: "str-chat__list ".concat(this.props.threadList ? 'str-chat__list--thread' : ''),
        ref: this.messageList
      }, /*#__PURE__*/React__default['default'].createElement(MessageListInner$1, {
        bottomRef: this.bottomRef,
        channel: this.props.channel,
        client: this.props.client,
        DateSeparator: this.props.DateSeparator || this.props.dateSeparator,
        disableDateSeparator: this.props.disableDateSeparator,
        EmptyStateIndicator: this.props.EmptyStateIndicator,
        HeaderComponent: this.props.HeaderComponent,
        headerPosition: this.props.headerPosition,
        hideDeletedMessages: this.props.hideDeletedMessages,
        messages: this.props.messages,
        MessageSystem: this.props.MessageSystem,
        noGroupByUser: this.props.noGroupByUser,
        onMessageLoadCaptured: this.onMessageLoadCaptured,
        read: this.props.read,
        threadList: this.props.threadList,
        TypingIndicator: this.props.TypingIndicator,
        internalInfiniteScrollProps: {
          hasMore: this.props.hasMore,
          isLoading: this.props.loadingMore,
          listenToScroll: this.listenToScroll,
          loadMore: this.loadMore,
          loader: /*#__PURE__*/React__default['default'].createElement(Center$1, {
            key: "loadingindicator"
          }, smartRender(this.props.LoadingIndicator, {
            size: 20
          }, null))
        },
        internalMessageProps: {
          additionalMessageInputProps: this.props.additionalMessageInputProps,
          addNotification: this.addNotification,
          Attachment: this.props.Attachment,
          Avatar: this.props.Avatar,
          channel: this.props.channel,
          getFlagMessageSuccessNotification: this.props.getFlagMessageSuccessNotification,
          getFlagMessageErrorNotification: this.props.getFlagMessageErrorNotification,
          getMuteUserSuccessNotification: this.props.getMuteUserSuccessNotification,
          getMuteUserErrorNotification: this.props.getMuteUserErrorNotification,
          getPinMessageErrorNotification: this.props.getPinMessageErrorNotification,
          members: this.props.members,
          Message: this.props.Message,
          messageActions: this.props.messageActions,
          messageListRect: this.state.messageListRect,
          mutes: this.props.mutes,
          onMentionsClick: this.props.onMentionsClick,
          onMentionsHover: this.props.onMentionsHover,
          openThread: this.props.openThread,
          removeMessage: this.props.removeMessage,
          retrySendMessage: this.props.retrySendMessage,
          unsafeHTML: this.props.unsafeHTML,
          updateMessage: this.props.updateMessage,
          watchers: this.props.watchers,
          pinPermissions: this.props.pinPermissions
        }
      })), /*#__PURE__*/React__default['default'].createElement("div", {
        className: "str-chat__list-notifications"
      }, this.state.notifications.map(function (notification) {
        return /*#__PURE__*/React__default['default'].createElement(CustomNotification$1, {
          active: true,
          key: notification.id,
          type: notification.type
        }, notification.text);
      }), /*#__PURE__*/React__default['default'].createElement(ConnectionStatus$1, null), /*#__PURE__*/React__default['default'].createElement(MessageNotification$1, {
        onClick: this.goToNewMessages,
        showNotification: this.state.newMessagesNotification
      }, t('New Messages!'))));
    }
  }]);

  return MessageList;
}(React.PureComponent);

MessageList.propTypes = {
  /**
   * Date separator UI component to render
   *
   * Defaults to and accepts same props as: [DateSeparator](https://github.com/GetStream/stream-chat-react/blob/master/src/components/DateSeparator.js)
   * */
  dateSeparator: PropTypes__default['default'].elementType,

  /** Disables the injection of date separator components, defaults to false */
  disableDateSeparator: PropTypes__default['default'].bool,

  /** Hides the MessageDeleted components from the list, defaults to false */
  hideDeletedMessages: PropTypes__default['default'].bool,

  /** Turn off grouping of messages by user */
  noGroupByUser: PropTypes__default['default'].bool,

  /** render HTML instead of markdown. Posting HTML is only allowed server-side */
  unsafeHTML: PropTypes__default['default'].bool,

  /** Set the limit to use when paginating messages */
  messageLimit: PropTypes__default['default'].number,

  /**
   * Array of allowed actions on message. e.g. ['edit', 'delete', 'flag', 'mute', 'react', 'reply']
   * If all the actions need to be disabled, empty array or false should be provided as value of prop.
   * */
  messageActions: PropTypes__default['default'].oneOfType([PropTypes__default['default'].bool, PropTypes__default['default'].array]),

  /**
   * Boolean weather current message list is a thread.
   */
  threadList: PropTypes__default['default'].bool,

  /**
   * Function that returns message/text as string to be shown as notification, when request for flagging a message is successful
   *
   * This function should accept following params:
   *
   * @param message A [message object](https://getstream.io/chat/docs/#message_format) which is flagged.
   *
   * */
  getFlagMessageSuccessNotification: PropTypes__default['default'].func,

  /**
   * Function that returns message/text as string to be shown as notification, when request for flagging a message runs into error
   *
   * This function should accept following params:
   *
   * @param message A [message object](https://getstream.io/chat/docs/#message_format) which is flagged.
   *
   * */
  getFlagMessageErrorNotification: PropTypes__default['default'].func,

  /**
   * Function that returns message/text as string to be shown as notification, when request for muting a user is successful
   *
   * This function should accept following params:
   *
   * @param user A user object which is being muted
   *
   * */
  getMuteUserSuccessNotification: PropTypes__default['default'].func,

  /**
   * Function that returns message/text as string to be shown as notification, when request for muting a user runs into error
   *
   * This function should accept following params:
   *
   * @param user A user object which is being muted
   *
   * */
  getMuteUserErrorNotification: PropTypes__default['default'].func,

  /**
   * Function that returns message/text as string to be shown as notification, when request for pinning a message runs into error
   *
   * This function should accept following params:
   *
   * @param message A [message object](https://getstream.io/chat/docs/#message_format)
   *
   * */
  getPinMessageErrorNotification: PropTypes__default['default'].func,

  /** **Available from [chat context](https://getstream.github.io/stream-chat-react/#chat)** */
  client: PropTypes__default['default'].object,

  /** **Available from [channel context](https://getstream.github.io/stream-chat-react/#channel)** */
  Attachment: PropTypes__default['default'].elementType,

  /**
   * Custom UI component to display user avatar
   *
   * Defaults to and accepts same props as: [Avatar](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Avatar/Avatar.js)
   * */
  Avatar: PropTypes__default['default'].elementType,

  /** **Available from [channel context](https://getstream.github.io/stream-chat-react/#channel)** */
  Message: PropTypes__default['default'].elementType,

  /**
   * Custom UI component to display system messages.
   *
   * Defaults to and accepts same props as: [EventComponent](https://github.com/GetStream/stream-chat-react/blob/master/src/components/EventComponent.js)
   */
  MessageSystem: PropTypes__default['default'].elementType,

  /**
   * Typing indicator UI component to render
   *
   * Defaults to and accepts same props as: [TypingIndicator](https://github.com/GetStream/stream-chat-react/blob/master/src/components/TypingIndicator/TypingIndicator.js)
   * */
  TypingIndicator: PropTypes__default['default'].elementType,

  /**
   * The UI Indicator to use when MessageList or ChannelList is empty
   * */
  EmptyStateIndicator: PropTypes__default['default'].elementType,

  /**
   * Component to render at the top of the MessageList
   * */
  HeaderComponent: PropTypes__default['default'].elementType,

  /**
   * Component to render at the top of the MessageList while loading new messages
   * */
  LoadingIndicator: PropTypes__default['default'].elementType,

  /** **Available from [channel context](https://getstream.github.io/stream-chat-react/#channel)** */
  messages: PropTypes__default['default'].array.isRequired,

  /** **Available from [channel context](https://getstream.github.io/stream-chat-react/#channel)** */
  channel:
  /** @type {PropTypes.Validator<ReturnType<import('../types').StreamChatReactClient['channel']>>} */
  PropTypes__default['default'].objectOf(checkChannelPropType).isRequired,

  /** **Available from [channel context](https://getstream.github.io/stream-chat-react/#channel)** */
  updateMessage: PropTypes__default['default'].func.isRequired,

  /** **Available from [channel context](https://getstream.github.io/stream-chat-react/#channel)** */
  retrySendMessage: PropTypes__default['default'].func,

  /** **Available from [channel context](https://getstream.github.io/stream-chat-react/#channel)** */
  removeMessage: PropTypes__default['default'].func,

  /** **Available from [channel context](https://getstream.github.io/stream-chat-react/#channel)** */
  onMentionsClick: PropTypes__default['default'].func,

  /** **Available from [channel context](https://getstream.github.io/stream-chat-react/#channel)** */
  onMentionsHover: PropTypes__default['default'].func,

  /** **Available from [channel context](https://getstream.github.io/stream-chat-react/#channel)** */
  openThread: PropTypes__default['default'].func,

  /** **Available from [channel context](https://getstream.github.io/stream-chat-react/#channel)** */
  members: PropTypes__default['default'].object,

  /** **Available from [channel context](https://getstream.github.io/stream-chat-react/#channel)** */
  watchers: PropTypes__default['default'].object,

  /** **Available from [channel context](https://getstream.github.io/stream-chat-react/#channel)** */
  read: PropTypes__default['default'].object,

  /**
   * Additional props for underlying MessageInput component. We have instance of MessageInput
   * component in MessageSimple component, for handling edit state.
   * Available props - https://getstream.github.io/stream-chat-react/#messageinput
   * */
  additionalMessageInputProps: PropTypes__default['default'].object,

  /**
   * The user roles allowed to pin messages in various channel types
   */
  pinPermissions:
  /** @type {PropTypes.Validator<import('../types').PinPermissions>>} */
  PropTypes__default['default'].object
};
MessageList.defaultProps = {
  Attachment,
  Avatar,
  Message: MessageSimple$1,
  MessageSystem: EventComponent$1,
  threadList: false,
  DateSeparator: DefaultDateSeparator,
  LoadingIndicator: DefaultLoadingIndicator,
  TypingIndicator: DefaultTypingIndicator,
  EmptyStateIndicator: DefaultEmptyStateIndicator,
  unsafeHTML: false,
  noGroupByUser: false,
  messageActions: Object.keys(MESSAGE_ACTIONS),
  pinPermissions: defaultPinPermissions
};
var MessageList$1 = withTranslationContext(function (props) {
  return /*#__PURE__*/React__default['default'].createElement(ChannelContext.Consumer, null, function (_ref3) {
    var typing = _ref3.typing,
        channelContext = _objectWithoutProperties__default['default'](_ref3, ["typing"]);

    return /*#__PURE__*/React__default['default'].createElement(MessageList, _extends__default['default']({}, channelContext, props));
  });
});

/**
 * VirtualizedMessageList - This component renders a list of messages in a virtual list. Its a consumer of [Channel Context](https://getstream.github.io/stream-chat-react/#channel)
 * It is pretty fast for rendering thousands of messages but it needs its Message componet to have fixed height
 * @example ../../docs/VirtualizedMessageList.md
 * @type {React.FC<import('../types').VirtualizedMessageListInternalProps>}
 */

var VirtualizedMessageList = function VirtualizedMessageList(_ref) {
  var client = _ref.client,
      messages = _ref.messages,
      loadMore = _ref.loadMore,
      hasMore = _ref.hasMore,
      loadingMore = _ref.loadingMore,
      _ref$messageLimit = _ref.messageLimit,
      messageLimit = _ref$messageLimit === void 0 ? 100 : _ref$messageLimit,
      _ref$overscan = _ref.overscan,
      overscan = _ref$overscan === void 0 ? 200 : _ref$overscan,
      _ref$shouldGroupByUse = _ref.shouldGroupByUser,
      shouldGroupByUser = _ref$shouldGroupByUse === void 0 ? false : _ref$shouldGroupByUse,
      customMessageRenderer = _ref.customMessageRenderer,
      scrollSeekPlaceHolder = _ref.scrollSeekPlaceHolder,
      _ref$Message = _ref.Message,
      Message = _ref$Message === void 0 ? FixedHeightMessage$1 : _ref$Message,
      _ref$MessageSystem = _ref.MessageSystem,
      MessageSystem = _ref$MessageSystem === void 0 ? EventComponent$1 : _ref$MessageSystem,
      _ref$MessageDeleted = _ref.MessageDeleted,
      MessageDeleted$1 = _ref$MessageDeleted === void 0 ? MessageDeleted : _ref$MessageDeleted,
      _ref$TypingIndicator = _ref.TypingIndicator,
      TypingIndicator = _ref$TypingIndicator === void 0 ? null : _ref$TypingIndicator,
      _ref$LoadingIndicator = _ref.LoadingIndicator,
      LoadingIndicator = _ref$LoadingIndicator === void 0 ? DefaultLoadingIndicator : _ref$LoadingIndicator,
      _ref$EmptyStateIndica = _ref.EmptyStateIndicator,
      EmptyStateIndicator = _ref$EmptyStateIndica === void 0 ? DefaultEmptyStateIndicator : _ref$EmptyStateIndica;

  var _useContext = React.useContext(TranslationContext),
      t = _useContext.t;

  var _useState = React.useState(false),
      _useState2 = _slicedToArray__default['default'](_useState, 2),
      newMessagesNotification = _useState2[0],
      setNewMessagesNotification = _useState2[1];

  var virtuoso = React.useRef(
  /** @type {import('react-virtuoso').VirtuosoMethods | undefined} */
  undefined);
  var mounted = React.useRef(false);
  var atBottom = React.useRef(false);
  var lastMessageId = React.useRef('');
  React.useEffect(function () {
    var _lastMessage$user;

    /* handle scrolling behavior for new messages */
    if (!messages.length) return;
    var lastMessage = messages[messages.length - 1];
    var prevMessageId = lastMessageId.current;
    lastMessageId.current = lastMessage.id || ''; // update last message id

    /* do nothing if new messages are loaded from top(loadMore)  */

    if (lastMessage.id === prevMessageId) return;
    /* if list is already at the bottom return, followOutput will do the job */

    if (atBottom.current) return;
    /* if the new message belongs to current user scroll to bottom */

    if (((_lastMessage$user = lastMessage.user) === null || _lastMessage$user === void 0 ? void 0 : _lastMessage$user.id) === client.userID) {
      setTimeout(function () {
        var _virtuoso$current;

        return (_virtuoso$current = virtuoso.current) === null || _virtuoso$current === void 0 ? void 0 : _virtuoso$current.scrollToIndex(messages.length);
      });
      return;
    }
    /* otherwise just show newMessage notification  */


    setNewMessagesNotification(true);
  }, [client.userID, messages]);
  React.useEffect(function () {
    /*
     * scroll to bottom when list is rendered for the first time
     * this is due to initialTopMostItemIndex buggy behavior leading to empty screen
     */
    if (mounted.current) return;
    mounted.current = true;

    if (messages.length && virtuoso.current) {
      virtuoso.current.scrollToIndex(messages.length - 1);
    }
  }, [messages.length]);
  var messageRenderer = React.useCallback(function (messageList, i) {
    // use custom renderer supplied by client if present and skip the rest
    if (customMessageRenderer) return customMessageRenderer(messageList, i);
    var message = messageList[i];
    if (!message) return /*#__PURE__*/React__default['default'].createElement("div", {
      style: {
        height: '1px'
      }
    }); // returning null or zero height breaks the virtuoso

    if (message.type === 'channel.event' || message.type === 'system') return /*#__PURE__*/React__default['default'].createElement(MessageSystem, {
      message: message
    });
    if (message.deleted_at) return smartRender(MessageDeleted$1, {
      message
    }, null);
    return /*#__PURE__*/React__default['default'].createElement(Message, {
      message: message,
      groupedByUser: shouldGroupByUser && i > 0 && message.user.id === messageList[i - 1].user.id
    });
  }, [MessageDeleted$1, customMessageRenderer, shouldGroupByUser]);
  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__virtual-list"
  }, /*#__PURE__*/React__default['default'].createElement(reactVirtuoso.Virtuoso // @ts-ignore
  , {
    ref: virtuoso,
    totalCount: messages.length,
    overscan: overscan,
    followOutput: true,
    maxHeightCacheSize: 2000 // reset the cache once it reaches 2k
    ,
    scrollSeek: scrollSeekPlaceHolder,
    item: function item(i) {
      return messageRenderer(messages, i);
    },
    emptyComponent: function emptyComponent() {
      return /*#__PURE__*/React__default['default'].createElement(EmptyStateIndicator, {
        listType: "message"
      });
    },
    header: function header() {
      return loadingMore ? /*#__PURE__*/React__default['default'].createElement("div", {
        className: "str-chat__virtual-list__loading"
      }, /*#__PURE__*/React__default['default'].createElement(LoadingIndicator, {
        size: 20
      })) : /*#__PURE__*/React__default['default'].createElement(React__default['default'].Fragment, null);
    },
    footer: function footer() {
      return TypingIndicator ? /*#__PURE__*/React__default['default'].createElement(TypingIndicator, {
        avatarSize: 24
      }) : /*#__PURE__*/React__default['default'].createElement(React__default['default'].Fragment, null);
    },
    startReached: function startReached() {
      // mounted.current prevents immediate loadMore on first render
      if (mounted.current && hasMore) {
        var _virtuoso$current2;

        loadMore(messageLimit).then((_virtuoso$current2 = virtuoso.current) === null || _virtuoso$current2 === void 0 ? void 0 : _virtuoso$current2.adjustForPrependedItems);
      }
    },
    atBottomStateChange: function atBottomStateChange(isAtBottom) {
      atBottom.current = isAtBottom;
      if (isAtBottom && newMessagesNotification) setNewMessagesNotification(false);
    }
  }), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__list-notifications"
  }, /*#__PURE__*/React__default['default'].createElement(MessageNotification$1, {
    showNotification: newMessagesNotification,
    onClick: function onClick() {
      if (virtuoso.current) virtuoso.current.scrollToIndex(messages.length);
      setNewMessagesNotification(false);
    }
  }, t('New Messages!'))));
}; // TODO: fix the types here when everything converted to proper TS

/**
 * @param {import("types").VirtualizedMessageListProps} props
 * @returns {React.ElementType<import("types").VirtualizedMessageListInternalProps>}
 */


function VirtualizedMessageListWithContext(props) {
  // @ts-ignore
  return /*#__PURE__*/React__default['default'].createElement(ChannelContext.Consumer, null, function (
  /* {Required<Pick<import('../types').ChannelContextValue, 'client' | 'messages' | 'loadMore' | 'hasMore' | 'loadingMore'>>} */
  context) {
    return /*#__PURE__*/React__default['default'].createElement(VirtualizedMessageList, _extends__default['default']({
      client: context.client // @ts-ignore
      ,
      messages: context.messages // @ts-ignore
      ,
      loadMore: context.loadMore // @ts-ignore
      ,
      hasMore: context.hasMore // @ts-ignore
      ,
      loadingMore: context.loadingMore
    }, props));
  });
}

function ownKeys$c(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$c(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$c(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$c(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
/**
 * Thread - The Thread renders a parent message with a list of replies. Use the standard message list of the main channel's messages.
 * The thread is only used for the list of replies to a message.
 * Underlying MessageList, MessageInput and Message components can be customized using props:
 * - additionalParentMessageProps
 * - additionalMessageListProps
 * - additionalMessageInputProps
 *
 * @example ../../docs/Thread.md
 * @typedef {import('../types').ThreadProps} ThreadProps
 * @type { React.FC<ThreadProps>}
 */

var Thread$7 = function Thread(props) {
  var _channel$getConfig, _channel$getConfig$ca;

  var _useContext = React.useContext(ChannelContext),
      channel = _useContext.channel,
      thread = _useContext.thread;

  if (!thread || (channel === null || channel === void 0 ? void 0 : (_channel$getConfig = channel.getConfig) === null || _channel$getConfig === void 0 ? void 0 : (_channel$getConfig$ca = _channel$getConfig.call(channel)) === null || _channel$getConfig$ca === void 0 ? void 0 : _channel$getConfig$ca.replies) === false) return null; // The wrapper ensures a key variable is set and the component recreates on thread switch

  return /*#__PURE__*/React__default['default'].createElement(ThreadInner, _extends__default['default']({}, props, {
    key: "thread-".concat(thread.id, "-").concat(channel === null || channel === void 0 ? void 0 : channel.cid)
  }));
};

Thread$7.propTypes = {
  /**
   * Additional props for underlying MessageInput component.
   * Available props - https://getstream.github.io/stream-chat-react/#messageinput
   * */
  additionalMessageInputProps: PropTypes__default['default'].object,

  /**
   * Additional props for underlying MessageList component.
   * Available props - https://getstream.github.io/stream-chat-react/#messagelist
   * */
  additionalMessageListProps: PropTypes__default['default'].object,

  /**
   * Additional props for underlying Message component of parent message at the top.
   * Available props - https://getstream.github.io/stream-chat-react/#message
   * */
  additionalParentMessageProps: PropTypes__default['default'].object,

  /** Make input focus on mounting thread */
  autoFocus: PropTypes__default['default'].bool,

  /** Display the thread on 100% width of it's container. Useful for mobile style view */
  fullWidth: PropTypes__default['default'].bool,

  /** UI component to override the default Message stored in channel context */
  Message:
  /** @type {PropTypes.Validator<React.ComponentType<import('../types').MessageUIComponentProps>>} */
  PropTypes__default['default'].elementType,

  /** Customized MessageInput component to used within Thread instead of default MessageInput
      Useable as follows:
      ```
      <Thread MessageInput={(props) => <MessageInput parent={props.parent} Input={MessageInputSmall} /> }/>
      ```
  */
  MessageInput:
  /** @type {PropTypes.Validator<React.ComponentType<import('../types').MessageInputProps>>} */
  PropTypes__default['default'].elementType,

  /** UI component used to override the default header of the thread */
  ThreadHeader:
  /** @type {PropTypes.Validator<React.ComponentType<import('../types').ThreadHeaderProps>>} */
  PropTypes__default['default'].elementType
};
Thread$7.defaultProps = {
  fullWidth: false,
  autoFocus: true,
  MessageInput: MessageInput$1
};
/**
 * @type { React.FC<import('../types').ThreadHeaderProps> }
 */

var DefaultThreadHeader = function DefaultThreadHeader(_ref) {
  var closeThread = _ref.closeThread,
      t = _ref.t,
      thread = _ref.thread;

  var getReplyCount = function getReplyCount() {
    if (!(thread !== null && thread !== void 0 && thread.reply_count) || !t) return '';
    if (thread.reply_count === 1) return t('1 reply');
    return t('{{ replyCount }} replies', {
      replyCount: thread.reply_count
    });
  };

  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__thread-header"
  }, /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__thread-header-details"
  }, /*#__PURE__*/React__default['default'].createElement("strong", null, t && t('Thread')), /*#__PURE__*/React__default['default'].createElement("small", null, getReplyCount())), /*#__PURE__*/React__default['default'].createElement("button", {
    onClick: function onClick(e) {
      return closeThread && closeThread(e);
    },
    className: "str-chat__square-button",
    "data-testid": "close-button"
  }, /*#__PURE__*/React__default['default'].createElement("svg", {
    width: "10",
    height: "10",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React__default['default'].createElement("path", {
    d: "M9.916 1.027L8.973.084 5 4.058 1.027.084l-.943.943L4.058 5 .084 8.973l.943.943L5 5.942l3.973 3.974.943-.943L5.942 5z",
    fillRule: "evenodd"
  }))));
};
/**
 * @typedef {import('../types').ThreadProps & {key: string}} ThreadInnerProps
 * @type { React.FC<ThreadInnerProps>}
 */


var ThreadInner = function ThreadInner(props) {
  var additionalMessageInputProps = props.additionalMessageInputProps,
      additionalMessageListProps = props.additionalMessageListProps,
      additionalParentMessageProps = props.additionalParentMessageProps,
      autoFocus = props.autoFocus,
      fullWidth = props.fullWidth,
      PropMessage = props.Message,
      ThreadMessageInput = props.MessageInput,
      _props$ThreadHeader = props.ThreadHeader,
      ThreadHeader = _props$ThreadHeader === void 0 ? DefaultThreadHeader : _props$ThreadHeader;

  var _useContext2 = React.useContext(ChannelContext),
      channel = _useContext2.channel,
      closeThread = _useContext2.closeThread,
      loadMoreThread = _useContext2.loadMoreThread,
      ContextMessage = _useContext2.Message,
      thread = _useContext2.thread,
      threadHasMore = _useContext2.threadHasMore,
      threadLoadingMore = _useContext2.threadLoadingMore,
      threadMessages = _useContext2.threadMessages;

  var _useContext3 = React.useContext(ChatContext),
      client = _useContext3.client;

  var _useContext4 = React.useContext(TranslationContext),
      t = _useContext4.t;

  var messageList = React.useRef(
  /** @type {HTMLDivElement | null} */
  null);
  var parentID = thread === null || thread === void 0 ? void 0 : thread.id;
  var ThreadMessage = PropMessage || ContextMessage;
  React.useEffect(function () {
    if (parentID && thread !== null && thread !== void 0 && thread.reply_count && loadMoreThread) {
      loadMoreThread();
    }
  }, []); // eslint-disable-line

  React.useEffect(function () {
    if (messageList.current && threadMessages !== null && threadMessages !== void 0 && threadMessages.length) {
      var _messageList$current = messageList.current,
          clientHeight = _messageList$current.clientHeight,
          scrollTop = _messageList$current.scrollTop,
          scrollHeight = _messageList$current.scrollHeight;
      var scrollDown = clientHeight + scrollTop !== scrollHeight;

      if (scrollDown) {
        messageList.current.scrollTop = scrollHeight - clientHeight;
      }
    }
  }, [threadMessages === null || threadMessages === void 0 ? void 0 : threadMessages.length]);
  if (!thread) return null;
  var read = {};
  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__thread ".concat(fullWidth ? 'str-chat__thread--full' : '')
  }, /*#__PURE__*/React__default['default'].createElement(ThreadHeader, {
    closeThread: closeThread,
    t: t,
    thread: thread
  }), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__thread-list",
    ref: messageList
  }, /*#__PURE__*/React__default['default'].createElement(Message$1, _extends__default['default']({
    channel: channel,
    client: client,
    initialMessage: true // @ts-expect-error
    ,
    message: thread,
    Message: ThreadMessage,
    threadList: true
  }, additionalParentMessageProps)), /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__thread-start"
  }, t && t('Start of a new thread')), /*#__PURE__*/React__default['default'].createElement(MessageList$1, _extends__default['default']({
    hasMore: threadHasMore,
    loadMore: loadMoreThread,
    loadingMore: threadLoadingMore,
    messages: threadMessages,
    Message: ThreadMessage,
    read: read,
    threadList: true
  }, additionalMessageListProps))), smartRender(ThreadMessageInput, _objectSpread$c({
    Input: MessageInputSmall,
    parent: thread,
    focus: autoFocus,
    publishTypingEvent: false
  }, additionalMessageInputProps)));
};

// @ts-check
/**
 * Window - A UI component for conditionally displaying thread or channel.
 *
 * @example ../../docs/Window.md
 * @type { React.FC<import('../types').WindowProps>}
 */

var Window = function Window(_ref) {
  var children = _ref.children,
      _ref$hideOnThread = _ref.hideOnThread,
      hideOnThread = _ref$hideOnThread === void 0 ? false : _ref$hideOnThread;

  var _useContext = React.useContext(ChannelContext),
      thread = _useContext.thread; // If thread is active and window should hide on thread. Return null


  if (thread && hideOnThread) return null;
  return /*#__PURE__*/React__default['default'].createElement("div", {
    className: "str-chat__main-panel"
  }, children);
};

Window.propTypes = {
  /** show or hide the window when a thread is active */
  hideOnThread: PropTypes__default['default'].bool
};
var Window$1 = /*#__PURE__*/React__default['default'].memo(Window);

exports.Attachment = Attachment;
exports.AttachmentActions = DefaultAttachmentActions;
exports.Audio = DefaultAudio;
exports.AutoCompleteTextarea = ReactTextareaAutocomplete;
exports.Avatar = Avatar;
exports.Card = DefaultCard;
exports.Channel = Channel$1;
exports.ChannelContext = ChannelContext;
exports.ChannelHeader = ChannelHeader$1;
exports.ChannelList = ChannelList$1;
exports.ChannelListMessenger = ChannelListMessenger;
exports.ChannelListTeam = ChannelListTeam;
exports.ChannelPreview = ChannelPreview;
exports.ChannelPreviewCompact = ChannelPreviewCompact$1;
exports.ChannelPreviewCountOnly = ChannelPreviewCountOnly$1;
exports.ChannelPreviewLastMessage = ChannelPreviewLastMessage$1;
exports.ChannelPreviewMessenger = ChannelPreviewMessenger$1;
exports.ChannelSearch = ChannelSearch$1;
exports.ChatAutoComplete = ChatAutoComplete$1;
exports.ChatContext = ChatContext;
exports.ChatDown = ChatDown$1;
exports.CommandItem = CommandItem$1;
exports.ConnectionStatus = ConnectionStatus$1;
exports.CustomChat = CustomChat;
exports.DateSeparator = DefaultDateSeparator;
exports.EditMessageForm = EditMessageForm;
exports.EmojiContext = EmojiContext;
exports.EmojiPicker = EmojiPicker;
exports.EmoticonItem = EmoticonItem$1;
exports.EmptyStateIndicator = DefaultEmptyStateIndicator;
exports.EventComponent = EventComponent$1;
exports.FileAttachment = DefaultFile;
exports.FixedHeightMessage = FixedHeightMessage$1;
exports.Gallery = Gallery$1;
exports.ImageComponent = ImageComponent;
exports.InfiniteScroll = InfiniteScroll;
exports.InfiniteScrollPaginator = InfiniteScrollPaginator;
exports.Item = Item;
exports.KEY_CODES = KEY_CODES;
exports.List = List;
exports.LoadMoreButton = DefaultLoadMoreButton;
exports.LoadMorePaginator = LoadMorePaginator$1;
exports.LoadingChannels = LoadingChannels$1;
exports.LoadingErrorIndicator = DefaultLoadingErrorIndicator;
exports.LoadingIndicator = DefaultLoadingIndicator;
exports.MESSAGE_ACTIONS = MESSAGE_ACTIONS;
exports.Message = Message$1;
exports.MessageActions = MessageActions;
exports.MessageActionsBox = MessageActionsBox$1;
exports.MessageCommerce = MessageCommerce$1;
exports.MessageDeleted = MessageDeleted;
exports.MessageInput = MessageInput$1;
exports.MessageInputFlat = MessageInputFlat;
exports.MessageInputLarge = MessageInputLarge;
exports.MessageInputSimple = MessageInputSimple;
exports.MessageInputSmall = MessageInputSmall;
exports.MessageList = MessageList$1;
exports.MessageLivestream = MessageLivestream;
exports.MessageNotification = MessageNotification$1;
exports.MessageOptions = MessageOptions;
exports.MessagePropTypes = MessagePropTypes;
exports.MessageRepliesCountButton = MessageRepliesCountButton$1;
exports.MessageSimple = MessageSimple$1;
exports.MessageTeam = MessageTeam$1;
exports.MessageText = MessageText;
exports.Modal = Modal;
exports.ModalImage = ModalImage;
exports.ModalWrapper = ModalComponent;
exports.ReactionSelector = DefaultReactionSelector;
exports.ReactionsList = DefaultReactionsList;
exports.ReverseInfiniteScroll = ReverseInfiniteScroll;
exports.SafeAnchor = SafeAnchor$1;
exports.SendButton = SendButton;
exports.SimpleReactionsList = DefaultReactionsList$1;
exports.Streami18n = Streami18n;
exports.Thread = Thread$7;
exports.Tooltip = Tooltip$1;
exports.TranslationContext = TranslationContext;
exports.TypingIndicator = DefaultTypingIndicator;
exports.UploadsPreview = UploadsPreview;
exports.UserItem = UserItem$1;
exports.VirtualizedMessageList = VirtualizedMessageListWithContext;
exports.Window = Window$1;
exports.areMessagePropsEqual = areMessagePropsEqual;
exports.byDate = byDate;
exports.checkChannelPropType = checkChannelPropType;
exports.checkClientPropType = checkClientPropType;
exports.defaultPinPermissions = defaultPinPermissions;
exports.defaultScrollToItem = defaultScrollToItem;
exports.enTranslations = enTranslations;
exports.frTranslations = frTranslations;
exports.generateRandomId = generateRandomId;
exports.getImages = getImages;
exports.getMessageActions = getMessageActions;
exports.getNonImageAttachments = getNonImageAttachments;
exports.getReadByTooltipText = getReadByTooltipText;
exports.handleActionWarning = handleActionWarning;
exports.hiTranslations = hiTranslations;
exports.isOnlyEmojis = isOnlyEmojis;
exports.isPromise = isPromise;
exports.isUserMuted = isUserMuted;
exports.itTranslations = itTranslations;
exports.listener = Listeners;
exports.messageHasAttachments = messageHasAttachments;
exports.messageHasReactions = messageHasReactions;
exports.missingUseFlagHandlerParameterWarning = missingUseFlagHandlerParameterWarning;
exports.missingUseMuteHandlerParamsWarning = missingUseMuteHandlerParamsWarning;
exports.nlTranslations = nlTranslations;
exports.reactionHandlerWarning = reactionHandlerWarning;
exports.renderText = renderText;
exports.ruTranslations = ruTranslations;
exports.shouldMessageComponentUpdate = shouldMessageComponentUpdate;
exports.smartRender = smartRender;
exports.trTranslations = trTranslations;
exports.truncate = truncate;
exports.useActionHandler = useActionHandler;
exports.useChannelEditMessageHandler = useEditMessageHandler;
exports.useChannelMentionsHandler = useMentionsHandlers;
exports.useDeleteHandler = useDeleteHandler;
exports.useEditHandler = useEditHandler;
exports.useFlagHandler = useFlagHandler;
exports.useMentionsHandler = useMentionsHandler;
exports.useMentionsUIHandler = useMentionsUIHandler;
exports.useMessageInput = useMessageInput;
exports.useMuteHandler = useMuteHandler;
exports.useOpenThreadHandler = useOpenThreadHandler;
exports.usePinHandler = usePinHandler;
exports.useReactionClick = useReactionClick;
exports.useReactionHandler = useReactionHandler;
exports.useRetryHandler = useRetryHandler;
exports.useUserHandler = useUserHandler;
exports.useUserRole = useUserRole;
exports.validateAndGetMessage = validateAndGetMessage;
exports.withChannelContext = withChannelContext;
exports.withChatContext = withChatContext;
exports.withEmojiContext = withEmojiContext;
exports.withTranslationContext = withTranslationContext;
//# sourceMappingURL=index.js.map
